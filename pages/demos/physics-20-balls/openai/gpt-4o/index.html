<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OpenRouter API Response</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            max-width: 900px;
            margin: 0 auto;
            padding: 2rem;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        .container {
            background: white;
            border-radius: 16px;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            padding: 2rem;
        }
        h1 {
            color: #1a202c;
            margin-bottom: 1.5rem;
            font-size: 2rem;
        }
        .metadata {
            background: #f7fafc;
            border-left: 4px solid #667eea;
            padding: 1rem;
            margin-bottom: 2rem;
            border-radius: 4px;
        }
        .metadata p {
            margin: 0.5rem 0;
            color: #4a5568;
        }
        .metadata strong {
            color: #2d3748;
        }
        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 1rem;
            margin-bottom: 2rem;
        }
        .metric-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 1rem;
            border-radius: 8px;
            text-align: center;
        }
        .metric-value {
            font-size: 1.5rem;
            font-weight: bold;
        }
        .metric-label {
            font-size: 0.875rem;
            opacity: 0.9;
        }
        .prompt-section, .response-section {
            margin-bottom: 2rem;
        }
        .section-title {
            font-size: 1.25rem;
            font-weight: 600;
            color: #2d3748;
            margin-bottom: 1rem;
        }
        .content-box {
            background: #f9fafb;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 1.5rem;
            white-space: pre-wrap;
            word-wrap: break-word;
            color: #2d3748;
            line-height: 1.6;
        }
        .response-content {
            background: white;
            border: 2px solid #667eea;
        }
        code {
            background: #edf2f7;
            padding: 0.2rem 0.4rem;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
        }
        pre {
            background: #2d3748;
            color: #e2e8f0;
            padding: 1rem;
            border-radius: 8px;
            overflow-x: auto;
        }
        pre code {
            background: transparent;
            padding: 0;
            color: inherit;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ü§ñ OpenRouter API Response</h1>
        
        <div class="metadata">
            <p><strong>Model:</strong> openai/gpt-4o</p>
            <p><strong>Generated:</strong> 2025-10-01T23:55:24.738Z</p>
        </div>
        
        <div class="metrics">
            <div class="metric-card">
                <div class="metric-value">1029</div>
                <div class="metric-label">Total Tokens</div>
            </div>
            <div class="metric-card">
                <div class="metric-value">13.122s</div>
                <div class="metric-label">Duration</div>
            </div>
            <div class="metric-card">
                <div class="metric-value">$0.0098</div>
                <div class="metric-label">Total Cost</div>
            </div>
        </div>
        
        <div class="prompt-section">
            <div class="section-title">üìù Prompt</div>
            <div class="content-box">In a single HTML file named index.html, create a simulation of 20 balls (they follow the rules of gravity and physics) which start in the center of a spinning 2D hexagon. Gravity should change from the bottom to the top every 5 seconds.
</div>
        </div>
        
        <div class="response-section">
            <div class="section-title">üí¨ Response</div>
            <div class="content-box response-content">Creating a simulation of 20 balls within a spinning hexagon with gravity changing every 5 seconds is a complex task that involves several steps. Below is a simple implementation using HTML, CSS, and JavaScript with the help of the HTML5 Canvas to draw and animate the scene. This example uses basic physics and animation principles to achieve the desired effect.<br><br><pre><code>&lt;!DOCTYPE html&gt;<br>&lt;html lang=&quot;en&quot;&gt;<br>&lt;head&gt;<br>    &lt;meta charset=&quot;UTF-8&quot;&gt;<br>    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;<br>    &lt;title&gt;Hexagon Ball Simulation&lt;/title&gt;<br>    &lt;style&gt;<br>        body {<br>            margin: 0;<br>            overflow: hidden;<br>            display: flex;<br>            justify-content: center;<br>            align-items: center;<br>            height: 100vh;<br>            background-color: #f0f0f0;<br>        }<br>        canvas {<br>            background: white;<br>        }<br>    &lt;/style&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>    &lt;canvas id=&quot;canvas&quot;&gt;&lt;/canvas&gt;<br>    &lt;script&gt;<br>        const canvas = document.getElementById(&#039;canvas&#039;);<br>        const ctx = canvas.getContext(&#039;2d&#039;);<br>        canvas.width = window.innerWidth;<br>        canvas.height = window.innerHeight;<br><br>        const numBalls = 20;<br>        const balls = [];<br>        const hexagonRadius = 200;<br>        const hexagonCenter = { x: canvas.width / 2, y: canvas.height / 2 };<br>        let gravity = 0.1;<br>        let gravityDirection = 1;<br><br>        class Ball {<br>            constructor(x, y) {<br>                this.x = x;<br>                this.y = y;<br>                this.radius = 5;<br>                this.vx = Math.random() * 2 - 1;<br>                this.vy = Math.random() * 2 - 1;<br>            }<br><br>            update() {<br>                this.vy += gravity * gravityDirection;<br>                this.x += this.vx;<br>                this.y += this.vy;<br><br>                // Bounce off hexagon walls<br>                if (this.x + this.radius &gt; hexagonCenter.x + hexagonRadius ||<br>                    this.x - this.radius &lt; hexagonCenter.x - hexagonRadius ||<br>                    this.y + this.radius &gt; hexagonCenter.y + hexagonRadius ||<br>                    this.y - this.radius &lt; hexagonCenter.y - hexagonRadius) {<br>                    this.vx *= -1;<br>                    this.vy *= -1;<br>                }<br>            }<br><br>            draw() {<br>                ctx.beginPath();<br>                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);<br>                ctx.fillStyle = &#039;blue&#039;;<br>                ctx.fill();<br>                ctx.closePath();<br>            }<br>        }<br><br>        function drawHexagon() {<br>            ctx.save();<br>            ctx.translate(hexagonCenter.x, hexagonCenter.y);<br>            ctx.rotate(Date.now() / 1000); // Rotate the hexagon<br>            ctx.beginPath();<br>            for (let i = 0; i &lt; 6; i++) {<br>                const angle = Math.PI / 3 * i;<br>                const x = hexagonRadius * Math.cos(angle);<br>                const y = hexagonRadius * Math.sin(angle);<br>                ctx.lineTo(x, y);<br>            }<br>            ctx.closePath();<br>            ctx.strokeStyle = &#039;black&#039;;<br>            ctx.stroke();<br>            ctx.restore();<br>        }<br><br>        function updateGravityDirection() {<br>            gravityDirection *= -1;<br>        }<br><br>        function init() {<br>            for (let i = 0; i &lt; numBalls; i++) {<br>                balls.push(new Ball(hexagonCenter.x, hexagonCenter.y));<br>            }<br>            setInterval(updateGravityDirection, 5000);<br>        }<br><br>        function animate() {<br>            ctx.clearRect(0, 0, canvas.width, canvas.height);<br>            drawHexagon();<br>            balls.forEach(ball =&gt; {<br>                ball.update();<br>                ball.draw();<br>            });<br>            requestAnimationFrame(animate);<br>        }<br><br>        init();<br>        animate();<br>    &lt;/script&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;</code></pre><br><br>### Explanation:<br>1. **Canvas Setup**: A canvas is used to draw the hexagon and animate the balls.<br>2. **Hexagon**: The hexagon is drawn with a rotating transformation applied every frame.<br>3. **Balls**: Each ball is updated with a simple physics model, adjusting its position based on velocity and gravity.<br>4. **Gravity Change**: The direction of gravity is toggled every 5 seconds using a setInterval function.<br>5. **Animation Loop**: <code>requestAnimationFrame</code> is used to create a smooth animation loop.<br><br>This example provides a basic foundation and can be extended with more sophisticated physics, collision detection, and additional features like friction or more complex boundary conditions for the hexagon.</div>
        </div>
    </div>
</body>
</html>