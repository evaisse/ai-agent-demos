<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Hexagon Ball Physics Simulation</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #222;
    }
    canvas {
      display: block;
      margin: 0 auto;
      background: #222;
    }
  </style>
</head>
<body>
<canvas id="sim"></canvas>
<script>
const canvas = document.getElementById('sim');
const ctx = canvas.getContext('2d');
let W = window.innerWidth;
let H = window.innerHeight;
canvas.width = W;
canvas.height = H;

function resize() {
  W = window.innerWidth;
  H = window.innerHeight;
  canvas.width = W;
  canvas.height = H;
}
window.addEventListener('resize', resize);

// Hexagon parameters
const hexRadius = Math.min(W, H) * 0.35;
const hexSides = 6;
let hexAngle = 0;
const hexSpinSpeed = Math.PI / 8 / 60; // radians per frame

// Ball parameters
const BALL_COUNT = 20;
const BALL_RADIUS = 16;
const BALL_COLOR = "#ffec70";
const RESTITUTION = 0.8;

// Gravity
let gravity = {x: 0, y: 0.5};
let gravitySign = 1;
setInterval(() => {
  gravitySign *= -1;
  gravity.y = 0.5 * gravitySign;
}, 5000);

// Ball class
class Ball {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.vx = (Math.random()-0.5)*2;
    this.vy = (Math.random()-0.5)*2;
    this.radius = BALL_RADIUS;
  }
  update() {
    this.vx += gravity.x;
    this.vy += gravity.y;

    this.x += this.vx;
    this.y += this.vy;
  }
  draw(ctx) {
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.radius, 0, 2*Math.PI);
    ctx.fillStyle = BALL_COLOR;
    ctx.shadowColor = "#fffbc5";
    ctx.shadowBlur = 8;
    ctx.fill();
    ctx.shadowBlur = 0;
    ctx.strokeStyle = "#b4a13e";
    ctx.lineWidth = 2;
    ctx.stroke();
  }
}

// Generate hexagon vertices
function getHexVertices(cx, cy, radius, angle) {
  const verts = [];
  for (let i = 0; i < hexSides; i++) {
    let a = angle + i * 2 * Math.PI / hexSides;
    verts.push({
      x: cx + radius * Math.cos(a),
      y: cy + radius * Math.sin(a)
    });
  }
  return verts;
}

// Project point onto line segment
function projectPointToSegment(px, py, x1, y1, x2, y2) {
  const dx = x2 - x1, dy = y2 - y1;
  if (dx === 0 && dy === 0) return {x: x1, y: y1};
  const t = Math.max(0, Math.min(1, ((px - x1) * dx + (py - y1) * dy) / (dx*dx + dy*dy)));
  return {x: x1 + t * dx, y: y1 + t * dy};
}

// Collision between ball and hexagon
function resolveBallHexCollision(ball, verts) {
  // Find closest edge and distance
  let minDist = Infinity, closest = null, normal = null;
  for (let i = 0; i < verts.length; i++) {
    let v1 = verts[i];
    let v2 = verts[(i+1)%verts.length];
    let proj = projectPointToSegment(ball.x, ball.y, v1.x, v1.y, v2.x, v2.y);
    let dx = ball.x - proj.x, dy = ball.y - proj.y;
    let dist = Math.sqrt(dx*dx + dy*dy);
    if (dist < minDist) {
      minDist = dist;
      closest = proj;
      // Normal: perpendicular to edge, pointing inside
      let nx = v2.y - v1.y;
      let ny = -(v2.x - v1.x);
      let len = Math.sqrt(nx*nx + ny*ny);
      nx /= len; ny /= len;
      // Ensure normal points inward (from edge to center)
      let cx = (v1.x + v2.x)/2, cy = (v1.y + v2.y)/2;
      let toCenterX = W/2 - cx, toCenterY = H/2 - cy;
      if ((nx*toCenterX + ny*toCenterY) < 0) { nx *= -1; ny *= -1; }
      normal = {x: nx, y: ny};
    }
  }
  if (minDist < ball.radius) {
    // Push out
    ball.x += normal.x * (ball.radius - minDist);
    ball.y += normal.y * (ball.radius - minDist);
    // Reflect velocity
    let dot = ball.vx * normal.x + ball.vy * normal.y;
    ball.vx -= (1 + RESTITUTION) * dot * normal.x;
    ball.vy -= (1 + RESTITUTION) * dot * normal.y;
    // Dampen perpendicular velocity
    ball.vx *= 0.98;
    ball.vy *= 0.98;
  }
}

// Create balls in the center
const balls = [];
for (let i = 0; i < BALL_COUNT; i++) {
  balls.push(new Ball(W/2, H/2));
}

// Animation loop
function animate() {
  ctx.clearRect(0, 0, W, H);

  // Rotate hexagon
  hexAngle += hexSpinSpeed;
  const hexVerts = getHexVertices(W/2, H/2, hexRadius, hexAngle);

  // Draw hexagon
  ctx.save();
  ctx.beginPath();
  ctx.moveTo(hexVerts[0].x, hexVerts[0].y);
  for (let v of hexVerts) ctx.lineTo(v.x, v.y);
  ctx.closePath();
  ctx.strokeStyle = "#5ee3fa";
  ctx.lineWidth = 8;
  ctx.shadowColor = "#4a9abf";
  ctx.shadowBlur = 16;
  ctx.stroke();
  ctx.shadowBlur = 0;
  ctx.restore();

  // Update and draw balls
  for (let ball of balls) {
    ball.update();
    resolveBallHexCollision(ball, hexVerts);
    ball.draw(ctx);
  }

  requestAnimationFrame(animate);
}

animate();
</script>
</body>
</html>
