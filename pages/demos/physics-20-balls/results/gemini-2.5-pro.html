<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spinning Hexagon Ball Simulation</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
        }
        canvas {
            display: block;
        }
        .info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: monospace;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div class="info" id="gravity-status">Gravity: Down</div>
    <canvas id="simulationCanvas"></canvas>

    <script>
        // --- Setup ---
        const canvas = document.getElementById('simulationCanvas');
        const ctx = canvas.getContext('2d');
        const gravityStatus = document.getElementById('gravity-status');

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // --- Configuration ---
        const ballCount = 20;
        const balls = [];
        let gravity = { y: 0.3 }; // Initial gravity downwards
        const hexagon = {
            x: canvas.width / 2,
            y: canvas.height / 2,
            size: Math.min(canvas.width, canvas.height) / 2.5,
            rotation: 0,
            spinSpeed: 0.003
        };

        // --- Ball Class ---
        class Ball {
            constructor(x, y) {
                this.radius = Math.random() * 8 + 4; // Random size
                this.mass = this.radius * 0.5;
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 4; // Random initial velocity
                this.vy = (Math.random() - 0.5) * 4;
                this.color = `hsl(${Math.random() * 360}, 100%, 75%)`;
                this.dampening = 0.85; // Energy loss on bounce
            }

            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
                ctx.closePath();
            }

            update() {
                // Apply gravity
                this.vy += gravity.y * this.mass * 0.2;

                // Update position based on velocity
                this.x += this.vx;
                this.y += this.vy;
                
                // --- Collision Detection (simplified) ---
                // For simplicity, we treat the hexagon boundary as a circle for physics.
                // This keeps the balls contained within the spinning visual.
                const distFromCenter = Math.sqrt((this.x - hexagon.x) ** 2 + (this.y - hexagon.y) ** 2);
                if (distFromCenter + this.radius > hexagon.size) {
                    // Move ball back inside the boundary to prevent it from getting stuck
                    const overlap = distFromCenter + this.radius - hexagon.size;
                    const angle = Math.atan2(this.y - hexagon.y, this.x - hexagon.x);
                    this.x -= overlap * Math.cos(angle);
                    this.y -= overlap * Math.sin(angle);

                    // Calculate bounce vector
                    const normal = { x: this.x - hexagon.x, y: this.y - hexagon.y };
                    const normalMag = Math.sqrt(normal.x * normal.x + normal.y * normal.y);
                    normal.x /= normalMag;
                    normal.y /= normalMag;

                    const dotProduct = this.vx * normal.x + this.vy * normal.y;
                    this.vx = (this.vx - 2 * dotProduct * normal.x) * this.dampening;
                    this.vy = (this.vy - 2 * dotProduct * normal.y) * this.dampening;
                }
            }
        }

        // --- Hexagon Drawing Function ---
        function drawHexagon() {
            ctx.save();
            ctx.translate(hexagon.x, hexagon.y);
            ctx.rotate(hexagon.rotation); // Apply rotation
            ctx.beginPath();
            for (let i = 0; i < 6; i++) {
                const angle = (Math.PI / 3) * i;
                const x = hexagon.size * Math.cos(angle);
                const y = hexagon.size * Math.sin(angle);
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.closePath();
            ctx.strokeStyle = '#00FFFF'; // Cyan color
            ctx.lineWidth = 4;
            ctx.stroke();
            ctx.restore();
        }

        // --- Initialization Function ---
        function init() {
            for (let i = 0; i < ballCount; i++) {
                // Start all balls in the center of the hexagon
                balls.push(new Ball(hexagon.x, hexagon.y));
            }

            // --- Gravity Switcher ---
            setInterval(() => {
                gravity.y *= -1; // Invert gravity
                gravityStatus.textContent = gravity.y > 0 ? 'Gravity: Down' : 'Gravity: Up';
            }, 5000);
        }

        // --- Animation Loop ---
        function animate() {
            // Use a semi-transparent background for a motion blur effect
            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Update hexagon rotation and draw it
            hexagon.rotation += hexagon.spinSpeed;
            drawHexagon();

            // Update and draw each ball
            balls.forEach(ball => {
                ball.update();
                ball.draw();
            });

            // Loop the animation
            requestAnimationFrame(animate);
        }

        // --- Event Listener for Window Resize ---
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            hexagon.x = canvas.width / 2;
            hexagon.y = canvas.height / 2;
            hexagon.size = Math.min(canvas.width, canvas.height) / 2.5;
            // No need to reset balls, they will adapt to the new boundaries
        });

        // --- Start the simulation ---
        init();
        animate();
    </script>
</body>
</html>
