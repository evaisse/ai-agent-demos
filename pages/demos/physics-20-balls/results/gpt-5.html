<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Hexagon Gravity Balls</title>
  <style>
    /* Keep code and docs in English (see AGENTS.md). */
    html, body { height: 100%; }
    body { margin: 0; background: #0e0f13; color: #eaeaea; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    canvas { display: block; width: 100vw; height: 100vh; }
    .overlay { position: fixed; left: 12px; top: 10px; font-size: 12px; opacity: 0.8; user-select: none; }
  </style>
</head>
<body>
  <canvas id="c"></canvas>
  <div class="overlay" id="overlay"></div>
  <script>
    // Configuration
    const NUM_BALLS = 20;
    const BALL_RADIUS = 8;
    const RESTITUTION_WALL = 0.9;
    const RESTITUTION_BALL = 0.98;
    const FRICTION_TANGENTIAL = 0.01;
    const OMEGA = 0.3;           // hexagon angular velocity (rad/s)
    const GRAVITY_MAG = 800;     // px/s^2
    const GRAVITY_SWITCH_MS = 5000;

    // Canvas + HiDPI
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d');
    const overlay = document.getElementById('overlay');
    let dpr = window.devicePixelRatio || 1;

    function resize() {
      dpr = window.devicePixelRatio || 1;
      const w = Math.floor(window.innerWidth);
      const h = Math.floor(window.innerHeight);
      canvas.style.width = w + 'px';
      canvas.style.height = h + 'px';
      canvas.width = Math.floor(w * dpr);
      canvas.height = Math.floor(h * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // logical units == CSS pixels
      computeHexGeometry();
    }
    window.addEventListener('resize', resize);

    // Hexagon geometry
    let hex = {
      center: { x: 0, y: 0 },
      apothem: 0,
      radius: 0,   // circumradius (center to vertex)
      angle: 0,
      points: []
    };

    function computeHexGeometry() {
      const w = window.innerWidth;
      const h = window.innerHeight;
      hex.center.x = w / 2;
      hex.center.y = h / 2;
      const margin = 24 + BALL_RADIUS * 2;
      const a = Math.max(40, Math.min(w, h) * 0.4 - margin); // apothem (center to side)
      hex.apothem = a;
      hex.radius = (2 * a) / Math.sqrt(3); // circumradius (R = 2a/âˆš3)
      hex.points = computeHexPoints(hex.center, hex.radius, hex.angle);
    }

    function computeHexPoints(center, R, angle) {
      const pts = [];
      for (let k = 0; k < 6; k++) {
        const t = angle + k * Math.PI / 3;
        pts.push({ x: center.x + R * Math.cos(t), y: center.y + R * Math.sin(t) });
      }
      return pts;
    }

    function edgeNormalOutward(p1, p2, center) {
      const ex = p2.x - p1.x, ey = p2.y - p1.y;
      // Candidate normal
      let nx = ey, ny = -ex;
      const len = Math.hypot(nx, ny) || 1;
      nx /= len; ny /= len;
      // Ensure it points outward: flip if it faces the center
      const mx = (p1.x + p2.x) * 0.5, my = (p1.y + p2.y) * 0.5;
      const toCenterX = center.x - mx, toCenterY = center.y - my;
      if (nx * toCenterX + ny * toCenterY > 0) {
        nx = -nx; ny = -ny;
      }
      return { x: nx, y: ny };
    }

    // Ball model
    class Ball {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        const angle = Math.random() * Math.PI * 2;
        const speed = 60 + Math.random() * 80;
        this.vx = Math.cos(angle) * speed;
        this.vy = Math.sin(angle) * speed;
        this.r = BALL_RADIUS;
        this.m = 1;
      }

      integrate(dt, gy) {
        this.vy += gy * dt;          // gravity
        this.x += this.vx * dt;      // position
        this.y += this.vy * dt;
      }

      collideWithWalls() {
        const pts = hex.points;
        for (let i = 0; i < 6; i++) {
          const p1 = pts[i];
          const p2 = pts[(i + 1) % 6];
          const n = edgeNormalOutward(p1, p2, hex.center);

          const dx = this.x - p1.x;
          const dy = this.y - p1.y;
          const d = dx * n.x + dy * n.y;   // >0 means toward outside
          const overlap = d + this.r;      // penetration beyond allowed distance (-r)
          if (overlap > 0) {
            // Push back inside
            this.x -= n.x * overlap;
            this.y -= n.y * overlap;

            // Reflect velocity if moving outward
            const vn = this.vx * n.x + this.vy * n.y;
            if (vn > 0) {
              this.vx -= (1 + RESTITUTION_WALL) * vn * n.x;
              this.vy -= (1 + RESTITUTION_WALL) * vn * n.y;

              // Tangential friction (slight energy loss)
              const tx = -n.y, ty = n.x;
              const vt = this.vx * tx + this.vy * ty;
              const vtAfter = vt * (1 - FRICTION_TANGENTIAL);
              this.vx += (vtAfter - vt) * tx;
              this.vy += (vtAfter - vt) * ty;
            }
          }
        }
      }
    }

    const balls = [];

    // Gravity switching
    let gravitySign = 1;
    let lastSwitch = performance.now();
    function updateGravity(now) {
      if (now - lastSwitch >= GRAVITY_SWITCH_MS) {
        gravitySign *= -1;
        lastSwitch = now;
      }
    }

    // Simulation loop
    let last = performance.now();

    function init() {
      resize();
      balls.length = 0;
      for (let i = 0; i < NUM_BALLS; i++) {
        balls.push(new Ball(hex.center.x, hex.center.y)); // all start at center
      }
      requestAnimationFrame(loop);
    }

    function loop(now) {
      const dtRaw = (now - last) / 1000;
      last = now;
      const dt = Math.min(0.033, Math.max(0.001, dtRaw)); // clamp for stability

      // Rotate hexagon
      hex.angle += OMEGA * dt;
      hex.points = computeHexPoints(hex.center, hex.radius, hex.angle);

      // Gravity toggle
      updateGravity(now);
      const gy = gravitySign * GRAVITY_MAG;

      // Integrate dynamics
      for (const b of balls) b.integrate(dt, gy);

      // Ball-ball collisions (elastic, equal mass)
      resolveBallCollisions();

      // Walls
      for (const b of balls) b.collideWithWalls();

      // Render
      render(gy);

      requestAnimationFrame(loop);
    }

    function resolveBallCollisions() {
      for (let i = 0; i < balls.length; i++) {
        for (let j = i + 1; j < balls.length; j++) {
          const a = balls[i], b = balls[j];
          const dx = b.x - a.x;
          const dy = b.y - a.y;
          const dist = Math.hypot(dx, dy);
          const minDist = a.r + b.r;
          if (dist > 0 && dist < minDist) {
            // Positional correction (split overlap)
            const overlap = minDist - dist;
            const nx = dx / dist, ny = dy / dist;
            a.x -= nx * overlap * 0.5; a.y -= ny * overlap * 0.5;
            b.x += nx * overlap * 0.5; b.y += ny * overlap * 0.5;

            // Relative velocity along normal
            const rvx = b.vx - a.vx;
            const rvy = b.vy - a.vy;
            const relVelN = rvx * nx + rvy * ny;

            if (relVelN > 0) {
              // Elastic impulse (equal masses)
              const j = -(1 + RESTITUTION_BALL) * relVelN / (1 / a.m + 1 / b.m);
              const ix = j * nx, iy = j * ny;
              a.vx -= ix / a.m; a.vy -= iy / a.m;
              b.vx += ix / b.m; b.vy += iy / b.m;
            }
          }
        }
      }
    }

    function render(gy) {
      const w = window.innerWidth;
      const h = window.innerHeight;

      ctx.clearRect(0, 0, w, h);

      // Hexagon
      ctx.save();
      ctx.lineWidth = 3;
      ctx.strokeStyle = '#5bd1ff';
      ctx.fillStyle = 'rgba(91, 209, 255, 0.06)';
      const pts = hex.points;
      ctx.beginPath();
      ctx.moveTo(pts[0].x, pts[0].y);
      for (let i = 1; i < pts.length; i++) ctx.lineTo(pts[i].x, pts[i].y);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      ctx.restore();

      // Balls
      for (const b of balls) {
        ctx.beginPath();
        ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
        ctx.fillStyle = '#ffd166';
        ctx.strokeStyle = '#ef476f';
        ctx.lineWidth = 1.5;
        ctx.fill();
        ctx.stroke();
      }

      // Overlay
      overlay.textContent = `Gravity: ${gy > 0 ? 'Down' : 'Up'}  |  Balls: ${NUM_BALLS}`;
    }

    init();
  </script>
</body>
</html>
