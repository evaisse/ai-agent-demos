<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hexagon Ball Physics Simulation</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: Arial, sans-serif;
        }
        canvas {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        }
        .info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div class="info">
        <div>Gravity Direction: <span id="gravityDir">DOWN</span></div>
        <div>Next Switch: <span id="countdown">5</span>s</div>
    </div>
    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        canvas.width = 800;
        canvas.height = 800;
        
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        
        // Physics constants
        const GRAVITY = 0.3;
        const DAMPING = 0.98;
        const FRICTION = 0.99;
        const BALL_RADIUS = 8;
        const HEXAGON_RADIUS = 200;
        
        // Gravity state
        let gravityDirection = 1; // 1 = down, -1 = up
        let lastGravitySwitch = Date.now();
        
        // Ball class
        class Ball {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = (Math.random() - 0.5) * 2;
                this.radius = BALL_RADIUS;
                this.color = `hsl(${Math.random() * 360}, 70%, 60%)`;
            }
            
            update() {
                // Apply gravity
                this.vy += GRAVITY * gravityDirection;
                
                // Apply velocity
                this.x += this.vx;
                this.y += this.vy;
                
                // Apply damping
                this.vx *= DAMPING;
                this.vy *= DAMPING;
                
                // Check collision with hexagon walls
                this.checkHexagonCollision();
            }
            
            checkHexagonCollision() {
                const hexagonPoints = getHexagonPoints();
                
                // Check collision with each edge of the hexagon
                for (let i = 0; i < hexagonPoints.length; i++) {
                    const p1 = hexagonPoints[i];
                    const p2 = hexagonPoints[(i + 1) % hexagonPoints.length];
                    
                    // Calculate distance from ball to line segment
                    const collision = this.checkLineCollision(p1, p2);
                    
                    if (collision) {
                        // Reflect velocity
                        const normal = collision.normal;
                        const dot = this.vx * normal.x + this.vy * normal.y;
                        
                        this.vx -= 2 * dot * normal.x;
                        this.vy -= 2 * dot * normal.y;
                        
                        // Apply friction
                        this.vx *= FRICTION;
                        this.vy *= FRICTION;
                        
                        // Move ball outside the wall
                        this.x = collision.x;
                        this.y = collision.y;
                    }
                }
            }
            
            checkLineCollision(p1, p2) {
                // Vector from p1 to p2
                const dx = p2.x - p1.x;
                const dy = p2.y - p1.y;
                const len = Math.sqrt(dx * dx + dy * dy);
                
                // Normalized direction
                const nx = dx / len;
                const ny = dy / len;
                
                // Vector from p1 to ball
                const bx = this.x - p1.x;
                const by = this.y - p1.y;
                
                // Project ball onto line
                const dot = bx * nx + by * ny;
                const clampedDot = Math.max(0, Math.min(len, dot));
                
                // Closest point on line
                const closestX = p1.x + nx * clampedDot;
                const closestY = p1.y + ny * clampedDot;
                
                // Distance to closest point
                const distX = this.x - closestX;
                const distY = this.y - closestY;
                const distance = Math.sqrt(distX * distX + distY * distY);
                
                if (distance < this.radius) {
                    // Collision detected
                    const normalX = distX / distance;
                    const normalY = distY / distance;
                    
                    return {
                        x: closestX + normalX * this.radius,
                        y: closestY + normalY * this.radius,
                        normal: { x: normalX, y: normalY }
                    };
                }
                
                return null;
            }
            
            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        }
        
        // Create balls
        const balls = [];
        for (let i = 0; i < 20; i++) {
            balls.push(new Ball(centerX, centerY));
        }
        
        // Hexagon rotation
        let hexagonRotation = 0;
        
        function getHexagonPoints() {
            const points = [];
            for (let i = 0; i < 6; i++) {
                const angle = (Math.PI / 3) * i + hexagonRotation;
                points.push({
                    x: centerX + Math.cos(angle) * HEXAGON_RADIUS,
                    y: centerY + Math.sin(angle) * HEXAGON_RADIUS
                });
            }
            return points;
        }
        
        function drawHexagon() {
            const points = getHexagonPoints();
            
            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            for (let i = 1; i < points.length; i++) {
                ctx.lineTo(points[i].x, points[i].y);
            }
            ctx.closePath();
            
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.lineWidth = 4;
            ctx.stroke();
            
            ctx.fillStyle = 'rgba(255, 255, 255, 0.05)';
            ctx.fill();
        }
        
        function updateGravity() {
            const now = Date.now();
            const elapsed = (now - lastGravitySwitch) / 1000;
            const countdown = Math.ceil(5 - elapsed);
            
            document.getElementById('countdown').textContent = countdown;
            
            if (elapsed >= 5) {
                gravityDirection *= -1;
                lastGravitySwitch = now;
                
                document.getElementById('gravityDir').textContent = 
                    gravityDirection === 1 ? 'DOWN' : 'UP';
            }
        }
        
        function animate() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Update hexagon rotation
            hexagonRotation += 0.01;
            
            // Draw hexagon
            drawHexagon();
            
            // Update and draw balls
            balls.forEach(ball => {
                ball.update();
                ball.draw();
            });
            
            // Update gravity info
            updateGravity();
            
            requestAnimationFrame(animate);
        }
        
        animate();
    </script>
</body>
</html>
