<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OpenRouter API Response</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            max-width: 900px;
            margin: 0 auto;
            padding: 2rem;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        .container {
            background: white;
            border-radius: 16px;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            padding: 2rem;
        }
        h1 {
            color: #1a202c;
            margin-bottom: 1.5rem;
            font-size: 2rem;
        }
        .metadata {
            background: #f7fafc;
            border-left: 4px solid #667eea;
            padding: 1rem;
            margin-bottom: 2rem;
            border-radius: 4px;
        }
        .metadata p {
            margin: 0.5rem 0;
            color: #4a5568;
        }
        .metadata strong {
            color: #2d3748;
        }
        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 1rem;
            margin-bottom: 2rem;
        }
        .metric-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 1rem;
            border-radius: 8px;
            text-align: center;
        }
        .metric-value {
            font-size: 1.5rem;
            font-weight: bold;
        }
        .metric-label {
            font-size: 0.875rem;
            opacity: 0.9;
        }
        .prompt-section, .response-section {
            margin-bottom: 2rem;
        }
        .section-title {
            font-size: 1.25rem;
            font-weight: 600;
            color: #2d3748;
            margin-bottom: 1rem;
        }
        .content-box {
            background: #f9fafb;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 1.5rem;
            white-space: pre-wrap;
            word-wrap: break-word;
            color: #2d3748;
            line-height: 1.6;
        }
        .response-content {
            background: white;
            border: 2px solid #667eea;
        }
        code {
            background: #edf2f7;
            padding: 0.2rem 0.4rem;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
        }
        pre {
            background: #2d3748;
            color: #e2e8f0;
            padding: 1rem;
            border-radius: 8px;
            overflow-x: auto;
        }
        pre code {
            background: transparent;
            padding: 0;
            color: inherit;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ü§ñ OpenRouter API Response</h1>
        
        <div class="metadata">
            <p><strong>Model:</strong> google/gemini-2.5-flash-lite-preview-06-17</p>
            <p><strong>Generated:</strong> 2025-10-06T11:41:24.063Z</p>
        </div>
        
        <div class="metrics">
            <div class="metric-card">
                <div class="metric-value">7908</div>
                <div class="metric-label">Total Tokens</div>
            </div>
            <div class="metric-card">
                <div class="metric-value">6.284s</div>
                <div class="metric-label">Duration</div>
            </div>
            <div class="metric-card">
                <div class="metric-value">$0.0032</div>
                <div class="metric-label">Total Cost</div>
            </div>
        </div>
        
        <div class="prompt-section">
            <div class="section-title">üìù Prompt</div>
            <div class="content-box">In a single HTML file named index.html, create exact copy of the PAC-MAN game in one html file using css and js.
</div>
        </div>
        
        <div class="response-section">
            <div class="section-title">üí¨ Response</div>
            <div class="content-box response-content">Creating an **exact copy** of the original PAC-MAN game in a single HTML file with CSS and JavaScript is a **highly complex undertaking** and would result in a very, very long and intricate file. The original arcade game involved many sprites, animations, sound effects, AI for the ghosts, collision detection, scoring, levels, and a game loop.<br><br>However, I can provide you with a **simplified, functional version** of PAC-MAN within a single <code>index.html</code> file. This version will demonstrate the core mechanics:<br><br>*   **Player Movement:** PAC-MAN moving around the maze.<br>*   **Pellets:** Collectible dots.<br>*   **Walls:** Impassable maze boundaries.<br>*   **Basic Ghost Movement (simplified):** Ghosts will move around.<br>*   **Game Over Condition:** PAC-MAN losing a life.<br>*   **Scoring:** Basic score tracking.<br><br>**This will NOT be an exact arcade replica** due to the sheer amount of detail involved. For a true arcade experience, you&#039;d typically see more sophisticated graphics, sound design, and complex AI.<br><br>Here&#039;s the <code>index.html</code> file. I&#039;ve tried to keep it as self-contained and readable as possible.<br><br><pre><code>&lt;!DOCTYPE html&gt;<br>&lt;html lang=&quot;en&quot;&gt;<br>&lt;head&gt;<br>    &lt;meta charset=&quot;UTF-8&quot;&gt;<br>    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;<br>    &lt;title&gt;PAC-MAN (Simplified)&lt;/title&gt;<br>    &lt;style&gt;<br>        body {<br>            display: flex;<br>            justify-content: center;<br>            align-items: center;<br>            min-height: 100vh;<br>            background-color: #000;<br>            margin: 0;<br>            font-family: &#039;Press Start 2P&#039;, cursive; /* A pixelated font for the feel */<br>            color: white;<br>            flex-direction: column;<br>        }<br><br>        #game-container {<br>            position: relative;<br>            width: 500px; /* Adjust as needed */<br>            height: 500px; /* Adjust as needed */<br>            border: 2px solid #fff;<br>            background-color: #000;<br>            overflow: hidden; /* Crucial to keep elements within bounds */<br>        }<br><br>        .game-element {<br>            position: absolute;<br>            box-sizing: border-box; /* Include padding and border in the element&#039;s total width and height */<br>        }<br><br>        #pacman {<br>            background-color: yellow;<br>            border-radius: 50%;<br>            width: 20px;<br>            height: 20px;<br>            top: 50%;<br>            left: 50%;<br>            transform: translate(-50%, -50%); /* Center it initially */<br>            transition: top 0.1s linear, left 0.1s linear; /* Smooth movement */<br>            z-index: 10; /* Ensure Pac-Man is on top */<br>        }<br><br>        .wall {<br>            background-color: blue;<br>            border: 2px solid #000; /* Small border to distinguish */<br>        }<br><br>        .pellet {<br>            background-color: white;<br>            border-radius: 50%;<br>            width: 8px;<br>            height: 8px;<br>        }<br><br>        .ghost {<br>            background-color: red; /* Default ghost color */<br>            border-radius: 5px; /* Slightly rounded corners */<br>            width: 20px;<br>            height: 20px;<br>            z-index: 5;<br>        }<br><br>        /* Specific ghost colors */<br>        .ghost.blinky { background-color: red; }<br>        .ghost.pinky { background-color: pink; }<br>        .ghost.inky { background-color: cyan; }<br>        .ghost.clyde { background-color: orange; }<br><br>        #game-info {<br>            margin-top: 20px;<br>            font-size: 1.2em;<br>            text-align: center;<br>        }<br><br>        #score {<br>            font-weight: bold;<br>        }<br><br>        #lives {<br>            margin-left: 20px;<br>        }<br><br>        #message {<br>            margin-top: 10px;<br>            font-size: 1.5em;<br>            color: yellow;<br>            text-align: center;<br>            position: absolute;<br>            top: 50%;<br>            left: 50%;<br>            transform: translate(-50%, -50%);<br>            z-index: 20;<br>            display: none; /* Hidden by default */<br>        }<br>    &lt;/style&gt;<br>    &lt;!-- You&#039;d typically link to external fonts, but for a single file, we can embed if available via CDN --&gt;<br>    &lt;link href=&quot;https://fonts.googleapis.com/css2?family=Press+Start+2P&amp;display=swap&quot; rel=&quot;stylesheet&quot;&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>    &lt;h1&gt;PAC-MAN (Simplified)&lt;/h1&gt;<br>    &lt;div id=&quot;game-container&quot;&gt;<br>        &lt;div id=&quot;pacman&quot;&gt;&lt;/div&gt;<br>        &lt;/div&gt;<br>    &lt;div id=&quot;game-info&quot;&gt;<br>        Score: &lt;span id=&quot;score&quot;&gt;0&lt;/span&gt;<br>        Lives: &lt;span id=&quot;lives&quot;&gt;3&lt;/span&gt;<br>    &lt;/div&gt;<br>    &lt;div id=&quot;message&quot;&gt;&lt;/div&gt;<br><br>    &lt;script&gt;<br>        const gameContainer = document.getElementById(&#039;game-container&#039;);<br>        const pacman = document.getElementById(&#039;pacman&#039;);<br>        const scoreDisplay = document.getElementById(&#039;score&#039;);<br>        const livesDisplay = document.getElementById(&#039;lives&#039;);<br>        const messageDisplay = document.getElementById(&#039;message&#039;);<br><br>        // Game constants<br>        const TILE_SIZE = 25; // Size of each grid cell<br>        const GAME_WIDTH = 500;<br>        const GAME_HEIGHT = 500;<br>        const PACMAN_SPEED = 5; // Pixels per move<br>        const GHOST_SPEED = 3;<br><br>        // Game state<br>        let pacmanX = GAME_WIDTH / 2;<br>        let pacmanY = GAME_HEIGHT / 2;<br>        let score = 0;<br>        let lives = 3;<br>        let direction = { x: 0, y: 0 }; // Current movement direction<br>        let nextDirection = { x: 0, y: 0 }; // Desired next direction<br>        let gameInterval;<br>        let maze = [];<br>        let pellets = [];<br>        let ghosts = [];<br>        let isGameOver = false;<br>        let isGameWon = false;<br><br>        // Maze layout (0: empty, 1: wall, 2: pellet)<br>        // This is a very basic maze representation. For a true Pac-Man, this would be much more intricate.<br>        // The maze needs to be a multiple of TILE_SIZE for easy positioning.<br>        const mazeLayout = [<br>            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],<br>            [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1],<br>            [1, 2, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 2, 2, 1],<br>            [1, 2, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 2, 2, 1],<br>            [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1],<br>            [1, 2, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 2, 1],<br>            [1, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 1],<br>            [1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1],<br>            [1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1],<br>            [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1],<br>            [1, 2, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 2, 1],<br>            [1, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 1],<br>            [1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1],<br>            [1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1],<br>            [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1],<br>            [1, 2, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 2, 2, 1],<br>            [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1],<br>            [1, 2, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 2, 1],<br>            [1, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 1],<br>            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]<br>        ];<br><br>        // Ghost configurations: { id, startX, startY, color, aiType }<br>        // AI types are very simplified here.<br>        const ghostConfigs = [<br>            { id: &#039;blinky&#039;, startX: 10, startY: 9, color: &#039;red&#039;, aiType: &#039;chase&#039; },<br>            { id: &#039;pinky&#039;, startX: 9, startY: 9, color: &#039;pink&#039;, aiType: &#039;ambush&#039; },<br>            { id: &#039;inky&#039;, startX: 11, startY: 9, color: &#039;cyan&#039;, aiType: &#039;random&#039; },<br>            { id: &#039;clyde&#039;, startX: 12, startY: 9, color: &#039;orange&#039;, aiType: &#039;scatter&#039; }<br>        ];<br><br>        // Function to create DOM elements for maze, pellets, and ghosts<br>        function createGameElements() {<br>            gameContainer.innerHTML = &#039;&lt;div id=&quot;pacman&quot;&gt;&lt;/div&gt;&#039;; // Reset container, keep pacman<br><br>            const mazeGridWidth = mazeLayout[0].length;<br>            const mazeGridHeight = mazeLayout.length;<br><br>            for (let row = 0; row &lt; mazeGridHeight; row++) {<br>                for (let col = 0; col &lt; mazeGridWidth; col++) {<br>                    const cellType = mazeLayout[row][col];<br>                    const x = col * TILE_SIZE;<br>                    const y = row * TILE_SIZE;<br><br>                    if (cellType === 1) { // Wall<br>                        const wall = document.createElement(&#039;div&#039;);<br>                        wall.classList.add(&#039;game-element&#039;, &#039;wall&#039;);<br>                        wall.style.left = <code>${x}px</code>;<br>                        wall.style.top = <code>${y}px</code>;<br>                        wall.style.width = <code>${TILE_SIZE}px</code>;<br>                        wall.style.height = <code>${TILE_SIZE}px</code>;<br>                        gameContainer.appendChild(wall);<br>                    } else if (cellType === 2) { // Pellet<br>                        const pellet = document.createElement(&#039;div&#039;);<br>                        pellet.classList.add(&#039;game-element&#039;, &#039;pellet&#039;);<br>                        pellet.style.left = <code>${x + TILE_SIZE / 2 - 4}px</code>; // Centered pellet<br>                        pellet.style.top = <code>${y + TILE_SIZE / 2 - 4}px</code>;<br>                        pellet.dataset.row = row;<br>                        pellet.dataset.col = col;<br>                        gameContainer.appendChild(pellet);<br>                        pellets.push({ x: col, y: row, element: pellet });<br>                    }<br>                }<br>            }<br><br>            // Create ghosts<br>            ghostConfigs.forEach(config =&gt; {<br>                const ghost = document.createElement(&#039;div&#039;);<br>                ghost.classList.add(&#039;game-element&#039;, &#039;ghost&#039;, config.id);<br>                ghost.style.left = <code>${config.startX * TILE_SIZE}px</code>;<br>                ghost.style.top = <code>${config.startY * TILE_SIZE}px</code>;<br>                gameContainer.appendChild(ghost);<br>                ghosts.push({<br>                    ...config,<br>                    element: ghost,<br>                    currentX: config.startX * TILE_SIZE,<br>                    currentY: config.startY * TILE_SIZE,<br>                    direction: { x: 0, y: 0 }, // Initial direction<br>                    speed: GHOST_SPEED<br>                });<br>            });<br><br>            // Center Pac-Man in the maze grid<br>            const numCols = mazeLayout[0].length;<br>            const numRows = mazeLayout.length;<br>            let pacmanGridCol = Math.floor(numCols / 2);<br>            let pacmanGridRow = Math.floor(numRows / 2);<br><br>            // Find a valid starting position for Pac-Man<br>            while (mazeLayout[pacmanGridRow][pacmanGridCol] === 1) {<br>                pacmanGridCol++;<br>                if (pacmanGridCol &gt;= numCols) {<br>                    pacmanGridCol = 0;<br>                    pacmanGridRow++;<br>                    if (pacmanGridRow &gt;= numRows) {<br>                        pacmanGridRow = 0; // Wrap around if needed<br>                    }<br>                }<br>            }<br><br>            pacmanX = pacmanGridCol * TILE_SIZE + TILE_SIZE / 2;<br>            pacmanY = pacmanGridRow * TILE_SIZE + TILE_SIZE / 2;<br>            pacman.style.left = <code>${pacmanX}px</code>;<br>            pacman.style.top = <code>${pacmanY}px</code>;<br>        }<br><br>        // Function to check for collisions with walls<br>        function isWallCollision(x, y) {<br>            const gridCol = Math.floor(x / TILE_SIZE);<br>            const gridRow = Math.floor(y / TILE_SIZE);<br><br>            // Check boundaries<br>            if (gridCol &lt; 0 || gridCol &gt;= mazeLayout[0].length || gridRow &lt; 0 || gridRow &gt;= mazeLayout.length) {<br>                return true; // Treat out of bounds as a wall<br>            }<br><br>            return mazeLayout[gridRow][gridCol] === 1;<br>        }<br><br>        // Function to check for collisions with pellets<br>        function checkPelletCollision() {<br>            const pacmanGridCol = Math.floor(pacmanX / TILE_SIZE);<br>            const pacmanGridRow = Math.floor(pacmanY / TILE_SIZE);<br><br>            for (let i = pellets.length - 1; i &gt;= 0; i--) {<br>                const pellet = pellets[i];<br>                if (pellet.x === pacmanGridCol &amp;&amp; pellet.y === pacmanGridRow) {<br>                    score += 10;<br>                    scoreDisplay.textContent = score;<br>                    pellet.element.remove();<br>                    pellets.splice(i, 1);<br>                    if (pellets.length === 0) {<br>                        winGame();<br>                    }<br>                    return;<br>                }<br>            }<br>        }<br><br>        // Function to check for collisions with ghosts<br>        function checkGhostCollision() {<br>            const pacmanRect = pacman.getBoundingClientRect();<br><br>            for (const ghost of ghosts) {<br>                const ghostRect = ghost.element.getBoundingClientRect();<br><br>                // Basic AABB collision detection<br>                if (pacmanRect.left &lt; ghostRect.right &amp;&amp;<br>                    pacmanRect.right &gt; ghostRect.left &amp;&amp;<br>                    pacmanRect.top &lt; ghostRect.bottom &amp;&amp;<br>                    pacmanRect.bottom &gt; ghostRect.top) {<br>                    loseLife();<br>                    return;<br>                }<br>            }<br>        }<br><br>        // Function to handle losing a life<br>        function loseLife() {<br>            lives--;<br>            livesDisplay.textContent = lives;<br><br>            if (lives &lt;= 0) {<br>                gameOver();<br>                return;<br>            }<br><br>            // Reset Pac-Man position and clear directions<br>            const numCols = mazeLayout[0].length;<br>            const numRows = mazeLayout.length;<br>            let pacmanGridCol = Math.floor(numCols / 2);<br>            let pacmanGridRow = Math.floor(numRows / 2);<br><br>            while (mazeLayout[pacmanGridRow][pacmanGridCol] === 1) {<br>                pacmanGridCol++;<br>                if (pacmanGridCol &gt;= numCols) {<br>                    pacmanGridCol = 0;<br>                    pacmanGridRow++;<br>                    if (pacmanGridRow &gt;= numRows) {<br>                        pacmanGridRow = 0;<br>                    }<br>                }<br>            }<br><br>            pacmanX = pacmanGridCol * TILE_SIZE + TILE_SIZE / 2;<br>            pacmanY = pacmanGridRow * TILE_SIZE + TILE_SIZE / 2;<br>            pacman.style.left = <code>${pacmanX}px</code>;<br>            pacman.style.top = <code>${pacmanY}px</code>;<br>            direction = { x: 0, y: 0 };<br>            nextDirection = { x: 0, y: 0 };<br><br>            // Reset ghosts to their starting positions<br>            ghosts.forEach(ghost =&gt; {<br>                ghost.currentX = ghost.startX * TILE_SIZE + TILE_SIZE / 2;<br>                ghost.currentY = ghost.startY * TILE_SIZE + TILE_SIZE / 2;<br>                ghost.element.style.left = <code>${ghost.currentX}px</code>;<br>                ghost.element.style.top = <code>${ghost.currentY}px</code>;<br>                ghost.direction = { x: 0, y: 0 };<br>            });<br><br>            // Briefly pause game for reset<br>            setTimeout(() =&gt; {<br>                // Game continues<br>            }, 1000);<br>        }<br><br>        // Function to handle game over<br>        function gameOver() {<br>            isGameOver = true;<br>            clearInterval(gameInterval);<br>            messageDisplay.textContent = &quot;GAME OVER!&quot;;<br>            messageDisplay.style.display = &#039;block&#039;;<br>            document.removeEventListener(&#039;keydown&#039;, handleKeyPress);<br>        }<br><br>        // Function to handle game win<br>        function winGame() {<br>            isGameWon = true;<br>            clearInterval(gameInterval);<br>            messageDisplay.textContent = &quot;YOU WIN!&quot;;<br>            messageDisplay.style.display = &#039;block&#039;;<br>            document.removeEventListener(&#039;keydown&#039;, handleKeyPress);<br>        }<br><br>        // Function to move Pac-Man<br>        function movePacman() {<br>            // Try to change direction if a new direction is queued and possible<br>            if (nextDirection.x !== 0 || nextDirection.y !== 0) {<br>                const potentialX = pacmanX + nextDirection.x * PACMAN_SPEED;<br>                const potentialY = pacmanY + nextDirection.y * PACMAN_SPEED;<br><br>                if (!isWallCollision(potentialX, potentialY)) {<br>                    direction = { ...nextDirection };<br>                    nextDirection = { x: 0, y: 0 }; // Reset next direction as it&#039;s now active<br>                }<br>            }<br><br>            // Move in the current direction if possible<br>            const newPacmanX = pacmanX + direction.x * PACMAN_SPEED;<br>            const newPacmanY = pacmanY + direction.y * PACMAN_SPEED;<br><br>            if (!isWallCollision(newPacmanX, newPacmanY)) {<br>                pacmanX = newPacmanX;<br>                pacmanY = newPacmanY;<br>                pacman.style.left = <code>${pacmanX}px</code>;<br>                pacman.style.top = <code>${pacmanY}px</code>;<br>            } else {<br>                // If we hit a wall in the current direction, stop<br>                direction = { x: 0, y: 0 };<br>            }<br>        }<br><br>        // Simplified AI for ghosts<br>        function moveGhost(ghost) {<br>            const gridCol = Math.floor(ghost.currentX / TILE_SIZE);<br>            const gridRow = Math.floor(ghost.currentY / TILE_SIZE);<br><br>            // Simple AI: try to move towards the player or scatter<br>            let possibleMoves = [];<br>            const directions = [<br>                { dx: 0, dy: -1 }, // Up<br>                { dx: 0, dy: 1 },  // Down<br>                { dx: -1, dy: 0 }, // Left<br>                { dx: 1, dy: 0 }   // Right<br>            ];<br><br>            // Filter out moves that go into walls<br>            for (const dir of directions) {<br>                const nextGridCol = gridCol + dir.dx;<br>                const nextGridRow = gridRow + dir.dy;<br><br>                if (!isWallCollision(nextGridCol * TILE_SIZE + TILE_SIZE / 2, nextGridRow * TILE_SIZE + TILE_SIZE / 2)) {<br>                    possibleMoves.push({ ...dir });<br>                }<br>            }<br><br>            // Remove the opposite direction if it&#039;s not the only option (to prevent ghosts from just going back and forth)<br>            if (possibleMoves.length &gt; 1) {<br>                const oppositeDir = { x: -ghost.direction.x, y: -ghost.direction.y };<br>                const oppositeIndex = possibleMoves.findIndex(move =&gt; move.dx === oppositeDir.x &amp;&amp; move.dy === oppositeDir.y);<br>                if (oppositeIndex !== -1) {<br>                    possibleMoves.splice(oppositeIndex, 1);<br>                }<br>            }<br><br>            // Choose a direction based on AI type<br>            let chosenDirection = { x: 0, y: 0 };<br><br>            if (ghost.aiType === &#039;chase&#039;) {<br>                // Simple chase: move towards Pac-Man&#039;s current grid position<br>                const dx = pacmanX - ghost.currentX;<br>                const dy = pacmanY - ghost.currentY;<br><br>                if (Math.abs(dx) &gt; Math.abs(dy)) {<br>                    chosenDirection.x = dx &gt; 0 ? 1 : -1;<br>                } else {<br>                    chosenDirection.y = dy &gt; 0 ? 1 : -1;<br>                }<br>            } else if (ghost.aiType === &#039;random&#039;) {<br>                // Random movement<br>                if (possibleMoves.length &gt; 0) {<br>                    chosenDirection = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];<br>                }<br>            } else if (ghost.aiType === &#039;scatter&#039;) {<br>                // Scatter: move towards a corner (simplified)<br>                // For simplicity, let&#039;s just pick a random valid move. A true scatter would be towards a specific corner.<br>                if (possibleMoves.length &gt; 0) {<br>                    chosenDirection = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];<br>                }<br>            } else if (ghost.aiType === &#039;ambush&#039;) {<br>                // Ambush (Pinky&#039;s AI): try to move to a position ahead of Pac-Man<br>                // This is a very simplified version. True Pinky AI targets 4 tiles ahead of Pac-Man.<br>                const targetX = pacmanX + ghost.direction.x * 4 * TILE_SIZE; // Approximation<br>                const targetY = pacmanY + ghost.direction.y * 4 * TILE_SIZE;<br><br>                const dx = targetX - ghost.currentX;<br>                const dy = targetY - ghost.currentY;<br><br>                if (Math.abs(dx) &gt; Math.abs(dy)) {<br>                    chosenDirection.x = dx &gt; 0 ? 1 : -1;<br>                } else {<br>                    chosenDirection.y = dy &gt; 0 ? 1 : -1;<br>                }<br>            }<br><br>            // If the chosen direction is valid, update ghost&#039;s direction<br>            const isValidChosenDirection = possibleMoves.some(move =&gt; move.dx === chosenDirection.x &amp;&amp; move.dy === chosenDirection.y);<br>            if (isValidChosenDirection &amp;&amp; (chosenDirection.x !== 0 || chosenDirection.y !== 0)) {<br>                ghost.direction = chosenDirection;<br>            } else if (possibleMoves.length &gt; 0) {<br>                // If chosen direction is not valid, pick a random valid move<br>                ghost.direction = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];<br>            } else {<br>                // If no moves are possible (stuck), reverse direction<br>                ghost.direction = { x: -ghost.direction.x, y: -ghost.direction.y };<br>            }<br><br><br>            // Move the ghost<br>            ghost.currentX += ghost.direction.x * ghost.speed;<br>            ghost.currentY += ghost.direction.y * ghost.speed;<br><br>            // Snap to grid when close to the center of a tile to avoid drift<br>            const gridCol = Math.round(ghost.currentX / TILE_SIZE);<br>            const gridRow = Math.round(ghost.currentY / TILE_SIZE);<br>            ghost.currentX = gridCol * TILE_SIZE + TILE_SIZE / 2;<br>            ghost.currentY = gridRow * TILE_SIZE + TILE_SIZE / 2;<br><br><br>            ghost.element.style.left = <code>${ghost.currentX - TILE_SIZE / 2}px</code>; // Adjust for element&#039;s origin<br>            ghost.element.style.top = <code>${ghost.currentY - TILE_SIZE / 2}px</code>;<br>        }<br><br><br>        // Handle keyboard input<br>        function handleKeyPress(event) {<br>            switch (event.key) {<br>                case &#039;ArrowUp&#039;:<br>                    nextDirection = { x: 0, y: -1 };<br>                    break;<br>                case &#039;ArrowDown&#039;:<br>                    nextDirection = { x: 0, y: 1 };<br>                    break;<br>                case &#039;ArrowLeft&#039;:<br>                    nextDirection = { x: -1, y: 0 };<br>                    break;<br>                case &#039;ArrowRight&#039;:<br>                    nextDirection = { x: 1, y: 0 };<br>                    break;<br>            }<br>        }<br><br>        // Game loop<br>        function gameLoop() {<br>            if (isGameOver || isGameWon) return;<br><br>            movePacman();<br>            checkPelletCollision();<br>            checkGhostCollision();<br><br>            // Move ghosts<br>            ghosts.forEach(moveGhost);<br>        }<br><br>        // Initialize game<br>        function initGame() {<br>            createGameElements();<br>            document.addEventListener(&#039;keydown&#039;, handleKeyPress);<br>            gameInterval = setInterval(gameLoop, 1000 / 60); // 60 FPS<br>        }<br><br>        // Start the game when the page loads<br>        initGame();<br>    &lt;/script&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;</code></pre><br><br>### How to Use This Code:<br><br>1.  **Save:** Save the entire code block above into a file named <code>index.html</code>.<br>2.  **Open:** Open the <code>index.html</code> file in your web browser.<br><br>### Explanation of the Code:<br><br>1.  **HTML Structure:**<br>    *   <code>&lt;!DOCTYPE html&gt;</code> and basic <code>html</code>, <code>head</code>, <code>body</code> tags.<br>    *   <code>&lt;title&gt;</code> for the browser tab.<br>    *   <code>&lt;style&gt;</code> block contains all the CSS for styling the game elements.<br>    *   <code>&lt;link&gt;</code> for a pixelated font (<code>Press Start 2P</code>) for a retro feel.<br>    *   A main <code>div</code> with <code>id=&quot;game-container&quot;</code> acts as the game&#039;s canvas.<br>    *   <code>div id=&quot;pacman&quot;</code> is the player character.<br>    *   <code>div id=&quot;game-info&quot;</code> displays the score and lives.<br>    *   <code>div id=&quot;message&quot;</code> is used for &quot;GAME OVER&quot; or &quot;YOU WIN&quot; messages.<br>    *   <code>&lt;script&gt;</code> block contains all the JavaScript logic.<br><br>2.  **CSS Styling:**<br>    *   Basic styling for the <code>body</code> to center the game.<br>    *   <code>#game-container</code> is the core game area, with <code>position: relative</code> so its children can be positioned absolutely within it. <code>overflow: hidden</code> is crucial.<br>    *   <code>.game-element</code> is a base class for all game objects.<br>    *   <code>#pacman</code> is styled as a yellow circle. <code>transition</code> is used for smoother movement.<br>    *   <code>.wall</code> is a blue square.<br>    *   <code>.pellet</code> is a small white circle.<br>    *   <code>.ghost</code> is styled as a colored square. Specific classes like <code>.blinky</code> allow for individual ghost colors.<br><br>3.  **JavaScript Logic:**<br>    *   **DOM Element References:** Gets references to the main game elements.<br>    *   **Game Constants:** Defines <code>TILE_SIZE</code>, <code>GAME_WIDTH</code>, <code>GAME_HEIGHT</code>, <code>PACMAN_SPEED</code>, <code>GHOST_SPEED</code>.<br>    *   **Game State Variables:** <code>pacmanX</code>, <code>pacmanY</code>, <code>score</code>, <code>lives</code>, <code>direction</code>, <code>nextDirection</code>, <code>gameInterval</code>, <code>maze</code>, <code>pellets</code>, <code>ghosts</code>, <code>isGameOver</code>, <code>isGameWon</code>.<br>    *   **<code>mazeLayout</code>:** A 2D array representing the maze. <code>1</code> for walls, <code>2</code> for pellets, <code>0</code> for empty space. **Important:** The dimensions of this array, when multiplied by <code>TILE_SIZE</code>, should ideally match <code>GAME_WIDTH</code> and <code>GAME_HEIGHT</code>.<br>    *   **<code>ghostConfigs</code>:** An array defining the initial properties of each ghost.<br>    *   **<code>createGameElements()</code>:**<br>        *   Iterates through <code>mazeLayout</code>.<br>        *   Creates <code>div</code> elements for walls and pellets and appends them to the <code>game-container</code>.<br>        *   Creates <code>div</code> elements for ghosts and adds them to the <code>ghosts</code> array.<br>        *   Calculates and sets the initial position of Pac-Man, trying to find an empty starting cell.<br>    *   **<code>isWallCollision(x, y)</code>:** Checks if a given coordinate <code>(x, y)</code> falls within a wall tile.<br>    *   **<code>checkPelletCollision()</code>:** Detects if Pac-Man is on the same tile as a pellet, updates the score, removes the pellet, and checks for win condition.<br>    *   **<code>checkGhostCollision()</code>:** Performs a simple bounding box collision check between Pac-Man and each ghost. If a collision occurs, <code>loseLife()</code> is called.<br>    *   **<code>loseLife()</code>:** Decrements lives, updates the display, resets Pac-Man and ghost positions, and checks for game over.<br>    *   **<code>gameOver()</code>:** Stops the game loop, displays &quot;GAME OVER&quot;, and removes the key listener.<br>    *   **<code>winGame()</code>:** Stops the game loop, displays &quot;YOU WIN&quot;, and removes the key listener.<br>    *   **<code>movePacman()</code>:**<br>        *   Handles changing Pac-Man&#039;s <code>direction</code> based on <code>nextDirection</code> if the move is not into a wall.<br>        *   Updates Pac-Man&#039;s position based on the current <code>direction</code>.<br>        *   Stops Pac-Man if it hits a wall.<br>    *   **<code>moveGhost(ghost)</code>:**<br>        *   Implements a **very simplified** ghost AI.<br>        *   Identifies possible moves (not into walls).<br>        *   Chooses a direction based on <code>aiType</code> (chase, random, scatter, ambush).<br>        *   Updates the ghost&#039;s position and snaps it to the grid center.<br>    *   **<code>handleKeyPress(event)</code>:** Listens for arrow key presses and sets <code>nextDirection</code> for Pac-Man.<br>    *   **<code>gameLoop()</code>:** The heart of the game. Called repeatedly by <code>setInterval</code>. It calls <code>movePacman</code>, <code>checkPelletCollision</code>, <code>checkGhostCollision</code>, and <code>moveGhost</code> for each ghost.<br>    *   **<code>initGame()</code>:** Sets up the initial game state, creates elements, adds the event listener, and starts the <code>gameLoop</code>.<br>    *   **<code>initGame()</code> is called at the end to start the game.**<br><br>### Limitations and Further Improvements:<br><br>*   **Exact Copy:** This is far from an exact copy. Key missing features for an exact replica include:<br>    *   **Graphics:** Original PAC-MAN used tile-based graphics with sprites for Pac-Man&#039;s mouth animation, ghost animations, etc.<br>    *   **Sound Effects:** Crucial for the PAC-MAN experience (eating pellets, dying,</div>
        </div>
    </div>
</body>
</html>