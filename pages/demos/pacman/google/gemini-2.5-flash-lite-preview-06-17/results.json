{
  "timestamp": "2025-10-06T11:41:24.061Z",
  "execution": {
    "duration_seconds": "6.284",
    "model_used": "google/gemini-2.5-flash-lite-preview-06-17",
    "model_requested": "google/gemini-2.5-flash-lite-preview-06-17"
  },
  "tokens": {
    "prompt_tokens": 28,
    "completion_tokens": 7880,
    "total_tokens": 7908
  },
  "cost": {
    "currency": "USD",
    "prompt_cost": 0.000003,
    "completion_cost": 0.003152,
    "total_cost": 0.003155
  },
  "model_card": {
    "id": "google/gemini-2.5-flash-lite-preview-06-17",
    "name": "Google: Gemini 2.5 Flash Lite Preview 06-17",
    "description": "Gemini 2.5 Flash-Lite is a lightweight reasoning model in the Gemini 2.5 family, optimized for ultra-low latency and cost efficiency. It offers improved throughput, faster token generation, and better performance across common benchmarks compared to earlier Flash models. By default, \"thinking\" (i.e. multi-pass reasoning) is disabled to prioritize speed, but developers can enable it via the [Reasoning API parameter](https://openrouter.ai/docs/use-cases/reasoning-tokens) to selectively trade off cost for intelligence. ",
    "context_length": 1048576,
    "architecture": {
      "modality": "text+image->text",
      "input_modalities": [
        "file",
        "image",
        "text",
        "audio"
      ],
      "output_modalities": [
        "text"
      ],
      "tokenizer": "Gemini",
      "instruct_type": null
    },
    "pricing": {
      "prompt": "0.0000001",
      "completion": "0.0000004",
      "request": "0",
      "image": "0",
      "web_search": "0",
      "internal_reasoning": "0",
      "input_cache_read": "0.000000025",
      "input_cache_write": "0.0000001833"
    },
    "top_provider": {
      "context_length": 1048576,
      "max_completion_tokens": 65535,
      "is_moderated": false
    }
  },
  "request": {
    "prompt": "In a single HTML file named index.html, create exact copy of the PAC-MAN game in one html file using css and js.\n",
    "system_prompt": null,
    "temperature": 0.7,
    "max_tokens": 8000
  },
  "response_metadata": {
    "id": "gen-1759750865-I6J6D7WEhQMNrb84gbMQ",
    "created": 1759750865,
    "object": "chat.completion"
  },
  "raw_response": "Creating an **exact copy** of the original PAC-MAN game in a single HTML file with CSS and JavaScript is a **highly complex undertaking** and would result in a very, very long and intricate file. The original arcade game involved many sprites, animations, sound effects, AI for the ghosts, collision detection, scoring, levels, and a game loop.\n\nHowever, I can provide you with a **simplified, functional version** of PAC-MAN within a single `index.html` file. This version will demonstrate the core mechanics:\n\n*   **Player Movement:** PAC-MAN moving around the maze.\n*   **Pellets:** Collectible dots.\n*   **Walls:** Impassable maze boundaries.\n*   **Basic Ghost Movement (simplified):** Ghosts will move around.\n*   **Game Over Condition:** PAC-MAN losing a life.\n*   **Scoring:** Basic score tracking.\n\n**This will NOT be an exact arcade replica** due to the sheer amount of detail involved. For a true arcade experience, you'd typically see more sophisticated graphics, sound design, and complex AI.\n\nHere's the `index.html` file. I've tried to keep it as self-contained and readable as possible.\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>PAC-MAN (Simplified)</title>\n    <style>\n        body {\n            display: flex;\n            justify-content: center;\n            align-items: center;\n            min-height: 100vh;\n            background-color: #000;\n            margin: 0;\n            font-family: 'Press Start 2P', cursive; /* A pixelated font for the feel */\n            color: white;\n            flex-direction: column;\n        }\n\n        #game-container {\n            position: relative;\n            width: 500px; /* Adjust as needed */\n            height: 500px; /* Adjust as needed */\n            border: 2px solid #fff;\n            background-color: #000;\n            overflow: hidden; /* Crucial to keep elements within bounds */\n        }\n\n        .game-element {\n            position: absolute;\n            box-sizing: border-box; /* Include padding and border in the element's total width and height */\n        }\n\n        #pacman {\n            background-color: yellow;\n            border-radius: 50%;\n            width: 20px;\n            height: 20px;\n            top: 50%;\n            left: 50%;\n            transform: translate(-50%, -50%); /* Center it initially */\n            transition: top 0.1s linear, left 0.1s linear; /* Smooth movement */\n            z-index: 10; /* Ensure Pac-Man is on top */\n        }\n\n        .wall {\n            background-color: blue;\n            border: 2px solid #000; /* Small border to distinguish */\n        }\n\n        .pellet {\n            background-color: white;\n            border-radius: 50%;\n            width: 8px;\n            height: 8px;\n        }\n\n        .ghost {\n            background-color: red; /* Default ghost color */\n            border-radius: 5px; /* Slightly rounded corners */\n            width: 20px;\n            height: 20px;\n            z-index: 5;\n        }\n\n        /* Specific ghost colors */\n        .ghost.blinky { background-color: red; }\n        .ghost.pinky { background-color: pink; }\n        .ghost.inky { background-color: cyan; }\n        .ghost.clyde { background-color: orange; }\n\n        #game-info {\n            margin-top: 20px;\n            font-size: 1.2em;\n            text-align: center;\n        }\n\n        #score {\n            font-weight: bold;\n        }\n\n        #lives {\n            margin-left: 20px;\n        }\n\n        #message {\n            margin-top: 10px;\n            font-size: 1.5em;\n            color: yellow;\n            text-align: center;\n            position: absolute;\n            top: 50%;\n            left: 50%;\n            transform: translate(-50%, -50%);\n            z-index: 20;\n            display: none; /* Hidden by default */\n        }\n    </style>\n    <!-- You'd typically link to external fonts, but for a single file, we can embed if available via CDN -->\n    <link href=\"https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap\" rel=\"stylesheet\">\n</head>\n<body>\n    <h1>PAC-MAN (Simplified)</h1>\n    <div id=\"game-container\">\n        <div id=\"pacman\"></div>\n        </div>\n    <div id=\"game-info\">\n        Score: <span id=\"score\">0</span>\n        Lives: <span id=\"lives\">3</span>\n    </div>\n    <div id=\"message\"></div>\n\n    <script>\n        const gameContainer = document.getElementById('game-container');\n        const pacman = document.getElementById('pacman');\n        const scoreDisplay = document.getElementById('score');\n        const livesDisplay = document.getElementById('lives');\n        const messageDisplay = document.getElementById('message');\n\n        // Game constants\n        const TILE_SIZE = 25; // Size of each grid cell\n        const GAME_WIDTH = 500;\n        const GAME_HEIGHT = 500;\n        const PACMAN_SPEED = 5; // Pixels per move\n        const GHOST_SPEED = 3;\n\n        // Game state\n        let pacmanX = GAME_WIDTH / 2;\n        let pacmanY = GAME_HEIGHT / 2;\n        let score = 0;\n        let lives = 3;\n        let direction = { x: 0, y: 0 }; // Current movement direction\n        let nextDirection = { x: 0, y: 0 }; // Desired next direction\n        let gameInterval;\n        let maze = [];\n        let pellets = [];\n        let ghosts = [];\n        let isGameOver = false;\n        let isGameWon = false;\n\n        // Maze layout (0: empty, 1: wall, 2: pellet)\n        // This is a very basic maze representation. For a true Pac-Man, this would be much more intricate.\n        // The maze needs to be a multiple of TILE_SIZE for easy positioning.\n        const mazeLayout = [\n            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n            [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1],\n            [1, 2, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 2, 2, 1],\n            [1, 2, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 2, 2, 1],\n            [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1],\n            [1, 2, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 2, 1],\n            [1, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 1],\n            [1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1],\n            [1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1],\n            [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1],\n            [1, 2, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 2, 1],\n            [1, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 1],\n            [1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1],\n            [1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1],\n            [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1],\n            [1, 2, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 2, 2, 1],\n            [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1],\n            [1, 2, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 2, 1],\n            [1, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 1],\n            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n        ];\n\n        // Ghost configurations: { id, startX, startY, color, aiType }\n        // AI types are very simplified here.\n        const ghostConfigs = [\n            { id: 'blinky', startX: 10, startY: 9, color: 'red', aiType: 'chase' },\n            { id: 'pinky', startX: 9, startY: 9, color: 'pink', aiType: 'ambush' },\n            { id: 'inky', startX: 11, startY: 9, color: 'cyan', aiType: 'random' },\n            { id: 'clyde', startX: 12, startY: 9, color: 'orange', aiType: 'scatter' }\n        ];\n\n        // Function to create DOM elements for maze, pellets, and ghosts\n        function createGameElements() {\n            gameContainer.innerHTML = '<div id=\"pacman\"></div>'; // Reset container, keep pacman\n\n            const mazeGridWidth = mazeLayout[0].length;\n            const mazeGridHeight = mazeLayout.length;\n\n            for (let row = 0; row < mazeGridHeight; row++) {\n                for (let col = 0; col < mazeGridWidth; col++) {\n                    const cellType = mazeLayout[row][col];\n                    const x = col * TILE_SIZE;\n                    const y = row * TILE_SIZE;\n\n                    if (cellType === 1) { // Wall\n                        const wall = document.createElement('div');\n                        wall.classList.add('game-element', 'wall');\n                        wall.style.left = `${x}px`;\n                        wall.style.top = `${y}px`;\n                        wall.style.width = `${TILE_SIZE}px`;\n                        wall.style.height = `${TILE_SIZE}px`;\n                        gameContainer.appendChild(wall);\n                    } else if (cellType === 2) { // Pellet\n                        const pellet = document.createElement('div');\n                        pellet.classList.add('game-element', 'pellet');\n                        pellet.style.left = `${x + TILE_SIZE / 2 - 4}px`; // Centered pellet\n                        pellet.style.top = `${y + TILE_SIZE / 2 - 4}px`;\n                        pellet.dataset.row = row;\n                        pellet.dataset.col = col;\n                        gameContainer.appendChild(pellet);\n                        pellets.push({ x: col, y: row, element: pellet });\n                    }\n                }\n            }\n\n            // Create ghosts\n            ghostConfigs.forEach(config => {\n                const ghost = document.createElement('div');\n                ghost.classList.add('game-element', 'ghost', config.id);\n                ghost.style.left = `${config.startX * TILE_SIZE}px`;\n                ghost.style.top = `${config.startY * TILE_SIZE}px`;\n                gameContainer.appendChild(ghost);\n                ghosts.push({\n                    ...config,\n                    element: ghost,\n                    currentX: config.startX * TILE_SIZE,\n                    currentY: config.startY * TILE_SIZE,\n                    direction: { x: 0, y: 0 }, // Initial direction\n                    speed: GHOST_SPEED\n                });\n            });\n\n            // Center Pac-Man in the maze grid\n            const numCols = mazeLayout[0].length;\n            const numRows = mazeLayout.length;\n            let pacmanGridCol = Math.floor(numCols / 2);\n            let pacmanGridRow = Math.floor(numRows / 2);\n\n            // Find a valid starting position for Pac-Man\n            while (mazeLayout[pacmanGridRow][pacmanGridCol] === 1) {\n                pacmanGridCol++;\n                if (pacmanGridCol >= numCols) {\n                    pacmanGridCol = 0;\n                    pacmanGridRow++;\n                    if (pacmanGridRow >= numRows) {\n                        pacmanGridRow = 0; // Wrap around if needed\n                    }\n                }\n            }\n\n            pacmanX = pacmanGridCol * TILE_SIZE + TILE_SIZE / 2;\n            pacmanY = pacmanGridRow * TILE_SIZE + TILE_SIZE / 2;\n            pacman.style.left = `${pacmanX}px`;\n            pacman.style.top = `${pacmanY}px`;\n        }\n\n        // Function to check for collisions with walls\n        function isWallCollision(x, y) {\n            const gridCol = Math.floor(x / TILE_SIZE);\n            const gridRow = Math.floor(y / TILE_SIZE);\n\n            // Check boundaries\n            if (gridCol < 0 || gridCol >= mazeLayout[0].length || gridRow < 0 || gridRow >= mazeLayout.length) {\n                return true; // Treat out of bounds as a wall\n            }\n\n            return mazeLayout[gridRow][gridCol] === 1;\n        }\n\n        // Function to check for collisions with pellets\n        function checkPelletCollision() {\n            const pacmanGridCol = Math.floor(pacmanX / TILE_SIZE);\n            const pacmanGridRow = Math.floor(pacmanY / TILE_SIZE);\n\n            for (let i = pellets.length - 1; i >= 0; i--) {\n                const pellet = pellets[i];\n                if (pellet.x === pacmanGridCol && pellet.y === pacmanGridRow) {\n                    score += 10;\n                    scoreDisplay.textContent = score;\n                    pellet.element.remove();\n                    pellets.splice(i, 1);\n                    if (pellets.length === 0) {\n                        winGame();\n                    }\n                    return;\n                }\n            }\n        }\n\n        // Function to check for collisions with ghosts\n        function checkGhostCollision() {\n            const pacmanRect = pacman.getBoundingClientRect();\n\n            for (const ghost of ghosts) {\n                const ghostRect = ghost.element.getBoundingClientRect();\n\n                // Basic AABB collision detection\n                if (pacmanRect.left < ghostRect.right &&\n                    pacmanRect.right > ghostRect.left &&\n                    pacmanRect.top < ghostRect.bottom &&\n                    pacmanRect.bottom > ghostRect.top) {\n                    loseLife();\n                    return;\n                }\n            }\n        }\n\n        // Function to handle losing a life\n        function loseLife() {\n            lives--;\n            livesDisplay.textContent = lives;\n\n            if (lives <= 0) {\n                gameOver();\n                return;\n            }\n\n            // Reset Pac-Man position and clear directions\n            const numCols = mazeLayout[0].length;\n            const numRows = mazeLayout.length;\n            let pacmanGridCol = Math.floor(numCols / 2);\n            let pacmanGridRow = Math.floor(numRows / 2);\n\n            while (mazeLayout[pacmanGridRow][pacmanGridCol] === 1) {\n                pacmanGridCol++;\n                if (pacmanGridCol >= numCols) {\n                    pacmanGridCol = 0;\n                    pacmanGridRow++;\n                    if (pacmanGridRow >= numRows) {\n                        pacmanGridRow = 0;\n                    }\n                }\n            }\n\n            pacmanX = pacmanGridCol * TILE_SIZE + TILE_SIZE / 2;\n            pacmanY = pacmanGridRow * TILE_SIZE + TILE_SIZE / 2;\n            pacman.style.left = `${pacmanX}px`;\n            pacman.style.top = `${pacmanY}px`;\n            direction = { x: 0, y: 0 };\n            nextDirection = { x: 0, y: 0 };\n\n            // Reset ghosts to their starting positions\n            ghosts.forEach(ghost => {\n                ghost.currentX = ghost.startX * TILE_SIZE + TILE_SIZE / 2;\n                ghost.currentY = ghost.startY * TILE_SIZE + TILE_SIZE / 2;\n                ghost.element.style.left = `${ghost.currentX}px`;\n                ghost.element.style.top = `${ghost.currentY}px`;\n                ghost.direction = { x: 0, y: 0 };\n            });\n\n            // Briefly pause game for reset\n            setTimeout(() => {\n                // Game continues\n            }, 1000);\n        }\n\n        // Function to handle game over\n        function gameOver() {\n            isGameOver = true;\n            clearInterval(gameInterval);\n            messageDisplay.textContent = \"GAME OVER!\";\n            messageDisplay.style.display = 'block';\n            document.removeEventListener('keydown', handleKeyPress);\n        }\n\n        // Function to handle game win\n        function winGame() {\n            isGameWon = true;\n            clearInterval(gameInterval);\n            messageDisplay.textContent = \"YOU WIN!\";\n            messageDisplay.style.display = 'block';\n            document.removeEventListener('keydown', handleKeyPress);\n        }\n\n        // Function to move Pac-Man\n        function movePacman() {\n            // Try to change direction if a new direction is queued and possible\n            if (nextDirection.x !== 0 || nextDirection.y !== 0) {\n                const potentialX = pacmanX + nextDirection.x * PACMAN_SPEED;\n                const potentialY = pacmanY + nextDirection.y * PACMAN_SPEED;\n\n                if (!isWallCollision(potentialX, potentialY)) {\n                    direction = { ...nextDirection };\n                    nextDirection = { x: 0, y: 0 }; // Reset next direction as it's now active\n                }\n            }\n\n            // Move in the current direction if possible\n            const newPacmanX = pacmanX + direction.x * PACMAN_SPEED;\n            const newPacmanY = pacmanY + direction.y * PACMAN_SPEED;\n\n            if (!isWallCollision(newPacmanX, newPacmanY)) {\n                pacmanX = newPacmanX;\n                pacmanY = newPacmanY;\n                pacman.style.left = `${pacmanX}px`;\n                pacman.style.top = `${pacmanY}px`;\n            } else {\n                // If we hit a wall in the current direction, stop\n                direction = { x: 0, y: 0 };\n            }\n        }\n\n        // Simplified AI for ghosts\n        function moveGhost(ghost) {\n            const gridCol = Math.floor(ghost.currentX / TILE_SIZE);\n            const gridRow = Math.floor(ghost.currentY / TILE_SIZE);\n\n            // Simple AI: try to move towards the player or scatter\n            let possibleMoves = [];\n            const directions = [\n                { dx: 0, dy: -1 }, // Up\n                { dx: 0, dy: 1 },  // Down\n                { dx: -1, dy: 0 }, // Left\n                { dx: 1, dy: 0 }   // Right\n            ];\n\n            // Filter out moves that go into walls\n            for (const dir of directions) {\n                const nextGridCol = gridCol + dir.dx;\n                const nextGridRow = gridRow + dir.dy;\n\n                if (!isWallCollision(nextGridCol * TILE_SIZE + TILE_SIZE / 2, nextGridRow * TILE_SIZE + TILE_SIZE / 2)) {\n                    possibleMoves.push({ ...dir });\n                }\n            }\n\n            // Remove the opposite direction if it's not the only option (to prevent ghosts from just going back and forth)\n            if (possibleMoves.length > 1) {\n                const oppositeDir = { x: -ghost.direction.x, y: -ghost.direction.y };\n                const oppositeIndex = possibleMoves.findIndex(move => move.dx === oppositeDir.x && move.dy === oppositeDir.y);\n                if (oppositeIndex !== -1) {\n                    possibleMoves.splice(oppositeIndex, 1);\n                }\n            }\n\n            // Choose a direction based on AI type\n            let chosenDirection = { x: 0, y: 0 };\n\n            if (ghost.aiType === 'chase') {\n                // Simple chase: move towards Pac-Man's current grid position\n                const dx = pacmanX - ghost.currentX;\n                const dy = pacmanY - ghost.currentY;\n\n                if (Math.abs(dx) > Math.abs(dy)) {\n                    chosenDirection.x = dx > 0 ? 1 : -1;\n                } else {\n                    chosenDirection.y = dy > 0 ? 1 : -1;\n                }\n            } else if (ghost.aiType === 'random') {\n                // Random movement\n                if (possibleMoves.length > 0) {\n                    chosenDirection = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];\n                }\n            } else if (ghost.aiType === 'scatter') {\n                // Scatter: move towards a corner (simplified)\n                // For simplicity, let's just pick a random valid move. A true scatter would be towards a specific corner.\n                if (possibleMoves.length > 0) {\n                    chosenDirection = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];\n                }\n            } else if (ghost.aiType === 'ambush') {\n                // Ambush (Pinky's AI): try to move to a position ahead of Pac-Man\n                // This is a very simplified version. True Pinky AI targets 4 tiles ahead of Pac-Man.\n                const targetX = pacmanX + ghost.direction.x * 4 * TILE_SIZE; // Approximation\n                const targetY = pacmanY + ghost.direction.y * 4 * TILE_SIZE;\n\n                const dx = targetX - ghost.currentX;\n                const dy = targetY - ghost.currentY;\n\n                if (Math.abs(dx) > Math.abs(dy)) {\n                    chosenDirection.x = dx > 0 ? 1 : -1;\n                } else {\n                    chosenDirection.y = dy > 0 ? 1 : -1;\n                }\n            }\n\n            // If the chosen direction is valid, update ghost's direction\n            const isValidChosenDirection = possibleMoves.some(move => move.dx === chosenDirection.x && move.dy === chosenDirection.y);\n            if (isValidChosenDirection && (chosenDirection.x !== 0 || chosenDirection.y !== 0)) {\n                ghost.direction = chosenDirection;\n            } else if (possibleMoves.length > 0) {\n                // If chosen direction is not valid, pick a random valid move\n                ghost.direction = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];\n            } else {\n                // If no moves are possible (stuck), reverse direction\n                ghost.direction = { x: -ghost.direction.x, y: -ghost.direction.y };\n            }\n\n\n            // Move the ghost\n            ghost.currentX += ghost.direction.x * ghost.speed;\n            ghost.currentY += ghost.direction.y * ghost.speed;\n\n            // Snap to grid when close to the center of a tile to avoid drift\n            const gridCol = Math.round(ghost.currentX / TILE_SIZE);\n            const gridRow = Math.round(ghost.currentY / TILE_SIZE);\n            ghost.currentX = gridCol * TILE_SIZE + TILE_SIZE / 2;\n            ghost.currentY = gridRow * TILE_SIZE + TILE_SIZE / 2;\n\n\n            ghost.element.style.left = `${ghost.currentX - TILE_SIZE / 2}px`; // Adjust for element's origin\n            ghost.element.style.top = `${ghost.currentY - TILE_SIZE / 2}px`;\n        }\n\n\n        // Handle keyboard input\n        function handleKeyPress(event) {\n            switch (event.key) {\n                case 'ArrowUp':\n                    nextDirection = { x: 0, y: -1 };\n                    break;\n                case 'ArrowDown':\n                    nextDirection = { x: 0, y: 1 };\n                    break;\n                case 'ArrowLeft':\n                    nextDirection = { x: -1, y: 0 };\n                    break;\n                case 'ArrowRight':\n                    nextDirection = { x: 1, y: 0 };\n                    break;\n            }\n        }\n\n        // Game loop\n        function gameLoop() {\n            if (isGameOver || isGameWon) return;\n\n            movePacman();\n            checkPelletCollision();\n            checkGhostCollision();\n\n            // Move ghosts\n            ghosts.forEach(moveGhost);\n        }\n\n        // Initialize game\n        function initGame() {\n            createGameElements();\n            document.addEventListener('keydown', handleKeyPress);\n            gameInterval = setInterval(gameLoop, 1000 / 60); // 60 FPS\n        }\n\n        // Start the game when the page loads\n        initGame();\n    </script>\n</body>\n</html>\n```\n\n### How to Use This Code:\n\n1.  **Save:** Save the entire code block above into a file named `index.html`.\n2.  **Open:** Open the `index.html` file in your web browser.\n\n### Explanation of the Code:\n\n1.  **HTML Structure:**\n    *   `<!DOCTYPE html>` and basic `html`, `head`, `body` tags.\n    *   `<title>` for the browser tab.\n    *   `<style>` block contains all the CSS for styling the game elements.\n    *   `<link>` for a pixelated font (`Press Start 2P`) for a retro feel.\n    *   A main `div` with `id=\"game-container\"` acts as the game's canvas.\n    *   `div id=\"pacman\"` is the player character.\n    *   `div id=\"game-info\"` displays the score and lives.\n    *   `div id=\"message\"` is used for \"GAME OVER\" or \"YOU WIN\" messages.\n    *   `<script>` block contains all the JavaScript logic.\n\n2.  **CSS Styling:**\n    *   Basic styling for the `body` to center the game.\n    *   `#game-container` is the core game area, with `position: relative` so its children can be positioned absolutely within it. `overflow: hidden` is crucial.\n    *   `.game-element` is a base class for all game objects.\n    *   `#pacman` is styled as a yellow circle. `transition` is used for smoother movement.\n    *   `.wall` is a blue square.\n    *   `.pellet` is a small white circle.\n    *   `.ghost` is styled as a colored square. Specific classes like `.blinky` allow for individual ghost colors.\n\n3.  **JavaScript Logic:**\n    *   **DOM Element References:** Gets references to the main game elements.\n    *   **Game Constants:** Defines `TILE_SIZE`, `GAME_WIDTH`, `GAME_HEIGHT`, `PACMAN_SPEED`, `GHOST_SPEED`.\n    *   **Game State Variables:** `pacmanX`, `pacmanY`, `score`, `lives`, `direction`, `nextDirection`, `gameInterval`, `maze`, `pellets`, `ghosts`, `isGameOver`, `isGameWon`.\n    *   **`mazeLayout`:** A 2D array representing the maze. `1` for walls, `2` for pellets, `0` for empty space. **Important:** The dimensions of this array, when multiplied by `TILE_SIZE`, should ideally match `GAME_WIDTH` and `GAME_HEIGHT`.\n    *   **`ghostConfigs`:** An array defining the initial properties of each ghost.\n    *   **`createGameElements()`:**\n        *   Iterates through `mazeLayout`.\n        *   Creates `div` elements for walls and pellets and appends them to the `game-container`.\n        *   Creates `div` elements for ghosts and adds them to the `ghosts` array.\n        *   Calculates and sets the initial position of Pac-Man, trying to find an empty starting cell.\n    *   **`isWallCollision(x, y)`:** Checks if a given coordinate `(x, y)` falls within a wall tile.\n    *   **`checkPelletCollision()`:** Detects if Pac-Man is on the same tile as a pellet, updates the score, removes the pellet, and checks for win condition.\n    *   **`checkGhostCollision()`:** Performs a simple bounding box collision check between Pac-Man and each ghost. If a collision occurs, `loseLife()` is called.\n    *   **`loseLife()`:** Decrements lives, updates the display, resets Pac-Man and ghost positions, and checks for game over.\n    *   **`gameOver()`:** Stops the game loop, displays \"GAME OVER\", and removes the key listener.\n    *   **`winGame()`:** Stops the game loop, displays \"YOU WIN\", and removes the key listener.\n    *   **`movePacman()`:**\n        *   Handles changing Pac-Man's `direction` based on `nextDirection` if the move is not into a wall.\n        *   Updates Pac-Man's position based on the current `direction`.\n        *   Stops Pac-Man if it hits a wall.\n    *   **`moveGhost(ghost)`:**\n        *   Implements a **very simplified** ghost AI.\n        *   Identifies possible moves (not into walls).\n        *   Chooses a direction based on `aiType` (chase, random, scatter, ambush).\n        *   Updates the ghost's position and snaps it to the grid center.\n    *   **`handleKeyPress(event)`:** Listens for arrow key presses and sets `nextDirection` for Pac-Man.\n    *   **`gameLoop()`:** The heart of the game. Called repeatedly by `setInterval`. It calls `movePacman`, `checkPelletCollision`, `checkGhostCollision`, and `moveGhost` for each ghost.\n    *   **`initGame()`:** Sets up the initial game state, creates elements, adds the event listener, and starts the `gameLoop`.\n    *   **`initGame()` is called at the end to start the game.**\n\n### Limitations and Further Improvements:\n\n*   **Exact Copy:** This is far from an exact copy. Key missing features for an exact replica include:\n    *   **Graphics:** Original PAC-MAN used tile-based graphics with sprites for Pac-Man's mouth animation, ghost animations, etc.\n    *   **Sound Effects:** Crucial for the PAC-MAN experience (eating pellets, dying,"
}