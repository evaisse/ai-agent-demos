<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PAC-MAN (Simplified)</title>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #000;
            margin: 0;
            font-family: 'Press Start 2P', cursive; /* A pixelated font for the feel */
            color: white;
            flex-direction: column;
        }

        #game-container {
            position: relative;
            width: 500px; /* Adjust as needed */
            height: 500px; /* Adjust as needed */
            border: 2px solid #fff;
            background-color: #000;
            overflow: hidden; /* Crucial to keep elements within bounds */
        }

        .game-element {
            position: absolute;
            box-sizing: border-box; /* Include padding and border in the element's total width and height */
        }

        #pacman {
            background-color: yellow;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%); /* Center it initially */
            transition: top 0.1s linear, left 0.1s linear; /* Smooth movement */
            z-index: 10; /* Ensure Pac-Man is on top */
        }

        .wall {
            background-color: blue;
            border: 2px solid #000; /* Small border to distinguish */
        }

        .pellet {
            background-color: white;
            border-radius: 50%;
            width: 8px;
            height: 8px;
        }

        .ghost {
            background-color: red; /* Default ghost color */
            border-radius: 5px; /* Slightly rounded corners */
            width: 20px;
            height: 20px;
            z-index: 5;
        }

        /* Specific ghost colors */
        .ghost.blinky { background-color: red; }
        .ghost.pinky { background-color: pink; }
        .ghost.inky { background-color: cyan; }
        .ghost.clyde { background-color: orange; }

        #game-info {
            margin-top: 20px;
            font-size: 1.2em;
            text-align: center;
        }

        #score {
            font-weight: bold;
        }

        #lives {
            margin-left: 20px;
        }

        #message {
            margin-top: 10px;
            font-size: 1.5em;
            color: yellow;
            text-align: center;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 20;
            display: none; /* Hidden by default */
        }
    </style>
    <!-- You'd typically link to external fonts, but for a single file, we can embed if available via CDN -->
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
</head>
<body>
    <h1>PAC-MAN (Simplified)</h1>
    <div id="game-container">
        <div id="pacman"></div>
        </div>
    <div id="game-info">
        Score: <span id="score">0</span>
        Lives: <span id="lives">3</span>
    </div>
    <div id="message"></div>

    <script>
        const gameContainer = document.getElementById('game-container');
        const pacman = document.getElementById('pacman');
        const scoreDisplay = document.getElementById('score');
        const livesDisplay = document.getElementById('lives');
        const messageDisplay = document.getElementById('message');

        // Game constants
        const TILE_SIZE = 25; // Size of each grid cell
        const GAME_WIDTH = 500;
        const GAME_HEIGHT = 500;
        const PACMAN_SPEED = 5; // Pixels per move
        const GHOST_SPEED = 3;

        // Game state
        let pacmanX = GAME_WIDTH / 2;
        let pacmanY = GAME_HEIGHT / 2;
        let score = 0;
        let lives = 3;
        let direction = { x: 0, y: 0 }; // Current movement direction
        let nextDirection = { x: 0, y: 0 }; // Desired next direction
        let gameInterval;
        let maze = [];
        let pellets = [];
        let ghosts = [];
        let isGameOver = false;
        let isGameWon = false;

        // Maze layout (0: empty, 1: wall, 2: pellet)
        // This is a very basic maze representation. For a true Pac-Man, this would be much more intricate.
        // The maze needs to be a multiple of TILE_SIZE for easy positioning.
        const mazeLayout = [
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
            [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1],
            [1, 2, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 2, 2, 1],
            [1, 2, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 2, 2, 1],
            [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1],
            [1, 2, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 2, 1],
            [1, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 1],
            [1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1],
            [1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1],
            [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1],
            [1, 2, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 2, 1],
            [1, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 1],
            [1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1],
            [1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1],
            [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1],
            [1, 2, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 2, 2, 1],
            [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1],
            [1, 2, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 2, 1],
            [1, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 1],
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
        ];

        // Ghost configurations: { id, startX, startY, color, aiType }
        // AI types are very simplified here.
        const ghostConfigs = [
            { id: 'blinky', startX: 10, startY: 9, color: 'red', aiType: 'chase' },
            { id: 'pinky', startX: 9, startY: 9, color: 'pink', aiType: 'ambush' },
            { id: 'inky', startX: 11, startY: 9, color: 'cyan', aiType: 'random' },
            { id: 'clyde', startX: 12, startY: 9, color: 'orange', aiType: 'scatter' }
        ];

        // Function to create DOM elements for maze, pellets, and ghosts
        function createGameElements() {
            gameContainer.innerHTML = '<div id="pacman"></div>'; // Reset container, keep pacman

            const mazeGridWidth = mazeLayout[0].length;
            const mazeGridHeight = mazeLayout.length;

            for (let row = 0; row < mazeGridHeight; row++) {
                for (let col = 0; col < mazeGridWidth; col++) {
                    const cellType = mazeLayout[row][col];
                    const x = col * TILE_SIZE;
                    const y = row * TILE_SIZE;

                    if (cellType === 1) { // Wall
                        const wall = document.createElement('div');
                        wall.classList.add('game-element', 'wall');
                        wall.style.left = `${x}px`;
                        wall.style.top = `${y}px`;
                        wall.style.width = `${TILE_SIZE}px`;
                        wall.style.height = `${TILE_SIZE}px`;
                        gameContainer.appendChild(wall);
                    } else if (cellType === 2) { // Pellet
                        const pellet = document.createElement('div');
                        pellet.classList.add('game-element', 'pellet');
                        pellet.style.left = `${x + TILE_SIZE / 2 - 4}px`; // Centered pellet
                        pellet.style.top = `${y + TILE_SIZE / 2 - 4}px`;
                        pellet.dataset.row = row;
                        pellet.dataset.col = col;
                        gameContainer.appendChild(pellet);
                        pellets.push({ x: col, y: row, element: pellet });
                    }
                }
            }

            // Create ghosts
            ghostConfigs.forEach(config => {
                const ghost = document.createElement('div');
                ghost.classList.add('game-element', 'ghost', config.id);
                ghost.style.left = `${config.startX * TILE_SIZE}px`;
                ghost.style.top = `${config.startY * TILE_SIZE}px`;
                gameContainer.appendChild(ghost);
                ghosts.push({
                    ...config,
                    element: ghost,
                    currentX: config.startX * TILE_SIZE,
                    currentY: config.startY * TILE_SIZE,
                    direction: { x: 0, y: 0 }, // Initial direction
                    speed: GHOST_SPEED
                });
            });

            // Center Pac-Man in the maze grid
            const numCols = mazeLayout[0].length;
            const numRows = mazeLayout.length;
            let pacmanGridCol = Math.floor(numCols / 2);
            let pacmanGridRow = Math.floor(numRows / 2);

            // Find a valid starting position for Pac-Man
            while (mazeLayout[pacmanGridRow][pacmanGridCol] === 1) {
                pacmanGridCol++;
                if (pacmanGridCol >= numCols) {
                    pacmanGridCol = 0;
                    pacmanGridRow++;
                    if (pacmanGridRow >= numRows) {
                        pacmanGridRow = 0; // Wrap around if needed
                    }
                }
            }

            pacmanX = pacmanGridCol * TILE_SIZE + TILE_SIZE / 2;
            pacmanY = pacmanGridRow * TILE_SIZE + TILE_SIZE / 2;
            pacman.style.left = `${pacmanX}px`;
            pacman.style.top = `${pacmanY}px`;
        }

        // Function to check for collisions with walls
        function isWallCollision(x, y) {
            const gridCol = Math.floor(x / TILE_SIZE);
            const gridRow = Math.floor(y / TILE_SIZE);

            // Check boundaries
            if (gridCol < 0 || gridCol >= mazeLayout[0].length || gridRow < 0 || gridRow >= mazeLayout.length) {
                return true; // Treat out of bounds as a wall
            }

            return mazeLayout[gridRow][gridCol] === 1;
        }

        // Function to check for collisions with pellets
        function checkPelletCollision() {
            const pacmanGridCol = Math.floor(pacmanX / TILE_SIZE);
            const pacmanGridRow = Math.floor(pacmanY / TILE_SIZE);

            for (let i = pellets.length - 1; i >= 0; i--) {
                const pellet = pellets[i];
                if (pellet.x === pacmanGridCol && pellet.y === pacmanGridRow) {
                    score += 10;
                    scoreDisplay.textContent = score;
                    pellet.element.remove();
                    pellets.splice(i, 1);
                    if (pellets.length === 0) {
                        winGame();
                    }
                    return;
                }
            }
        }

        // Function to check for collisions with ghosts
        function checkGhostCollision() {
            const pacmanRect = pacman.getBoundingClientRect();

            for (const ghost of ghosts) {
                const ghostRect = ghost.element.getBoundingClientRect();

                // Basic AABB collision detection
                if (pacmanRect.left < ghostRect.right &&
                    pacmanRect.right > ghostRect.left &&
                    pacmanRect.top < ghostRect.bottom &&
                    pacmanRect.bottom > ghostRect.top) {
                    loseLife();
                    return;
                }
            }
        }

        // Function to handle losing a life
        function loseLife() {
            lives--;
            livesDisplay.textContent = lives;

            if (lives <= 0) {
                gameOver();
                return;
            }

            // Reset Pac-Man position and clear directions
            const numCols = mazeLayout[0].length;
            const numRows = mazeLayout.length;
            let pacmanGridCol = Math.floor(numCols / 2);
            let pacmanGridRow = Math.floor(numRows / 2);

            while (mazeLayout[pacmanGridRow][pacmanGridCol] === 1) {
                pacmanGridCol++;
                if (pacmanGridCol >= numCols) {
                    pacmanGridCol = 0;
                    pacmanGridRow++;
                    if (pacmanGridRow >= numRows) {
                        pacmanGridRow = 0;
                    }
                }
            }

            pacmanX = pacmanGridCol * TILE_SIZE + TILE_SIZE / 2;
            pacmanY = pacmanGridRow * TILE_SIZE + TILE_SIZE / 2;
            pacman.style.left = `${pacmanX}px`;
            pacman.style.top = `${pacmanY}px`;
            direction = { x: 0, y: 0 };
            nextDirection = { x: 0, y: 0 };

            // Reset ghosts to their starting positions
            ghosts.forEach(ghost => {
                ghost.currentX = ghost.startX * TILE_SIZE + TILE_SIZE / 2;
                ghost.currentY = ghost.startY * TILE_SIZE + TILE_SIZE / 2;
                ghost.element.style.left = `${ghost.currentX}px`;
                ghost.element.style.top = `${ghost.currentY}px`;
                ghost.direction = { x: 0, y: 0 };
            });

            // Briefly pause game for reset
            setTimeout(() => {
                // Game continues
            }, 1000);
        }

        // Function to handle game over
        function gameOver() {
            isGameOver = true;
            clearInterval(gameInterval);
            messageDisplay.textContent = "GAME OVER!";
            messageDisplay.style.display = 'block';
            document.removeEventListener('keydown', handleKeyPress);
        }

        // Function to handle game win
        function winGame() {
            isGameWon = true;
            clearInterval(gameInterval);
            messageDisplay.textContent = "YOU WIN!";
            messageDisplay.style.display = 'block';
            document.removeEventListener('keydown', handleKeyPress);
        }

        // Function to move Pac-Man
        function movePacman() {
            // Try to change direction if a new direction is queued and possible
            if (nextDirection.x !== 0 || nextDirection.y !== 0) {
                const potentialX = pacmanX + nextDirection.x * PACMAN_SPEED;
                const potentialY = pacmanY + nextDirection.y * PACMAN_SPEED;

                if (!isWallCollision(potentialX, potentialY)) {
                    direction = { ...nextDirection };
                    nextDirection = { x: 0, y: 0 }; // Reset next direction as it's now active
                }
            }

            // Move in the current direction if possible
            const newPacmanX = pacmanX + direction.x * PACMAN_SPEED;
            const newPacmanY = pacmanY + direction.y * PACMAN_SPEED;

            if (!isWallCollision(newPacmanX, newPacmanY)) {
                pacmanX = newPacmanX;
                pacmanY = newPacmanY;
                pacman.style.left = `${pacmanX}px`;
                pacman.style.top = `${pacmanY}px`;
            } else {
                // If we hit a wall in the current direction, stop
                direction = { x: 0, y: 0 };
            }
        }

        // Simplified AI for ghosts
        function moveGhost(ghost) {
            const gridCol = Math.floor(ghost.currentX / TILE_SIZE);
            const gridRow = Math.floor(ghost.currentY / TILE_SIZE);

            // Simple AI: try to move towards the player or scatter
            let possibleMoves = [];
            const directions = [
                { dx: 0, dy: -1 }, // Up
                { dx: 0, dy: 1 },  // Down
                { dx: -1, dy: 0 }, // Left
                { dx: 1, dy: 0 }   // Right
            ];

            // Filter out moves that go into walls
            for (const dir of directions) {
                const nextGridCol = gridCol + dir.dx;
                const nextGridRow = gridRow + dir.dy;

                if (!isWallCollision(nextGridCol * TILE_SIZE + TILE_SIZE / 2, nextGridRow * TILE_SIZE + TILE_SIZE / 2)) {
                    possibleMoves.push({ ...dir });
                }
            }

            // Remove the opposite direction if it's not the only option (to prevent ghosts from just going back and forth)
            if (possibleMoves.length > 1) {
                const oppositeDir = { x: -ghost.direction.x, y: -ghost.direction.y };
                const oppositeIndex = possibleMoves.findIndex(move => move.dx === oppositeDir.x && move.dy === oppositeDir.y);
                if (oppositeIndex !== -1) {
                    possibleMoves.splice(oppositeIndex, 1);
                }
            }

            // Choose a direction based on AI type
            let chosenDirection = { x: 0, y: 0 };

            if (ghost.aiType === 'chase') {
                // Simple chase: move towards Pac-Man's current grid position
                const dx = pacmanX - ghost.currentX;
                const dy = pacmanY - ghost.currentY;

                if (Math.abs(dx) > Math.abs(dy)) {
                    chosenDirection.x = dx > 0 ? 1 : -1;
                } else {
                    chosenDirection.y = dy > 0 ? 1 : -1;
                }
            } else if (ghost.aiType === 'random') {
                // Random movement
                if (possibleMoves.length > 0) {
                    chosenDirection = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
                }
            } else if (ghost.aiType === 'scatter') {
                // Scatter: move towards a corner (simplified)
                // For simplicity, let's just pick a random valid move. A true scatter would be towards a specific corner.
                if (possibleMoves.length > 0) {
                    chosenDirection = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
                }
            } else if (ghost.aiType === 'ambush') {
                // Ambush (Pinky's AI): try to move to a position ahead of Pac-Man
                // This is a very simplified version. True Pinky AI targets 4 tiles ahead of Pac-Man.
                const targetX = pacmanX + ghost.direction.x * 4 * TILE_SIZE; // Approximation
                const targetY = pacmanY + ghost.direction.y * 4 * TILE_SIZE;

                const dx = targetX - ghost.currentX;
                const dy = targetY - ghost.currentY;

                if (Math.abs(dx) > Math.abs(dy)) {
                    chosenDirection.x = dx > 0 ? 1 : -1;
                } else {
                    chosenDirection.y = dy > 0 ? 1 : -1;
                }
            }

            // If the chosen direction is valid, update ghost's direction
            const isValidChosenDirection = possibleMoves.some(move => move.dx === chosenDirection.x && move.dy === chosenDirection.y);
            if (isValidChosenDirection && (chosenDirection.x !== 0 || chosenDirection.y !== 0)) {
                ghost.direction = chosenDirection;
            } else if (possibleMoves.length > 0) {
                // If chosen direction is not valid, pick a random valid move
                ghost.direction = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
            } else {
                // If no moves are possible (stuck), reverse direction
                ghost.direction = { x: -ghost.direction.x, y: -ghost.direction.y };
            }


            // Move the ghost
            ghost.currentX += ghost.direction.x * ghost.speed;
            ghost.currentY += ghost.direction.y * ghost.speed;

            // Snap to grid when close to the center of a tile to avoid drift
            const gridCol = Math.round(ghost.currentX / TILE_SIZE);
            const gridRow = Math.round(ghost.currentY / TILE_SIZE);
            ghost.currentX = gridCol * TILE_SIZE + TILE_SIZE / 2;
            ghost.currentY = gridRow * TILE_SIZE + TILE_SIZE / 2;


            ghost.element.style.left = `${ghost.currentX - TILE_SIZE / 2}px`; // Adjust for element's origin
            ghost.element.style.top = `${ghost.currentY - TILE_SIZE / 2}px`;
        }


        // Handle keyboard input
        function handleKeyPress(event) {
            switch (event.key) {
                case 'ArrowUp':
                    nextDirection = { x: 0, y: -1 };
                    break;
                case 'ArrowDown':
                    nextDirection = { x: 0, y: 1 };
                    break;
                case 'ArrowLeft':
                    nextDirection = { x: -1, y: 0 };
                    break;
                case 'ArrowRight':
                    nextDirection = { x: 1, y: 0 };
                    break;
            }
        }

        // Game loop
        function gameLoop() {
            if (isGameOver || isGameWon) return;

            movePacman();
            checkPelletCollision();
            checkGhostCollision();

            // Move ghosts
            ghosts.forEach(moveGhost);
        }

        // Initialize game
        function initGame() {
            createGameElements();
            document.addEventListener('keydown', handleKeyPress);
            gameInterval = setInterval(gameLoop, 1000 / 60); // 60 FPS
        }

        // Start the game when the page loads
        initGame();
    </script>
</body>
</html>