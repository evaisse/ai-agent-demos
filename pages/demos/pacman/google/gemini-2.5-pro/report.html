<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OpenRouter API Response</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            max-width: 900px;
            margin: 0 auto;
            padding: 2rem;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        .container {
            background: white;
            border-radius: 16px;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            padding: 2rem;
        }
        h1 {
            color: #1a202c;
            margin-bottom: 1.5rem;
            font-size: 2rem;
        }
        .metadata {
            background: #f7fafc;
            border-left: 4px solid #667eea;
            padding: 1rem;
            margin-bottom: 2rem;
            border-radius: 4px;
        }
        .metadata p {
            margin: 0.5rem 0;
            color: #4a5568;
        }
        .metadata strong {
            color: #2d3748;
        }
        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 1rem;
            margin-bottom: 2rem;
        }
        .metric-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 1rem;
            border-radius: 8px;
            text-align: center;
        }
        .metric-value {
            font-size: 1.5rem;
            font-weight: bold;
        }
        .metric-label {
            font-size: 0.875rem;
            opacity: 0.9;
        }
        .prompt-section, .response-section {
            margin-bottom: 2rem;
        }
        .section-title {
            font-size: 1.25rem;
            font-weight: 600;
            color: #2d3748;
            margin-bottom: 1rem;
        }
        .content-box {
            background: #f9fafb;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 1.5rem;
            white-space: pre-wrap;
            word-wrap: break-word;
            color: #2d3748;
            line-height: 1.6;
        }
        .response-content {
            background: white;
            border: 2px solid #667eea;
        }
        code {
            background: #edf2f7;
            padding: 0.2rem 0.4rem;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
        }
        pre {
            background: #2d3748;
            color: #e2e8f0;
            padding: 1rem;
            border-radius: 8px;
            overflow-x: auto;
        }
        pre code {
            background: transparent;
            padding: 0;
            color: inherit;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ü§ñ OpenRouter API Response</h1>
        
        <div class="metadata">
            <p><strong>Model:</strong> google/gemini-2.5-pro</p>
            <p><strong>Generated:</strong> 2025-10-06T11:43:22.332Z</p>
        </div>
        
        <div class="metrics">
            <div class="metric-card">
                <div class="metric-value">20952</div>
                <div class="metric-label">Total Tokens</div>
            </div>
            <div class="metric-card">
                <div class="metric-value">16.629s</div>
                <div class="metric-label">Duration</div>
            </div>
            <div class="metric-card">
                <div class="metric-value">$0.1622</div>
                <div class="metric-label">Total Cost</div>
            </div>
        </div>
        
        <div class="prompt-section">
            <div class="section-title">üìù Prompt</div>
            <div class="content-box">In a single HTML file named index.html, create exact copy of the PAC-MAN game in one html file using css and js.
</div>
        </div>
        
        <div class="response-section">
            <div class="section-title">üí¨ Response</div>
            <div class="content-box response-content">Of course. Here is a complete, self-contained <code>index.html</code> file that creates a functional and visually recognizable clone of the classic PAC-MAN game. All the HTML, CSS, and JavaScript are embedded within this single file.<br><br>To use it, simply copy all the code below, paste it into a new text file, and save it as <code>index.html</code>. Then, open that file in any modern web browser.<br><br>### Features Included:<br>*   **Complete Maze:** A faithful representation of the classic Pac-Man maze layout.<br>*   **Pac-Man:** Fully animated (mouth chomping) and controllable with arrow keys.<br>*   **Ghosts:** Four ghosts (Blinky, Pinky, Inky, Clyde) with distinct (though simplified) AI behaviors.<br>    *   **Blinky (Red):** Directly chases Pac-Man.<br>    *   **Pinky (Pink):** Tries to ambush Pac-Man by targeting a few steps ahead of him.<br>    *   **Inky (Cyan):** Has a more complex targeting, using both Pac-Man and Blinky&#039;s positions.<br>    *   **Clyde (Orange):** Chases Pac-Man when far away but gets scared and retreats to his corner when too close.<br>*   **Pellets &amp; Power Pellets:** Collect all pellets to win the level. Power pellets make ghosts vulnerable.<br>*   **Ghost States:** Ghosts can be in <code>chase</code>, <code>scatter</code>, or <code>frightened</code> modes.<br>*   **Scoring &amp; Lives:** A functional scoring and life system.<br>*   **Game States:** Includes a &quot;Ready!&quot; screen, gameplay, life loss sequence, and &quot;Game Over&quot; screen.<br><br>---<br><br>### <code>index.html</code><br><br><pre><code>&lt;!DOCTYPE html&gt;<br>&lt;html lang=&quot;en&quot;&gt;<br>&lt;head&gt;<br>    &lt;meta charset=&quot;UTF-8&quot;&gt;<br>    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;<br>    &lt;title&gt;PAC-MAN&lt;/title&gt;<br>    &lt;style&gt;<br>        body {<br>            margin: 0;<br>            padding: 0;<br>            background-color: #000;<br>            color: #fff;<br>            font-family: &#039;Press Start 2P&#039;, monospace, sans-serif; /* A common retro game font */<br>            display: flex;<br>            justify-content: center;<br>            align-items: center;<br>            height: 100vh;<br>            flex-direction: column;<br>            text-align: center;<br>        }<br><br>        @font-face {<br>            font-family: &#039;Press Start 2P&#039;;<br>            src: url(&#039;https://fonts.gstatic.com/s/pressstart2p/v15/e3t4euO8T-267oIAQAu6jDQyK3nVivM.woff2&#039;) format(&#039;woff2&#039;);<br>            font-weight: normal;<br>            font-style: normal;<br>        }<br><br>        h1 {<br>            color: #FFFF00;<br>            text-shadow: 2px 2px #FF0000;<br>        }<br><br>        #game-container {<br>            position: relative;<br>            border: 2px solid #1E90FF;<br>            box-shadow: 0 0 20px #1E90FF;<br>        }<br><br>        #game-canvas {<br>            background-color: #000;<br>            display: block;<br>        }<br><br>        #game-info {<br>            display: flex;<br>            justify-content: space-between;<br>            width: 560px; /* Same as canvas width */<br>            padding: 10px 0;<br>            font-size: 16px;<br>        }<br><br>        #score, #lives {<br>            color: #fff;<br>        }<br>        <br>        #start-screen, #game-over-screen {<br>            position: absolute;<br>            top: 0;<br>            left: 0;<br>            width: 100%;<br>            height: 100%;<br>            background-color: rgba(0, 0, 0, 0.7);<br>            display: flex;<br>            flex-direction: column;<br>            justify-content: center;<br>            align-items: center;<br>            color: #FFFF00;<br>            font-size: 24px;<br>            text-align: center;<br>            z-index: 10;<br>        }<br>        <br>        #game-over-screen p {<br>            margin: 10px 0;<br>        }<br><br>        #game-over-screen button {<br>            padding: 10px 20px;<br>            font-family: &#039;Press Start 2P&#039;, monospace, sans-serif;<br>            background-color: #FFFF00;<br>            color: #000;<br>            border: none;<br>            cursor: pointer;<br>            margin-top: 20px;<br>        }<br><br>        #game-over-screen button:hover {<br>            background-color: #fff;<br>        }<br><br>    &lt;/style&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>    &lt;h1&gt;PAC-MAN&lt;/h1&gt;<br>    &lt;div id=&quot;game-info&quot;&gt;<br>        &lt;div id=&quot;score&quot;&gt;SCORE: 0&lt;/div&gt;<br>        &lt;div id=&quot;lives&quot;&gt;LIVES: ‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è&lt;/div&gt;<br>    &lt;/div&gt;<br>    &lt;div id=&quot;game-container&quot;&gt;<br>        &lt;canvas id=&quot;game-canvas&quot; width=&quot;560&quot; height=&quot;620&quot;&gt;&lt;/canvas&gt;<br>        &lt;div id=&quot;start-screen&quot;&gt;<br>            &lt;p&gt;READY!&lt;/p&gt;<br>        &lt;/div&gt;<br>        &lt;div id=&quot;game-over-screen&quot; style=&quot;display: none;&quot;&gt;<br>            &lt;p&gt;GAME OVER&lt;/p&gt;<br>            &lt;p id=&quot;final-score&quot;&gt;&lt;/p&gt;<br>            &lt;button onclick=&quot;window.location.reload()&quot;&gt;RESTART&lt;/button&gt;<br>        &lt;/div&gt;<br>    &lt;/div&gt;<br><br>    &lt;script&gt;<br>    document.addEventListener(&#039;DOMContentLoaded&#039;, () =&gt; {<br>        const canvas = document.getElementById(&#039;game-canvas&#039;);<br>        const ctx = canvas.getContext(&#039;2d&#039;);<br>        const scoreEl = document.getElementById(&#039;score&#039;);<br>        const livesEl = document.getElementById(&#039;lives&#039;);<br>        const startScreen = document.getElementById(&#039;start-screen&#039;);<br>        const gameOverScreen = document.getElementById(&#039;game-over-screen&#039;);<br>        const finalScoreEl = document.getElementById(&#039;final-score&#039;);<br><br>        const TILE_SIZE = 20;<br>        const PACMAN_SPEED = 2;<br>        const GHOST_SPEED = 1.8;<br>        const FRIGHTENED_GHOST_SPEED = 1;<br>        <br>        let score = 0;<br>        let lives = 3;<br>        let pelletsCount = 0;<br>        let gameStarted = false;<br>        let gameOver = false;<br>        let frightenedMode = false;<br>        let frightenedTimer = 0;<br><br>        // Maze layout: 0 = wall, 1 = pellet, 2 = empty, 3 = power pellet, 4 = ghost home<br>        const map = [<br>            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],<br>            [0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0],<br>            [0,1,0,0,1,1,0,0,1,1,0,0,1,0,0,1,0,0,1,1,0,0,1,1,0,0,1,0],<br>            [0,3,0,0,1,1,0,0,1,1,0,0,1,0,0,1,0,0,1,1,0,0,1,1,0,0,3,0],<br>            [0,1,0,0,1,1,0,0,1,1,0,0,1,0,0,1,0,0,1,1,0,0,1,1,0,0,1,0],<br>            [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],<br>            [0,1,0,0,1,1,0,1,1,0,1,1,1,0,0,1,1,1,0,1,1,0,1,1,0,0,1,0],<br>            [0,1,1,1,1,1,0,1,1,0,1,1,1,0,0,1,1,1,0,1,1,0,1,1,1,1,1,0],<br>            [0,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0],<br>            [0,0,0,0,1,1,0,1,1,0,0,0,1,0,0,1,0,0,0,1,1,0,1,1,0,0,0,0],<br>            [0,0,0,0,1,1,0,1,1,0,1,1,1,1,1,1,1,1,0,1,1,0,1,1,0,0,0,0],<br>            [0,0,0,0,1,1,0,1,1,0,1,0,0,4,4,0,0,1,0,1,1,0,1,1,0,0,0,0],<br>            [0,0,0,0,1,1,1,1,1,1,1,0,4,4,4,4,0,1,1,1,1,1,1,1,0,0,0,0],<br>            [2,2,2,2,1,1,1,1,1,1,1,0,4,4,4,4,0,1,1,1,1,1,1,1,2,2,2,2], // Tunnel<br>            [0,0,0,0,1,1,1,1,1,1,1,0,4,4,4,4,0,1,1,1,1,1,1,1,0,0,0,0],<br>            [0,0,0,0,1,1,0,1,1,0,1,0,0,0,0,0,0,1,0,1,1,0,1,1,0,0,0,0],<br>            [0,0,0,0,1,1,0,1,1,0,1,1,1,1,1,1,1,1,0,1,1,0,1,1,0,0,0,0],<br>            [0,0,0,0,1,1,0,1,1,0,0,0,1,0,0,1,0,0,0,1,1,0,1,1,0,0,0,0],<br>            [0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0],<br>            [0,1,0,0,1,1,0,0,1,1,0,0,1,0,0,1,0,0,1,1,0,0,1,1,0,0,1,0],<br>            [0,3,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,3,0],<br>            [0,1,0,0,1,1,0,1,1,0,1,1,1,0,0,1,1,1,0,1,1,0,1,1,0,0,1,0],<br>            [0,1,1,1,1,1,0,1,1,0,1,1,1,0,0,1,1,1,0,1,1,0,1,1,1,1,1,0],<br>            [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],<br>            [0,1,0,0,1,1,0,0,1,1,0,0,1,0,0,1,0,0,1,1,0,0,1,1,0,0,1,0],<br>            [0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0],<br>            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]<br>        ];<br><br>        class Pacman {<br>            constructor(x, y, speed) {<br>                this.x = x;<br>                this.y = y;<br>                this.speed = speed;<br>                this.radius = TILE_SIZE / 2;<br>                this.mouth = 0;<br>                this.direction = { x: 0, y: 0 };<br>                this.nextDirection = { x: 0, y: 0 };<br>            }<br><br>            draw() {<br>                const angle = 0.2 * Math.PI * Math.abs(Math.sin(this.mouth));<br>                ctx.save();<br>                ctx.translate(this.x, this.y);<br><br>                let rotation = 0;<br>                if (this.direction.x === 1) rotation = 0;<br>                else if (this.direction.x === -1) rotation = Math.PI;<br>                else if (this.direction.y === 1) rotation = 0.5 * Math.PI;<br>                else if (this.direction.y === -1) rotation = 1.5 * Math.PI;<br>                <br>                ctx.rotate(rotation);<br><br>                ctx.fillStyle = &#039;yellow&#039;;<br>                ctx.beginPath();<br>                ctx.arc(0, 0, this.radius, angle, 2 * Math.PI - angle);<br>                ctx.lineTo(0, 0);<br>                ctx.closePath();<br>                ctx.fill();<br>                ctx.restore();<br>            }<br><br>            update() {<br>                this.mouth += 0.1;<br>                this.handleInput();<br>                this.move();<br>                this.eatPellet();<br>            }<br><br>            handleInput() {<br>                if (this.isAtGridCenter()) {<br>                    const nextGridX = Math.floor((this.x + this.nextDirection.x * TILE_SIZE) / TILE_SIZE);<br>                    const nextGridY = Math.floor((this.y + this.nextDirection.y * TILE_SIZE) / TILE_SIZE);<br>                    if (map[nextGridY] &amp;&amp; map[nextGridY][nextGridX] !== 0) {<br>                        this.direction = { ...this.nextDirection };<br>                    }<br>                }<br>            }<br>            <br>            isAtGridCenter() {<br>                return (this.x % TILE_SIZE === TILE_SIZE / 2) &amp;&amp; (this.y % TILE_SIZE === TILE_SIZE / 2);<br>            }<br><br>            move() {<br>                // Check for wall collision<br>                const currentGridX = Math.floor(this.x / TILE_SIZE);<br>                const currentGridY = Math.floor(this.y / TILE_SIZE);<br>                const nextX = this.x + this.direction.x * this.speed;<br>                const nextY = this.y + this.direction.y * this.speed;<br>                <br>                if (this.isAtGridCenter()) {<br>                    const nextGridX = currentGridX + this.direction.x;<br>                    const nextGridY = currentGridY + this.direction.y;<br>                    if (map[nextGridY] &amp;&amp; map[nextGridY][nextGridX] === 0) {<br>                        this.direction.x = 0;<br>                        this.direction.y = 0;<br>                    }<br>                }<br>                <br>                this.x += this.direction.x * this.speed;<br>                this.y += this.direction.y * this.speed;<br><br>                // Tunnel logic<br>                if (this.x &lt; 0) this.x = canvas.width;<br>                if (this.x &gt; canvas.width) this.x = 0;<br>            }<br>            <br>            eatPellet() {<br>                const gridX = Math.floor(this.x / TILE_SIZE);<br>                const gridY = Math.floor(this.y / TILE_SIZE);<br><br>                if (map[gridY] &amp;&amp; map[gridY][gridX] === 1) {<br>                    map[gridY][gridX] = 2; // Mark as eaten<br>                    score += 10;<br>                    pelletsCount--;<br>                    updateScore();<br>                } else if (map[gridY] &amp;&amp; map[gridY][gridX] === 3) {<br>                    map[gridY][gridX] = 2; // Mark as eaten<br>                    score += 50;<br>                    pelletsCount--;<br>                    activateFrightenedMode();<br>                    updateScore();<br>                }<br>            }<br>        }<br>        <br>        class Ghost {<br>            constructor(x, y, color, speed, scatterTarget) {<br>                this.x = x;<br>                this.y = y;<br>                this.color = color;<br>                this.speed = speed;<br>                this.radius = TILE_SIZE / 2;<br>                this.direction = { x: 0, y: -1 };<br>                this.state = &#039;scatter&#039;; // scatter, chase, frightened<br>                this.scatterTarget = scatterTarget;<br>                this.target = { x: 0, y: 0 };<br>                this.frightenedTimer = 0;<br>                this.isEaten = false;<br>                this.home = {x: 13.5 * TILE_SIZE, y: 13.5 * TILE_SIZE};<br>            }<br><br>            draw() {<br>                ctx.fillStyle = this.state === &#039;frightened&#039; ? &#039;#0000FF&#039; : this.color;<br>                if (this.isEaten) ctx.fillStyle = &#039;#888&#039;;<br>                <br>                ctx.beginPath();<br>                ctx.arc(this.x, this.y, this.radius, Math.PI, 0);<br>                ctx.lineTo(this.x + this.radius, this.y + this.radius);<br>                ctx.lineTo(this.x - this.radius, this.y + this.radius);<br>                ctx.closePath();<br>                ctx.fill();<br><br>                // Eyes<br>                ctx.fillStyle = &#039;white&#039;;<br>                const eyeOffsetX = this.radius * 0.3;<br>                const eyeOffsetY = -this.radius * 0.2;<br>                ctx.beginPath();<br>                ctx.arc(this.x - eyeOffsetX, this.y + eyeOffsetY, this.radius * 0.2, 0, 2*Math.PI);<br>                ctx.arc(this.x + eyeOffsetX, this.y + eyeOffsetY, this.radius * 0.2, 0, 2*Math.PI);<br>                ctx.fill();<br>                <br>                // Pupils<br>                ctx.fillStyle = &#039;black&#039;;<br>                const pupilOffsetX = this.direction.x * this.radius * 0.1;<br>                const pupilOffsetY = this.direction.y * this.radius * 0.1;<br>                ctx.beginPath();<br>                ctx.arc(this.x - eyeOffsetX + pupilOffsetX, this.y + eyeOffsetY + pupilOffsetY, this.radius * 0.1, 0, 2*Math.PI);<br>                ctx.arc(this.x + eyeOffsetX + pupilOffsetX, this.y + eyeOffsetY + pupilOffsetY, this.radius * 0.1, 0, 2*Math.PI);<br>                ctx.fill();<br><br>                if (this.state === &#039;frightened&#039;) {<br>                    ctx.strokeStyle = &#039;white&#039;;<br>                    ctx.lineWidth = 1;<br>                    ctx.beginPath();<br>                    ctx.moveTo(this.x - 5, this.y + 5);<br>                    ctx.lineTo(this.x + 5, this.y + 5);<br>                    ctx.stroke();<br>                }<br>            }<br><br>            update() {<br>                if (this.isEaten) {<br>                    this.target = this.home;<br>                    const dx = this.target.x - this.x;<br>                    const dy = this.target.y - this.y;<br>                    if (Math.abs(dx) &lt; this.speed &amp;&amp; Math.abs(dy) &lt; this.speed) {<br>                        this.isEaten = false;<br>                        this.state = &#039;chase&#039;; // Or scatter<br>                    }<br>                } else {<br>                    this.setTarget();<br>                }<br>                <br>                this.move();<br>            }<br>            <br>            setTarget() {<br>                if (this.state === &#039;scatter&#039;) {<br>                    this.target = this.scatterTarget;<br>                } else if (this.state === &#039;chase&#039;) {<br>                    this.chase();<br>                } else if (this.state === &#039;frightened&#039;) {<br>                    // Move randomly<br>                    if (this.isAtGridCenter()) {<br>                        const possibleMoves = this.getPossibleMoves();<br>                        if (possibleMoves.length &gt; 0) {<br>                            this.direction = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];<br>                        }<br>                    }<br>                    return; // Skip normal targeting<br>                }<br>            }<br><br>            move() {<br>                if (this.isAtGridCenter()) {<br>                    const bestMove = this.getBestMove();<br>                    if(bestMove) this.direction = bestMove;<br>                }<br>                <br>                this.x += this.direction.x * (this.state === &#039;frightened&#039; ? FRIGHTENED_GHOST_SPEED : this.speed);<br>                this.y += this.direction.y * (this.state === &#039;frightened&#039; ? FRIGHTENED_GHOST_SPEED : this.speed);<br>                <br>                // Tunnel<br>                if (this.x &lt; 0) this.x = canvas.width;<br>                if (this.x &gt; canvas.width) this<br>.x = 0;<br>            }<br><br>            getBestMove() {<br>                const possibleMoves = this.getPossibleMoves();<br>                if (possibleMoves.length === 0) return null;<br><br>                let bestMove = null;<br>                let minDistance = Infinity;<br><br>                for (const move of possibleMoves) {<br>                    const newX = this.x + move.x * TILE_SIZE;<br>                    const newY = this.y + move.y * TILE_SIZE;<br>                    const distance = Math.hypot(newX - this.target.x, newY - this.target.y);<br>                    <br>                    if (distance &lt; minDistance) {<br>                        minDistance = distance;<br>                        bestMove = move;<br>                    }<br>                }<br>                return bestMove;<br>            }<br><br>            getPossibleMoves() {<br>                const moves = [{x:1, y:0}, {x:-1, y:0}, {x:0, y:1}, {x:0, y:-1}];<br>                const possibleMoves = [];<br>                const currentGridX = Math.floor(this.x / TILE_SIZE);<br>                const currentGridY = Math.floor(this.y / TILE_SIZE);<br><br>                for (const move of moves) {<br>                    // Prevent ghost from reversing direction unless in a dead end<br>                    if (move.x === -this.direction.x &amp;&amp; move.y === -this.direction.y) {<br>                        continue;<br>                    }<br>                    <br>                    const nextGridX = currentGridX + move.x;<br>                    const nextGridY = currentGridY + move.y;<br>                    <br>                    // Check if next tile is a wall (0) or the ghost house gate (4)<br>                    if (map[nextGridY] &amp;&amp; map[nextGridY][nextGridX] !== 0) {<br>                         // A special rule for ghosts: they can&#039;t go up into certain zones<br>                         if (move.y === -1 &amp;&amp; (nextGridY === 10 || nextGridY === 22) &amp;&amp; (nextGridX === 12 || nextGridX === 15)) {<br>                             continue;<br>                         }<br>                         possibleMoves.push(move);<br>                    }<br>                }<br>                <br>                // If no other moves are possible, allow reversal (must be a dead end)<br>                if (possibleMoves.length === 0) {<br>                    possibleMoves.push({x: -this.direction.x, y: -this.direction.y});<br>                }<br>                <br>                return possibleMoves;<br>            }<br><br>            isAtGridCenter() {<br>                return (this.x % TILE_SIZE === TILE_SIZE / 2) &amp;&amp; (this.y % TILE_SIZE === TILE_SIZE / 2);<br>            }<br><br>            // This will be overridden by subclasses for specific chase behaviors<br>            chase() {<br>                this.target = { x: pacman.x, y: pacman.y };<br>            }<br>        }<br><br>        class Blinky extends Ghost { // Red<br>            constructor(x, y, speed) {<br>                super(x, y, &#039;#FF0000&#039;, speed, { x: 25 * TILE_SIZE, y: 0 * TILE_SIZE });<br>            }<br>            // Blinky&#039;s chase is the default: target Pac-Man&#039;s exact location. No override needed.<br>        }<br><br>        class Pinky extends Ghost { // Pink<br>            constructor(x, y, speed) {<br>                super(x, y, &#039;#FFB8FF&#039;, speed, { x: 2 * TILE_SIZE, y: 0 * TILE_SIZE });<br>            }<br><br>            chase() {<br>                // Target 4 tiles ahead of Pac-Man&#039;s current direction<br>                this.target = {<br>                    x: pacman.x + pacman.direction.x * 4 * TILE_SIZE,<br>                    y: pacman.y + pacman.direction.y * 4 * TILE_SIZE<br>                };<br>            }<br>        }<br>        <br>        class Inky extends Ghost { // Cyan<br>            constructor(x, y, speed) {<br>                super(x, y, &#039;#00FFFF&#039;, speed, { x: 27 * TILE_SIZE, y: 30 * TILE_SIZE });<br>            }<br><br>            chase() {<br>                // Target is based on a vector from Blinky to 2 tiles ahead of Pac-Man, doubled<br>                const pacmanAhead = {<br>                    x: pacman.x + pacman.direction.x * 2 * TILE_SIZE,<br>                    y: pacman.y + pacman.direction.y * 2 * TILE_SIZE<br>                };<br>                const blinkyPos = { x: blinky.x, y: blinky.y };<br>                <br>                this.target = {<br>                    x: pacmanAhead.x + (pacmanAhead.x - blinkyPos.x),<br>                    y: pacmanAhead.y + (pacmanAhead.y - blinkyPos.y)<br>                };<br>            }<br>        }<br><br>        class Clyde extends Ghost { // Orange<br>            constructor(x, y, speed) {<br>                super(x, y, &#039;#FFB851&#039;, speed, { x: 0 * TILE_SIZE, y: 30 * TILE_SIZE });<br>            }<br><br>            chase() {<br>                const distance = Math.hypot(this.x - pacman.x, this.y - pacman.y);<br>                if (distance &gt; 8 * TILE_SIZE) {<br>                    // If far away, chase Pac-Man (like Blinky)<br>                    this.target = { x: pacman.x, y: pacman.y };<br>                } else {<br>                    // If too close, retreat to his scatter corner<br>                    this.target = this.scatterTarget;<br>                }<br>            }<br>        }<br><br>        let pacman;<br>        let ghosts;<br>        let blinky, pinky, inky, clyde;<br><br>        function init() {<br>            // Recalculate total pellets every time for restarts<br>            pelletsCount = 0;<br>            map.forEach(row =&gt; {<br>                row.forEach(tile =&gt; {<br>                    if (tile === 1 || tile === 3) pelletsCount++;<br>                });<br>            });<br><br>            resetCharacters();<br>            <br>            updateScore();<br>            updateLives();<br>            <br>            startScreen.style.display = &#039;flex&#039;;<br>            gameOverScreen.style.display = &#039;none&#039;;<br><br>            // Initial draw<br>            draw();<br><br>            // Start game after &quot;Ready!&quot; message<br>            setTimeout(() =&gt; {<br>                startScreen.style.display = &#039;none&#039;;<br>                gameStarted = true;<br>                gameLoop();<br>            }, 2000);<br>        }<br><br>        function resetCharacters() {<br>            pacman = new Pacman(14 * TILE_SIZE - TILE_SIZE / 2, 23 * TILE_SIZE + TILE_SIZE / 2, PACMAN_SPEED);<br>            <br>            blinky = new Blinky(14 * TILE_SIZE - TILE_SIZE / 2, 11 * TILE_SIZE + TILE_SIZE / 2, GHOST_SPEED);<br>            pinky = new Pinky(14 * TILE_SIZE - TILE_SIZE / 2, 14 * TILE_SIZE + TILE_SIZE / 2, GHOST_SPEED);<br>            inky = new Inky(12 * TILE_SIZE - TILE_SIZE / 2, 14 * TILE_SIZE + TILE_SIZE / 2, GHOST_SPEED);<br>            clyde = new Clyde(16 * TILE_SIZE - TILE_SIZE / 2, 14 * TILE_SIZE + TILE_SIZE / 2, GHOST_SPEED);<br><br>            ghosts = [blinky, pinky, inky, clyde];<br>        }<br><br>        function drawMap() {<br>            for (let y = 0; y &lt; map.length; y++) {<br>                for (let x = 0; x &lt; map[y].length; x++) {<br>                    const tile = map[y][x];<br>                    if (tile === 0) { // Wall<br>                        ctx.fillStyle = &#039;#1E90FF&#039;;<br>                        ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);<br>                    } else if (tile === 1) { // Pellet<br>                        ctx.fillStyle = &#039;white&#039;;<br>                        ctx.beginPath();<br>                        ctx.arc(x * TILE_SIZE + TILE_SIZE / 2, y * TILE_SIZE + TILE_SIZE / 2, 2, 0, 2 * Math.PI);<br>                        ctx.fill();<br>                    } else if (tile === 3) { // Power Pellet<br>                        ctx.fillStyle = &#039;white&#039;;<br>                        ctx.beginPath();<br>                        ctx.arc(x * TILE_SIZE + TILE_SIZE / 2, y * TILE_SIZE + TILE_SIZE / 2, 6, 0, 2 * Math.PI);<br>                        ctx.fill();<br>                    }<br>                }<br>            }<br>        }<br>        <br>        function updateScore() {<br>            scoreEl.textContent = <code>SCORE: ${score}</code>;<br>        }<br><br>        function updateLives() {<br>            livesEl.innerHTML = &#039;LIVES: &#039; + &#039;‚ù§Ô∏è&#039;.repeat(lives);<br>        }<br><br>        function activateFrightenedMode() {<br>            frightenedMode = true;<br>            frightenedTimer = 400; // ~6.6 seconds at 60fps<br>            ghosts.forEach(ghost =&gt; {<br>                if (!ghost.isEaten) {<br>                    ghost.state = &#039;frightened&#039;;<br>                    ghost.direction = {x: -ghost.direction.x, y: -ghost.direction.y}; // Reverse direction<br>                }<br>            });<br>        }<br>        <br>        function checkCollisions() {<br>            ghosts.forEach(ghost =&gt; {<br>                const distance = Math.hypot(pacman.x - ghost.x, pacman.y - ghost.y);<br>                if (distance &lt; pacman.radius + ghost.radius - 4) { // -4 for more forgiving collision<br>                    if (ghost.state === &#039;frightened&#039;) {<br>                        if (!ghost.isEaten) {<br>                            score += 200;<br>                            updateScore();<br>                            ghost.isEaten = true;<br>                            ghost.state = &#039;chase&#039;; // Will now target home to respawn<br>                        }<br>                    } else if (!ghost.isEaten) {<br>                        handlePacmanDeath();<br>                    }<br>                }<br>            });<br>        }<br>        <br>        function handlePacmanDeath() {<br>            gameStarted = false; // Pause game logic<br>            lives--;<br>            updateLives();<br><br>            if (lives &lt;= 0) {<br>                gameOver = true;<br>                setTimeout(showGameOver, 1000);<br>            } else {<br>                setTimeout(() =&gt; {<br>                    resetCharacters();<br>                    startScreen.style.display = &#039;flex&#039;; // Show &quot;Ready!&quot; again<br>                    setTimeout(() =&gt; {<br>                        startScreen.style.display = &#039;none&#039;;<br>                        gameStarted = true;<br>                    }, 2000);<br>                }, 1000);<br>            }<br>        }<br>        <br>        function showGameOver() {<br>            finalScoreEl.textContent = <code>FINAL SCORE: ${score}</code>;<br>            gameOverScreen.style.display = &#039;flex&#039;;<br>        }<br><br>        function checkWinCondition() {<br>            if (pelletsCount &lt;= 0) {<br>                gameStarted = false;<br>                gameOver = true;<br>                // Use a timeout to let the last pellet-eating animation finish<br>                setTimeout(() =&gt; {<br>                    alert(&quot;YOU WIN! CONGRATULATIONS!&quot;);<br>                    showGameOver();<br>                }, 500);<br>            }<br>        }<br><br>        let scatterTimer = 0;<br>        const SCATTER_DURATION = 7 * 60; // 7 seconds<br>        const CHASE_DURATION = 20 * 60; // 20 seconds<br>        let wave = 0;<br><br>        function updateGhostStates() {<br>            if (frightenedMode) {<br>                frightenedTimer--;<br>                if (frightenedTimer &lt;= 0) {<br>                    frightenedMode = false;<br>                    ghosts.forEach(g =&gt; {<br>                        if (!g.isEaten) g.state = &#039;chase&#039;; // Return to chase after frightened mode ends<br>                    });<br>                }<br>                return; // Frightened mode overrides scatter/chase logic<br>            }<br><br>            scatterTimer++;<br>            const currentMode = ghosts[0].state;<br><br>            if (currentMode === &#039;scatter&#039; &amp;&amp; scatterTimer &gt; SCATTER_DURATION) {<br>                scatterTimer = 0;<br>                ghosts.forEach(g =&gt; g.state = &#039;chase&#039;);<br>            } else if (currentMode === &#039;chase&#039; &amp;&amp; scatterTimer &gt; CHASE_DURATION) {<br>                scatterTimer = 0;<br>                // Only scatter for the first few waves<br>                if (wave &lt; 4) {<br>                    ghosts.forEach(g =&gt; g.state = &#039;scatter&#039;);<br>                    wave++;<br>                }<br>            }<br>        }<br>        <br>        function draw() {<br>            ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas<br>            drawMap();<br>            pacman.draw();<br>            ghosts.forEach(ghost =&gt; ghost.draw());<br>        }<br><br>        function update() {<br>            pacman.update();<br>            ghosts.forEach(ghost =&gt; ghost.update());<br>            updateGhostStates();<br>            checkCollisions();<br>            checkWinCondition();<br>        }<br><br>        function gameLoop() {<br>            if (gameOver) return;<br>            <br>            if (gameStarted) {<br>                update();<br>            }<br>            draw();<br>            <br>            requestAnimationFrame(gameLoop);<br>        }<br><br>        // Keyboard controls<br>        document.addEventListener(&#039;keydown&#039;, (e) =&gt; {<br>            if ([&#039;ArrowUp&#039;, &#039;ArrowDown&#039;, &#039;ArrowLeft&#039;, &#039;ArrowRight&#039;].includes(e.key)) {<br>                e.preventDefault(); // Prevent page scrolling<br>            }<br>            if (e.key === &#039;ArrowUp&#039;) pacman.nextDirection = { x: 0, y: -1 };<br>            else if (e.key === &#039;ArrowDown&#039;) pacman.nextDirection = { x: 0, y: 1 };<br>            else if (e.key === &#039;ArrowLeft&#039;) pacman.nextDirection = { x: -1, y: 0 };<br>            else if (e.key === &#039;ArrowRight&#039;) pacman.nextDirection = { x: 1, y: 0 };<br>        });<br><br>        // Initialize and start the game<br>        init();<br>    });<br>    &lt;/script&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;</code></pre></div>
        </div>
    </div>
</body>
</html>