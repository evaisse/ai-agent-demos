{
  "timestamp": "2025-10-02T13:09:11.535Z",
  "execution": {
    "duration_seconds": "81.446",
    "model_used": "google/gemini-2.5-pro",
    "model_requested": "google/gemini-2.5-pro"
  },
  "tokens": {
    "prompt_tokens": 28,
    "completion_tokens": 7923,
    "total_tokens": 7951
  },
  "cost": {
    "currency": "USD",
    "prompt_cost": 0.000035,
    "completion_cost": 0.07923,
    "total_cost": 0.079265
  },
  "model_card": {
    "id": "google/gemini-2.5-pro",
    "name": "Google: Gemini 2.5 Pro",
    "description": "Gemini 2.5 Pro is Google’s state-of-the-art AI model designed for advanced reasoning, coding, mathematics, and scientific tasks. It employs “thinking” capabilities, enabling it to reason through responses with enhanced accuracy and nuanced context handling. Gemini 2.5 Pro achieves top-tier performance on multiple benchmarks, including first-place positioning on the LMArena leaderboard, reflecting superior human-preference alignment and complex problem-solving abilities.",
    "context_length": 1048576,
    "architecture": {
      "input_modalities": [
        "file",
        "image",
        "text",
        "audio"
      ],
      "instruct_type": null,
      "modality": "text+image->text",
      "output_modalities": [
        "text"
      ],
      "tokenizer": "Gemini"
    },
    "pricing": {
      "completion": "0.00001",
      "image": "0.00516",
      "input_cache_read": "0.00000031",
      "input_cache_write": "0.000001625",
      "internal_reasoning": "0",
      "prompt": "0.00000125",
      "request": "0",
      "web_search": "0"
    },
    "top_provider": {
      "context_length": 1048576,
      "is_moderated": false,
      "max_completion_tokens": 65536
    }
  },
  "request": {
    "prompt": "In a single HTML file named index.html, create exact copy of the PAC-MAN game in one html file using css and js.\n",
    "system_prompt": null,
    "temperature": 0.7,
    "max_tokens": 8000
  },
  "response_metadata": {
    "id": "gen-1759410370-kz7xfdrbGCcRu8lsbqqJ",
    "created": 1759410370,
    "object": "chat.completion"
  },
  "raw_response": "Of course. Creating a complete, pixel-perfect, and behaviorally-exact replica of the original PAC-MAN is a massive undertaking, especially concerning the complex and distinct AI for each ghost.\n\nHowever, I can create a very faithful and fully playable version that captures the look, feel, and core mechanics of the game, all within a single HTML file as requested. This version will include:\n\n*   A recognizable maze layout.\n*   Pac-Man movement and chomping animation.\n*   Dots and Power Pellets.\n*   Four ghosts with a simplified but effective chase AI.\n*   A \"frightened\" mode for ghosts after eating a Power Pellet.\n*   Score, lives, and game over/win conditions.\n\nHere is the complete code for `index.html`. Simply copy and paste this entire block of code into a file named `index.html` and open it in your web browser to play.\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>PAC-MAN</title>\n    <style>\n        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');\n\n        body {\n            background-color: #000;\n            color: #fff;\n            font-family: 'Press Start 2P', cursive;\n            text-align: center;\n            margin: 0;\n            padding: 0;\n            display: flex;\n            flex-direction: column;\n            align-items: center;\n            justify-content: center;\n            height: 100vh;\n        }\n\n        h1 {\n            color: #FFFF00;\n            text-shadow: 2px 2px 0 #FF0000;\n        }\n\n        #game-container {\n            position: relative;\n            border: 2px solid #1E90FF;\n            box-shadow: 0 0 20px #1E90FF;\n        }\n        \n        canvas {\n            background-color: #000;\n            display: block;\n        }\n\n        #game-info {\n            display: flex;\n            justify-content: space-between;\n            width: 560px; /* Same as canvas width */\n            padding: 10px 0;\n            font-size: 16px;\n        }\n\n        #score-label, #lives-label {\n            color: #fff;\n        }\n        \n        #score-value {\n            color: #FFFF00;\n        }\n\n        #lives-container {\n            display: flex;\n            align-items: center;\n        }\n\n        .life-pacman {\n            width: 20px;\n            height: 20px;\n            background: #FFFF00;\n            border-radius: 50%;\n            margin-left: 10px;\n            clip-path: polygon(0% 0%, 100% 0%, 100% 40%, 50% 50%, 100% 60%, 100% 100%, 0% 100%, 0% 60%, 50% 50%, 0% 40%);\n        }\n        \n        #message-overlay {\n            position: absolute;\n            top: 0;\n            left: 0;\n            width: 100%;\n            height: 100%;\n            background-color: rgba(0, 0, 0, 0.7);\n            color: #FFFF00;\n            font-size: 24px;\n            display: none; /* Initially hidden */\n            flex-direction: column;\n            align-items: center;\n            justify-content: center;\n            text-align: center;\n        }\n\n        #message-overlay p {\n            margin: 10px;\n        }\n\n        #message-overlay .subtext {\n            font-size: 16px;\n            color: #fff;\n        }\n\n    </style>\n</head>\n<body>\n    <h1>PAC-MAN</h1>\n    <div id=\"game-info\">\n        <div>\n            <span id=\"score-label\">SCORE: </span>\n            <span id=\"score-value\">0</span>\n        </div>\n        <div id=\"lives-container\">\n            <span id=\"lives-label\">LIVES:</span>\n            <!-- Lives will be dynamically added here -->\n        </div>\n    </div>\n    <div id=\"game-container\">\n        <canvas id=\"gameCanvas\"></canvas>\n        <div id=\"message-overlay\">\n            <p id=\"main-message\">GAME OVER</p>\n            <p id=\"sub-message\" class=\"subtext\">Press Enter to Restart</p>\n        </div>\n    </div>\n\n    <script>\n        document.addEventListener('DOMContentLoaded', () => {\n            const canvas = document.getElementById('gameCanvas');\n            const ctx = canvas.getContext('2d');\n            const scoreEl = document.getElementById('score-value');\n            const livesContainer = document.getElementById('lives-container');\n            const messageOverlay = document.getElementById('message-overlay');\n            const mainMessageEl = document.getElementById('main-message');\n            const subMessageEl = document.getElementById('sub-message');\n\n            const TILE_SIZE = 20;\n            const ROWS = 31;\n            const COLS = 28;\n\n            canvas.width = COLS * TILE_SIZE;\n            canvas.height = ROWS * TILE_SIZE;\n\n            // Map legend: 0 = Wall, 1 = Dot, 2 = Empty, 3 = Power Pellet, 4 = Ghost Lair\n            const map = [\n                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n                [0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0],\n                [0,1,0,0,1,1,0,0,0,1,1,0,1,0,0,1,0,1,1,0,0,0,1,1,0,0,1,0],\n                [0,3,0,0,1,1,0,0,0,1,1,0,1,0,0,1,0,1,1,0,0,0,1,1,0,0,3,0],\n                [0,1,0,0,1,1,0,0,0,1,1,0,1,0,0,1,0,1,1,0,0,0,1,1,0,0,1,0],\n                [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],\n                [0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,0,0,0,1,1,0,1,1,0,0,1,0],\n                [0,1,0,0,1,1,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,1,1,0,0,1,0],\n                [0,1,1,1,1,1,0,1,1,0,0,0,1,0,0,1,0,0,0,1,1,0,1,1,1,1,1,0],\n                [0,0,0,0,1,1,0,1,1,0,2,2,2,2,2,2,2,0,1,1,0,1,1,0,0,0,0,0],\n                [0,0,0,0,1,1,0,1,1,0,2,0,0,4,4,0,0,2,0,1,1,0,1,1,0,0,0,0],\n                [0,0,0,0,1,1,0,1,1,0,2,0,4,4,4,4,0,2,0,1,1,0,1,1,0,0,0,0],\n                [0,0,0,0,1,1,1,1,1,0,2,0,4,4,4,4,0,2,0,1,1,1,1,1,0,0,0,0],\n                [2,2,2,2,1,1,0,1,1,2,2,0,4,4,4,4,0,2,2,1,1,0,1,1,2,2,2,2],\n                [0,0,0,0,1,1,0,1,1,0,2,0,4,4,4,4,0,2,0,1,1,0,1,1,0,0,0,0],\n                [0,0,0,0,1,1,0,1,1,0,2,0,0,0,0,0,0,2,0,1,1,0,1,1,0,0,0,0],\n                [0,0,0,0,1,1,0,1,1,0,2,2,2,2,2,2,2,2,0,1,1,0,1,1,0,0,0,0],\n                [0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0],\n                [0,1,0,0,1,1,0,0,0,1,1,0,1,0,0,1,0,1,1,0,0,0,1,1,0,0,1,0],\n                [0,3,1,1,1,1,1,1,1,1,1,0,1,0,0,1,0,1,1,1,1,1,1,1,1,1,3,0],\n                [0,0,0,1,1,0,1,1,0,1,1,0,1,0,0,1,0,1,1,0,1,1,0,1,1,0,0,0],\n                [0,1,1,1,1,0,1,1,0,1,1,1,1,1,1,1,1,1,1,0,1,1,0,1,1,1,1,0],\n                [0,1,0,0,0,0,1,1,0,1,1,0,0,0,0,0,0,1,1,0,1,1,0,0,0,0,1,0],\n                [0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0],\n                [0,1,0,0,1,1,0,0,0,1,1,0,1,0,0,1,0,1,1,0,0,0,1,1,0,0,1,0],\n                [0,1,1,0,1,1,1,1,1,1,1,0,1,0,0,1,0,1,1,1,1,1,1,1,0,1,1,0],\n                [0,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,0,0,1,1,0,1,1,0,1,0,0,0],\n                [0,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0],\n                [0,1,0,0,0,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,0,0,0,1,0],\n                [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],\n                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\n            ];\n\n            let score = 0;\n            let lives = 3;\n            let dotCount = 0;\n            let gameState = 'start'; // 'start', 'playing', 'paused', 'dying', 'gameover', 'won'\n            let gameLoopId;\n\n            const pacman = {\n                x: 14 * TILE_SIZE,\n                y: 23 * TILE_SIZE,\n                dx: 0,\n                dy: 0,\n                speed: 2,\n                nextDirection: null,\n                mouthOpen: 0.2,\n                mouthOpening: true\n            };\n\n            const ghosts = [\n                { id: 'blinky', x: 14 * TILE_SIZE, y: 11 * TILE_SIZE, color: '#FF0000', dx: 0, dy: 0, state: 'chase', home: {x: 14 * TILE_SIZE, y: 11 * TILE_SIZE} },\n                { id: 'pinky', x: 14 * TILE_SIZE, y: 14 * TILE_SIZE, color: '#FFB8FF', dx: 0, dy: 0, state: 'chase', home: {x: 14 * TILE_SIZE, y: 14 * TILE_SIZE} },\n                { id: 'inky', x: 12 * TILE_SIZE, y: 14 * TILE_SIZE, color: '#00FFFF', dx: 0, dy: 0, state: 'chase', home: {x: 12 * TILE_SIZE, y: 14 * TILE_SIZE} },\n                { id: 'clyde', x: 16 * TILE_SIZE, y: 14 * TILE_SIZE, color: '#FFB852', dx: 0, dy: 0, state: 'chase', home: {x: 16 * TILE_SIZE, y: 14 * TILE_SIZE} }\n            ];\n            \n            let powerPelletTimer = 0;\n            const POWER_PELLET_DURATION = 8000; // 8 seconds\n\n            function isWall(x, y) {\n                const gridX = Math.floor(x / TILE_SIZE);\n                const gridY = Math.floor(y / TILE_SIZE);\n                if (gridX < 0 || gridX >= COLS || gridY < 0 || gridY >= ROWS) return true;\n                return map[gridY][gridX] === 0;\n            }\n\n            function isAtGridCenter(entity) {\n                return (entity.x % TILE_SIZE === 0) && (entity.y % TILE_SIZE === 0);\n            }\n\n            function drawWall(x, y) {\n                ctx.fillStyle = '#1E90FF'; // Blue walls\n                ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);\n            }\n\n            function drawDot(x, y) {\n                ctx.fillStyle = '#FFFFFF';\n                ctx.fillRect(x * TILE_SIZE + TILE_SIZE / 2 - 1, y * TILE_SIZE + TILE_SIZE / 2 - 1, 2, 2);\n            }\n\n            function drawPowerPellet(x, y) {\n                ctx.fillStyle = '#FFFFFF';\n                ctx.beginPath();\n                ctx.arc(x * TILE_SIZE + TILE_SIZE / 2, y * TILE_SIZE + TILE_SIZE / 2, TILE_SIZE / 3, 0, Math.PI * 2);\n                ctx.fill();\n            }\n\n            function drawMap() {\n                dotCount = 0;\n                for (let y = 0; y < ROWS; y++) {\n                    for (let x = 0; x < COLS; x++) {\n                        if (map[y][x] === 0) {\n                            drawWall(x, y);\n                        } else if (map[y][x] === 1) {\n                            drawDot(x, y);\n                            dotCount++;\n                        } else if (map[y][x] === 3) {\n                            drawPowerPellet(x, y);\n                            dotCount++;\n                        }\n                    }\n                }\n            }\n            \n            function drawPacman() {\n                // Animate mouth\n                if (pacman.mouthOpening) {\n                    pacman.mouthOpen += 0.05;\n                    if (pacman.mouthOpen >= 0.4) pacman.mouthOpening = false;\n                } else {\n                    pacman.mouthOpen -= 0.05;\n                    if (pacman.mouthOpen <= 0) pacman.mouthOpening = true;\n                }\n\n                let startAngle = pacman.mouthOpen * Math.PI;\n                let endAngle = (2 - pacman.mouthOpen) * Math.PI;\n                let rotation = 0;\n\n                if (pacman.dx > 0) rotation = 0; // Right\n                else if (pacman.dx < 0) rotation = Math.PI; // Left\n                else if (pacman.dy > 0) rotation = 0.5 * Math.PI; // Down\n                else if (pacman.dy < 0) rotation = 1.5 * Math.PI; // Up\n\n                ctx.save();\n                ctx.translate(pacman.x + TILE_SIZE / 2, pacman.y + TILE_SIZE / 2);\n                ctx.rotate(rotation);\n\n                ctx.fillStyle = '#FFFF00';\n                ctx.beginPath();\n                ctx.arc(0, 0, TILE_SIZE / 2 - 1, startAngle, endAngle);\n                ctx.lineTo(0, 0);\n                ctx.fill();\n                ctx.restore();\n            }\n\n            function drawGhost(ghost) {\n                const isFrightened = ghost.state === 'frightened';\n                const isEaten = ghost.state === 'eaten';\n                const bodyColor = isFrightened ? '#0000FF' : ghost.color;\n                \n                if (isEaten) {\n                    // Draw eyes only, returning to base\n                    ctx.fillStyle = '#FFFFFF';\n                    ctx.beginPath();\n                    ctx.arc(ghost.x + TILE_SIZE / 2 - 3, ghost.y + TILE_SIZE / 2, 2, 0, Math.PI * 2);\n                    ctx.arc(ghost.x + TILE_SIZE / 2 + 3, ghost.y + TILE_SIZE / 2, 2, 0, Math.PI * 2);\n                    ctx.fill();\n                } else {\n                    // Draw body\n                    ctx.fillStyle = bodyColor;\n                    ctx.beginPath();\n                    ctx.arc(ghost.x + TILE_SIZE / 2, ghost.y + TILE_SIZE / 2, TILE_SIZE / 2, Math.PI, 0);\n                    ctx.lineTo(ghost.x + TILE_SIZE, ghost.y + TILE_SIZE);\n                    ctx.lineTo(ghost.x, ghost.y + TILE_SIZE);\n                    ctx.fill();\n\n                    // Draw eyes\n                    ctx.fillStyle = '#FFFFFF';\n                    ctx.beginPath();\n                    ctx.arc(ghost.x + TILE_SIZE / 2 - 4, ghost.y + TILE_SIZE / 2 - 2, 3, 0, Math.PI * 2);\n                    ctx.arc(ghost.x + TILE_SIZE / 2 + 4, ghost.y + TILE_SIZE / 2 - 2, 3, 0, Math.PI * 2);\n                    ctx.fill();\n\n                    // Draw pupils\n                    ctx.fillStyle = '#000';\n                    ctx.beginPath();\n                    ctx.arc(ghost.x + TILE_SIZE / 2 - 4, ghost.y + TILE_SIZE / 2 - 2, 1, 0, Math.PI * 2);\n                    ctx.arc(ghost.x + TILE_SIZE / 2 + 4, ghost.y + TILE_SIZE / 2 - 2, 1, 0, Math.PI * 2);\n                    ctx.fill();\n                }\n            }\n\n            function updatePacman() {\n                // Tunnel logic\n                if (pacman.x < -TILE_SIZE) pacman.x = canvas.width - TILE_SIZE;\n                else if (pacman.x > canvas.width) pacman.x = 0;\n\n                const currentGridX = Math.floor(pacman.x / TILE_SIZE);\n                const currentGridY = Math.floor(pacman.y / TILE_SIZE);\n\n                // Handle direction change at grid intersection\n                if (isAtGridCenter(pacman)) {\n                    let newDx = 0, newDy = 0;\n                    if (pacman.nextDirection === 'up') newDy = -pacman.speed;\n                    else if (pacman.nextDirection === 'down') newDy = pacman.speed;\n                    else if (pacman.nextDirection === 'left') newDx = -pacman.speed;\n                    else if (pacman.nextDirection === 'right') newDx = pacman"
}