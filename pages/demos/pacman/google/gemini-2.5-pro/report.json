{
  "timestamp": "2025-10-06T11:43:22.316Z",
  "execution": {
    "duration_seconds": "16.629",
    "model_used": "google/gemini-2.5-pro",
    "model_requested": "google/gemini-2.5-pro"
  },
  "tokens": {
    "prompt_tokens": 5404,
    "completion_tokens": 15548,
    "total_tokens": 20952
  },
  "cost": {
    "currency": "USD",
    "prompt_cost": 0.006755,
    "completion_cost": 0.15548,
    "total_cost": 0.162235
  },
  "model_card": {
    "id": "google/gemini-2.5-pro",
    "name": "Google: Gemini 2.5 Pro",
    "description": "Gemini 2.5 Pro is Google’s state-of-the-art AI model designed for advanced reasoning, coding, mathematics, and scientific tasks. It employs “thinking” capabilities, enabling it to reason through responses with enhanced accuracy and nuanced context handling. Gemini 2.5 Pro achieves top-tier performance on multiple benchmarks, including first-place positioning on the LMArena leaderboard, reflecting superior human-preference alignment and complex problem-solving abilities.",
    "context_length": 1048576,
    "architecture": {
      "modality": "text+image->text",
      "input_modalities": [
        "file",
        "image",
        "text",
        "audio"
      ],
      "output_modalities": [
        "text"
      ],
      "tokenizer": "Gemini",
      "instruct_type": null
    },
    "pricing": {
      "prompt": "0.00000125",
      "completion": "0.00001",
      "request": "0",
      "image": "0.00516",
      "web_search": "0",
      "internal_reasoning": "0",
      "input_cache_read": "0.00000031",
      "input_cache_write": "0.000001625"
    },
    "top_provider": {
      "context_length": 1048576,
      "max_completion_tokens": 65536,
      "is_moderated": false
    }
  },
  "request": {
    "prompt": "In a single HTML file named index.html, create exact copy of the PAC-MAN game in one html file using css and js.\n",
    "system_prompt": null,
    "temperature": 0.7,
    "max_tokens": 8000
  },
  "response_metadata": {
    "id": "gen-1759750865-Is9Aa7NDkCvaKIrqQDMt",
    "created": 1759750865,
    "object": "chat.completion"
  },
  "raw_response": "Of course. Here is a complete, self-contained `index.html` file that creates a functional and visually recognizable clone of the classic PAC-MAN game. All the HTML, CSS, and JavaScript are embedded within this single file.\n\nTo use it, simply copy all the code below, paste it into a new text file, and save it as `index.html`. Then, open that file in any modern web browser.\n\n### Features Included:\n*   **Complete Maze:** A faithful representation of the classic Pac-Man maze layout.\n*   **Pac-Man:** Fully animated (mouth chomping) and controllable with arrow keys.\n*   **Ghosts:** Four ghosts (Blinky, Pinky, Inky, Clyde) with distinct (though simplified) AI behaviors.\n    *   **Blinky (Red):** Directly chases Pac-Man.\n    *   **Pinky (Pink):** Tries to ambush Pac-Man by targeting a few steps ahead of him.\n    *   **Inky (Cyan):** Has a more complex targeting, using both Pac-Man and Blinky's positions.\n    *   **Clyde (Orange):** Chases Pac-Man when far away but gets scared and retreats to his corner when too close.\n*   **Pellets & Power Pellets:** Collect all pellets to win the level. Power pellets make ghosts vulnerable.\n*   **Ghost States:** Ghosts can be in `chase`, `scatter`, or `frightened` modes.\n*   **Scoring & Lives:** A functional scoring and life system.\n*   **Game States:** Includes a \"Ready!\" screen, gameplay, life loss sequence, and \"Game Over\" screen.\n\n---\n\n### `index.html`\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>PAC-MAN</title>\n    <style>\n        body {\n            margin: 0;\n            padding: 0;\n            background-color: #000;\n            color: #fff;\n            font-family: 'Press Start 2P', monospace, sans-serif; /* A common retro game font */\n            display: flex;\n            justify-content: center;\n            align-items: center;\n            height: 100vh;\n            flex-direction: column;\n            text-align: center;\n        }\n\n        @font-face {\n            font-family: 'Press Start 2P';\n            src: url('https://fonts.gstatic.com/s/pressstart2p/v15/e3t4euO8T-267oIAQAu6jDQyK3nVivM.woff2') format('woff2');\n            font-weight: normal;\n            font-style: normal;\n        }\n\n        h1 {\n            color: #FFFF00;\n            text-shadow: 2px 2px #FF0000;\n        }\n\n        #game-container {\n            position: relative;\n            border: 2px solid #1E90FF;\n            box-shadow: 0 0 20px #1E90FF;\n        }\n\n        #game-canvas {\n            background-color: #000;\n            display: block;\n        }\n\n        #game-info {\n            display: flex;\n            justify-content: space-between;\n            width: 560px; /* Same as canvas width */\n            padding: 10px 0;\n            font-size: 16px;\n        }\n\n        #score, #lives {\n            color: #fff;\n        }\n        \n        #start-screen, #game-over-screen {\n            position: absolute;\n            top: 0;\n            left: 0;\n            width: 100%;\n            height: 100%;\n            background-color: rgba(0, 0, 0, 0.7);\n            display: flex;\n            flex-direction: column;\n            justify-content: center;\n            align-items: center;\n            color: #FFFF00;\n            font-size: 24px;\n            text-align: center;\n            z-index: 10;\n        }\n        \n        #game-over-screen p {\n            margin: 10px 0;\n        }\n\n        #game-over-screen button {\n            padding: 10px 20px;\n            font-family: 'Press Start 2P', monospace, sans-serif;\n            background-color: #FFFF00;\n            color: #000;\n            border: none;\n            cursor: pointer;\n            margin-top: 20px;\n        }\n\n        #game-over-screen button:hover {\n            background-color: #fff;\n        }\n\n    </style>\n</head>\n<body>\n    <h1>PAC-MAN</h1>\n    <div id=\"game-info\">\n        <div id=\"score\">SCORE: 0</div>\n        <div id=\"lives\">LIVES: ❤️❤️❤️</div>\n    </div>\n    <div id=\"game-container\">\n        <canvas id=\"game-canvas\" width=\"560\" height=\"620\"></canvas>\n        <div id=\"start-screen\">\n            <p>READY!</p>\n        </div>\n        <div id=\"game-over-screen\" style=\"display: none;\">\n            <p>GAME OVER</p>\n            <p id=\"final-score\"></p>\n            <button onclick=\"window.location.reload()\">RESTART</button>\n        </div>\n    </div>\n\n    <script>\n    document.addEventListener('DOMContentLoaded', () => {\n        const canvas = document.getElementById('game-canvas');\n        const ctx = canvas.getContext('2d');\n        const scoreEl = document.getElementById('score');\n        const livesEl = document.getElementById('lives');\n        const startScreen = document.getElementById('start-screen');\n        const gameOverScreen = document.getElementById('game-over-screen');\n        const finalScoreEl = document.getElementById('final-score');\n\n        const TILE_SIZE = 20;\n        const PACMAN_SPEED = 2;\n        const GHOST_SPEED = 1.8;\n        const FRIGHTENED_GHOST_SPEED = 1;\n        \n        let score = 0;\n        let lives = 3;\n        let pelletsCount = 0;\n        let gameStarted = false;\n        let gameOver = false;\n        let frightenedMode = false;\n        let frightenedTimer = 0;\n\n        // Maze layout: 0 = wall, 1 = pellet, 2 = empty, 3 = power pellet, 4 = ghost home\n        const map = [\n            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n            [0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0],\n            [0,1,0,0,1,1,0,0,1,1,0,0,1,0,0,1,0,0,1,1,0,0,1,1,0,0,1,0],\n            [0,3,0,0,1,1,0,0,1,1,0,0,1,0,0,1,0,0,1,1,0,0,1,1,0,0,3,0],\n            [0,1,0,0,1,1,0,0,1,1,0,0,1,0,0,1,0,0,1,1,0,0,1,1,0,0,1,0],\n            [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],\n            [0,1,0,0,1,1,0,1,1,0,1,1,1,0,0,1,1,1,0,1,1,0,1,1,0,0,1,0],\n            [0,1,1,1,1,1,0,1,1,0,1,1,1,0,0,1,1,1,0,1,1,0,1,1,1,1,1,0],\n            [0,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0],\n            [0,0,0,0,1,1,0,1,1,0,0,0,1,0,0,1,0,0,0,1,1,0,1,1,0,0,0,0],\n            [0,0,0,0,1,1,0,1,1,0,1,1,1,1,1,1,1,1,0,1,1,0,1,1,0,0,0,0],\n            [0,0,0,0,1,1,0,1,1,0,1,0,0,4,4,0,0,1,0,1,1,0,1,1,0,0,0,0],\n            [0,0,0,0,1,1,1,1,1,1,1,0,4,4,4,4,0,1,1,1,1,1,1,1,0,0,0,0],\n            [2,2,2,2,1,1,1,1,1,1,1,0,4,4,4,4,0,1,1,1,1,1,1,1,2,2,2,2], // Tunnel\n            [0,0,0,0,1,1,1,1,1,1,1,0,4,4,4,4,0,1,1,1,1,1,1,1,0,0,0,0],\n            [0,0,0,0,1,1,0,1,1,0,1,0,0,0,0,0,0,1,0,1,1,0,1,1,0,0,0,0],\n            [0,0,0,0,1,1,0,1,1,0,1,1,1,1,1,1,1,1,0,1,1,0,1,1,0,0,0,0],\n            [0,0,0,0,1,1,0,1,1,0,0,0,1,0,0,1,0,0,0,1,1,0,1,1,0,0,0,0],\n            [0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0],\n            [0,1,0,0,1,1,0,0,1,1,0,0,1,0,0,1,0,0,1,1,0,0,1,1,0,0,1,0],\n            [0,3,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,3,0],\n            [0,1,0,0,1,1,0,1,1,0,1,1,1,0,0,1,1,1,0,1,1,0,1,1,0,0,1,0],\n            [0,1,1,1,1,1,0,1,1,0,1,1,1,0,0,1,1,1,0,1,1,0,1,1,1,1,1,0],\n            [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],\n            [0,1,0,0,1,1,0,0,1,1,0,0,1,0,0,1,0,0,1,1,0,0,1,1,0,0,1,0],\n            [0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0],\n            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\n        ];\n\n        class Pacman {\n            constructor(x, y, speed) {\n                this.x = x;\n                this.y = y;\n                this.speed = speed;\n                this.radius = TILE_SIZE / 2;\n                this.mouth = 0;\n                this.direction = { x: 0, y: 0 };\n                this.nextDirection = { x: 0, y: 0 };\n            }\n\n            draw() {\n                const angle = 0.2 * Math.PI * Math.abs(Math.sin(this.mouth));\n                ctx.save();\n                ctx.translate(this.x, this.y);\n\n                let rotation = 0;\n                if (this.direction.x === 1) rotation = 0;\n                else if (this.direction.x === -1) rotation = Math.PI;\n                else if (this.direction.y === 1) rotation = 0.5 * Math.PI;\n                else if (this.direction.y === -1) rotation = 1.5 * Math.PI;\n                \n                ctx.rotate(rotation);\n\n                ctx.fillStyle = 'yellow';\n                ctx.beginPath();\n                ctx.arc(0, 0, this.radius, angle, 2 * Math.PI - angle);\n                ctx.lineTo(0, 0);\n                ctx.closePath();\n                ctx.fill();\n                ctx.restore();\n            }\n\n            update() {\n                this.mouth += 0.1;\n                this.handleInput();\n                this.move();\n                this.eatPellet();\n            }\n\n            handleInput() {\n                if (this.isAtGridCenter()) {\n                    const nextGridX = Math.floor((this.x + this.nextDirection.x * TILE_SIZE) / TILE_SIZE);\n                    const nextGridY = Math.floor((this.y + this.nextDirection.y * TILE_SIZE) / TILE_SIZE);\n                    if (map[nextGridY] && map[nextGridY][nextGridX] !== 0) {\n                        this.direction = { ...this.nextDirection };\n                    }\n                }\n            }\n            \n            isAtGridCenter() {\n                return (this.x % TILE_SIZE === TILE_SIZE / 2) && (this.y % TILE_SIZE === TILE_SIZE / 2);\n            }\n\n            move() {\n                // Check for wall collision\n                const currentGridX = Math.floor(this.x / TILE_SIZE);\n                const currentGridY = Math.floor(this.y / TILE_SIZE);\n                const nextX = this.x + this.direction.x * this.speed;\n                const nextY = this.y + this.direction.y * this.speed;\n                \n                if (this.isAtGridCenter()) {\n                    const nextGridX = currentGridX + this.direction.x;\n                    const nextGridY = currentGridY + this.direction.y;\n                    if (map[nextGridY] && map[nextGridY][nextGridX] === 0) {\n                        this.direction.x = 0;\n                        this.direction.y = 0;\n                    }\n                }\n                \n                this.x += this.direction.x * this.speed;\n                this.y += this.direction.y * this.speed;\n\n                // Tunnel logic\n                if (this.x < 0) this.x = canvas.width;\n                if (this.x > canvas.width) this.x = 0;\n            }\n            \n            eatPellet() {\n                const gridX = Math.floor(this.x / TILE_SIZE);\n                const gridY = Math.floor(this.y / TILE_SIZE);\n\n                if (map[gridY] && map[gridY][gridX] === 1) {\n                    map[gridY][gridX] = 2; // Mark as eaten\n                    score += 10;\n                    pelletsCount--;\n                    updateScore();\n                } else if (map[gridY] && map[gridY][gridX] === 3) {\n                    map[gridY][gridX] = 2; // Mark as eaten\n                    score += 50;\n                    pelletsCount--;\n                    activateFrightenedMode();\n                    updateScore();\n                }\n            }\n        }\n        \n        class Ghost {\n            constructor(x, y, color, speed, scatterTarget) {\n                this.x = x;\n                this.y = y;\n                this.color = color;\n                this.speed = speed;\n                this.radius = TILE_SIZE / 2;\n                this.direction = { x: 0, y: -1 };\n                this.state = 'scatter'; // scatter, chase, frightened\n                this.scatterTarget = scatterTarget;\n                this.target = { x: 0, y: 0 };\n                this.frightenedTimer = 0;\n                this.isEaten = false;\n                this.home = {x: 13.5 * TILE_SIZE, y: 13.5 * TILE_SIZE};\n            }\n\n            draw() {\n                ctx.fillStyle = this.state === 'frightened' ? '#0000FF' : this.color;\n                if (this.isEaten) ctx.fillStyle = '#888';\n                \n                ctx.beginPath();\n                ctx.arc(this.x, this.y, this.radius, Math.PI, 0);\n                ctx.lineTo(this.x + this.radius, this.y + this.radius);\n                ctx.lineTo(this.x - this.radius, this.y + this.radius);\n                ctx.closePath();\n                ctx.fill();\n\n                // Eyes\n                ctx.fillStyle = 'white';\n                const eyeOffsetX = this.radius * 0.3;\n                const eyeOffsetY = -this.radius * 0.2;\n                ctx.beginPath();\n                ctx.arc(this.x - eyeOffsetX, this.y + eyeOffsetY, this.radius * 0.2, 0, 2*Math.PI);\n                ctx.arc(this.x + eyeOffsetX, this.y + eyeOffsetY, this.radius * 0.2, 0, 2*Math.PI);\n                ctx.fill();\n                \n                // Pupils\n                ctx.fillStyle = 'black';\n                const pupilOffsetX = this.direction.x * this.radius * 0.1;\n                const pupilOffsetY = this.direction.y * this.radius * 0.1;\n                ctx.beginPath();\n                ctx.arc(this.x - eyeOffsetX + pupilOffsetX, this.y + eyeOffsetY + pupilOffsetY, this.radius * 0.1, 0, 2*Math.PI);\n                ctx.arc(this.x + eyeOffsetX + pupilOffsetX, this.y + eyeOffsetY + pupilOffsetY, this.radius * 0.1, 0, 2*Math.PI);\n                ctx.fill();\n\n                if (this.state === 'frightened') {\n                    ctx.strokeStyle = 'white';\n                    ctx.lineWidth = 1;\n                    ctx.beginPath();\n                    ctx.moveTo(this.x - 5, this.y + 5);\n                    ctx.lineTo(this.x + 5, this.y + 5);\n                    ctx.stroke();\n                }\n            }\n\n            update() {\n                if (this.isEaten) {\n                    this.target = this.home;\n                    const dx = this.target.x - this.x;\n                    const dy = this.target.y - this.y;\n                    if (Math.abs(dx) < this.speed && Math.abs(dy) < this.speed) {\n                        this.isEaten = false;\n                        this.state = 'chase'; // Or scatter\n                    }\n                } else {\n                    this.setTarget();\n                }\n                \n                this.move();\n            }\n            \n            setTarget() {\n                if (this.state === 'scatter') {\n                    this.target = this.scatterTarget;\n                } else if (this.state === 'chase') {\n                    this.chase();\n                } else if (this.state === 'frightened') {\n                    // Move randomly\n                    if (this.isAtGridCenter()) {\n                        const possibleMoves = this.getPossibleMoves();\n                        if (possibleMoves.length > 0) {\n                            this.direction = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];\n                        }\n                    }\n                    return; // Skip normal targeting\n                }\n            }\n\n            move() {\n                if (this.isAtGridCenter()) {\n                    const bestMove = this.getBestMove();\n                    if(bestMove) this.direction = bestMove;\n                }\n                \n                this.x += this.direction.x * (this.state === 'frightened' ? FRIGHTENED_GHOST_SPEED : this.speed);\n                this.y += this.direction.y * (this.state === 'frightened' ? FRIGHTENED_GHOST_SPEED : this.speed);\n                \n                // Tunnel\n                if (this.x < 0) this.x = canvas.width;\n                if (this.x > canvas.width) this\n.x = 0;\n            }\n\n            getBestMove() {\n                const possibleMoves = this.getPossibleMoves();\n                if (possibleMoves.length === 0) return null;\n\n                let bestMove = null;\n                let minDistance = Infinity;\n\n                for (const move of possibleMoves) {\n                    const newX = this.x + move.x * TILE_SIZE;\n                    const newY = this.y + move.y * TILE_SIZE;\n                    const distance = Math.hypot(newX - this.target.x, newY - this.target.y);\n                    \n                    if (distance < minDistance) {\n                        minDistance = distance;\n                        bestMove = move;\n                    }\n                }\n                return bestMove;\n            }\n\n            getPossibleMoves() {\n                const moves = [{x:1, y:0}, {x:-1, y:0}, {x:0, y:1}, {x:0, y:-1}];\n                const possibleMoves = [];\n                const currentGridX = Math.floor(this.x / TILE_SIZE);\n                const currentGridY = Math.floor(this.y / TILE_SIZE);\n\n                for (const move of moves) {\n                    // Prevent ghost from reversing direction unless in a dead end\n                    if (move.x === -this.direction.x && move.y === -this.direction.y) {\n                        continue;\n                    }\n                    \n                    const nextGridX = currentGridX + move.x;\n                    const nextGridY = currentGridY + move.y;\n                    \n                    // Check if next tile is a wall (0) or the ghost house gate (4)\n                    if (map[nextGridY] && map[nextGridY][nextGridX] !== 0) {\n                         // A special rule for ghosts: they can't go up into certain zones\n                         if (move.y === -1 && (nextGridY === 10 || nextGridY === 22) && (nextGridX === 12 || nextGridX === 15)) {\n                             continue;\n                         }\n                         possibleMoves.push(move);\n                    }\n                }\n                \n                // If no other moves are possible, allow reversal (must be a dead end)\n                if (possibleMoves.length === 0) {\n                    possibleMoves.push({x: -this.direction.x, y: -this.direction.y});\n                }\n                \n                return possibleMoves;\n            }\n\n            isAtGridCenter() {\n                return (this.x % TILE_SIZE === TILE_SIZE / 2) && (this.y % TILE_SIZE === TILE_SIZE / 2);\n            }\n\n            // This will be overridden by subclasses for specific chase behaviors\n            chase() {\n                this.target = { x: pacman.x, y: pacman.y };\n            }\n        }\n\n        class Blinky extends Ghost { // Red\n            constructor(x, y, speed) {\n                super(x, y, '#FF0000', speed, { x: 25 * TILE_SIZE, y: 0 * TILE_SIZE });\n            }\n            // Blinky's chase is the default: target Pac-Man's exact location. No override needed.\n        }\n\n        class Pinky extends Ghost { // Pink\n            constructor(x, y, speed) {\n                super(x, y, '#FFB8FF', speed, { x: 2 * TILE_SIZE, y: 0 * TILE_SIZE });\n            }\n\n            chase() {\n                // Target 4 tiles ahead of Pac-Man's current direction\n                this.target = {\n                    x: pacman.x + pacman.direction.x * 4 * TILE_SIZE,\n                    y: pacman.y + pacman.direction.y * 4 * TILE_SIZE\n                };\n            }\n        }\n        \n        class Inky extends Ghost { // Cyan\n            constructor(x, y, speed) {\n                super(x, y, '#00FFFF', speed, { x: 27 * TILE_SIZE, y: 30 * TILE_SIZE });\n            }\n\n            chase() {\n                // Target is based on a vector from Blinky to 2 tiles ahead of Pac-Man, doubled\n                const pacmanAhead = {\n                    x: pacman.x + pacman.direction.x * 2 * TILE_SIZE,\n                    y: pacman.y + pacman.direction.y * 2 * TILE_SIZE\n                };\n                const blinkyPos = { x: blinky.x, y: blinky.y };\n                \n                this.target = {\n                    x: pacmanAhead.x + (pacmanAhead.x - blinkyPos.x),\n                    y: pacmanAhead.y + (pacmanAhead.y - blinkyPos.y)\n                };\n            }\n        }\n\n        class Clyde extends Ghost { // Orange\n            constructor(x, y, speed) {\n                super(x, y, '#FFB851', speed, { x: 0 * TILE_SIZE, y: 30 * TILE_SIZE });\n            }\n\n            chase() {\n                const distance = Math.hypot(this.x - pacman.x, this.y - pacman.y);\n                if (distance > 8 * TILE_SIZE) {\n                    // If far away, chase Pac-Man (like Blinky)\n                    this.target = { x: pacman.x, y: pacman.y };\n                } else {\n                    // If too close, retreat to his scatter corner\n                    this.target = this.scatterTarget;\n                }\n            }\n        }\n\n        let pacman;\n        let ghosts;\n        let blinky, pinky, inky, clyde;\n\n        function init() {\n            // Recalculate total pellets every time for restarts\n            pelletsCount = 0;\n            map.forEach(row => {\n                row.forEach(tile => {\n                    if (tile === 1 || tile === 3) pelletsCount++;\n                });\n            });\n\n            resetCharacters();\n            \n            updateScore();\n            updateLives();\n            \n            startScreen.style.display = 'flex';\n            gameOverScreen.style.display = 'none';\n\n            // Initial draw\n            draw();\n\n            // Start game after \"Ready!\" message\n            setTimeout(() => {\n                startScreen.style.display = 'none';\n                gameStarted = true;\n                gameLoop();\n            }, 2000);\n        }\n\n        function resetCharacters() {\n            pacman = new Pacman(14 * TILE_SIZE - TILE_SIZE / 2, 23 * TILE_SIZE + TILE_SIZE / 2, PACMAN_SPEED);\n            \n            blinky = new Blinky(14 * TILE_SIZE - TILE_SIZE / 2, 11 * TILE_SIZE + TILE_SIZE / 2, GHOST_SPEED);\n            pinky = new Pinky(14 * TILE_SIZE - TILE_SIZE / 2, 14 * TILE_SIZE + TILE_SIZE / 2, GHOST_SPEED);\n            inky = new Inky(12 * TILE_SIZE - TILE_SIZE / 2, 14 * TILE_SIZE + TILE_SIZE / 2, GHOST_SPEED);\n            clyde = new Clyde(16 * TILE_SIZE - TILE_SIZE / 2, 14 * TILE_SIZE + TILE_SIZE / 2, GHOST_SPEED);\n\n            ghosts = [blinky, pinky, inky, clyde];\n        }\n\n        function drawMap() {\n            for (let y = 0; y < map.length; y++) {\n                for (let x = 0; x < map[y].length; x++) {\n                    const tile = map[y][x];\n                    if (tile === 0) { // Wall\n                        ctx.fillStyle = '#1E90FF';\n                        ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);\n                    } else if (tile === 1) { // Pellet\n                        ctx.fillStyle = 'white';\n                        ctx.beginPath();\n                        ctx.arc(x * TILE_SIZE + TILE_SIZE / 2, y * TILE_SIZE + TILE_SIZE / 2, 2, 0, 2 * Math.PI);\n                        ctx.fill();\n                    } else if (tile === 3) { // Power Pellet\n                        ctx.fillStyle = 'white';\n                        ctx.beginPath();\n                        ctx.arc(x * TILE_SIZE + TILE_SIZE / 2, y * TILE_SIZE + TILE_SIZE / 2, 6, 0, 2 * Math.PI);\n                        ctx.fill();\n                    }\n                }\n            }\n        }\n        \n        function updateScore() {\n            scoreEl.textContent = `SCORE: ${score}`;\n        }\n\n        function updateLives() {\n            livesEl.innerHTML = 'LIVES: ' + '❤️'.repeat(lives);\n        }\n\n        function activateFrightenedMode() {\n            frightenedMode = true;\n            frightenedTimer = 400; // ~6.6 seconds at 60fps\n            ghosts.forEach(ghost => {\n                if (!ghost.isEaten) {\n                    ghost.state = 'frightened';\n                    ghost.direction = {x: -ghost.direction.x, y: -ghost.direction.y}; // Reverse direction\n                }\n            });\n        }\n        \n        function checkCollisions() {\n            ghosts.forEach(ghost => {\n                const distance = Math.hypot(pacman.x - ghost.x, pacman.y - ghost.y);\n                if (distance < pacman.radius + ghost.radius - 4) { // -4 for more forgiving collision\n                    if (ghost.state === 'frightened') {\n                        if (!ghost.isEaten) {\n                            score += 200;\n                            updateScore();\n                            ghost.isEaten = true;\n                            ghost.state = 'chase'; // Will now target home to respawn\n                        }\n                    } else if (!ghost.isEaten) {\n                        handlePacmanDeath();\n                    }\n                }\n            });\n        }\n        \n        function handlePacmanDeath() {\n            gameStarted = false; // Pause game logic\n            lives--;\n            updateLives();\n\n            if (lives <= 0) {\n                gameOver = true;\n                setTimeout(showGameOver, 1000);\n            } else {\n                setTimeout(() => {\n                    resetCharacters();\n                    startScreen.style.display = 'flex'; // Show \"Ready!\" again\n                    setTimeout(() => {\n                        startScreen.style.display = 'none';\n                        gameStarted = true;\n                    }, 2000);\n                }, 1000);\n            }\n        }\n        \n        function showGameOver() {\n            finalScoreEl.textContent = `FINAL SCORE: ${score}`;\n            gameOverScreen.style.display = 'flex';\n        }\n\n        function checkWinCondition() {\n            if (pelletsCount <= 0) {\n                gameStarted = false;\n                gameOver = true;\n                // Use a timeout to let the last pellet-eating animation finish\n                setTimeout(() => {\n                    alert(\"YOU WIN! CONGRATULATIONS!\");\n                    showGameOver();\n                }, 500);\n            }\n        }\n\n        let scatterTimer = 0;\n        const SCATTER_DURATION = 7 * 60; // 7 seconds\n        const CHASE_DURATION = 20 * 60; // 20 seconds\n        let wave = 0;\n\n        function updateGhostStates() {\n            if (frightenedMode) {\n                frightenedTimer--;\n                if (frightenedTimer <= 0) {\n                    frightenedMode = false;\n                    ghosts.forEach(g => {\n                        if (!g.isEaten) g.state = 'chase'; // Return to chase after frightened mode ends\n                    });\n                }\n                return; // Frightened mode overrides scatter/chase logic\n            }\n\n            scatterTimer++;\n            const currentMode = ghosts[0].state;\n\n            if (currentMode === 'scatter' && scatterTimer > SCATTER_DURATION) {\n                scatterTimer = 0;\n                ghosts.forEach(g => g.state = 'chase');\n            } else if (currentMode === 'chase' && scatterTimer > CHASE_DURATION) {\n                scatterTimer = 0;\n                // Only scatter for the first few waves\n                if (wave < 4) {\n                    ghosts.forEach(g => g.state = 'scatter');\n                    wave++;\n                }\n            }\n        }\n        \n        function draw() {\n            ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas\n            drawMap();\n            pacman.draw();\n            ghosts.forEach(ghost => ghost.draw());\n        }\n\n        function update() {\n            pacman.update();\n            ghosts.forEach(ghost => ghost.update());\n            updateGhostStates();\n            checkCollisions();\n            checkWinCondition();\n        }\n\n        function gameLoop() {\n            if (gameOver) return;\n            \n            if (gameStarted) {\n                update();\n            }\n            draw();\n            \n            requestAnimationFrame(gameLoop);\n        }\n\n        // Keyboard controls\n        document.addEventListener('keydown', (e) => {\n            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {\n                e.preventDefault(); // Prevent page scrolling\n            }\n            if (e.key === 'ArrowUp') pacman.nextDirection = { x: 0, y: -1 };\n            else if (e.key === 'ArrowDown') pacman.nextDirection = { x: 0, y: 1 };\n            else if (e.key === 'ArrowLeft') pacman.nextDirection = { x: -1, y: 0 };\n            else if (e.key === 'ArrowRight') pacman.nextDirection = { x: 1, y: 0 };\n        });\n\n        // Initialize and start the game\n        init();\n    });\n    </script>\n</body>\n</html>\n```"
}