<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simplified Pac-Man</title>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: #333;
            font-family: 'Press Start 2P', cursive; /* A retro font if available */
            color: white;
            flex-direction: column;
        }

        #gameCanvas {
            background-color: black;
            border: 2px solid #555;
            display: block;
        }

        #score {
            margin-top: 10px;
            font-size: 1.5em;
        }

        /* Optional: Link to a retro Google Font */
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
    </style>
</head>
<body>
    <h1>Simplified Pac-Man</h1>
    <div id="score">Score: 0</div>
    <canvas id="gameCanvas" width="400" height="400"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        const TILE_SIZE = 20; // Size of each cell in the maze
        const MAZE_WIDTH = canvas.width / TILE_SIZE;
        const MAZE_HEIGHT = canvas.height / TILE_SIZE;

        let score = 0;
        const scoreDisplay = document.getElementById('score');

        // Maze layout (1 = wall, 0 = path, 2 = pellet)
        // This is a very simple maze for demonstration
        const maze = [
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
            [1, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1],
            [1, 2, 1, 1, 2, 1, 1, 1, 2, 1, 2, 1, 1, 1, 2, 1, 1, 1, 2, 1],
            [1, 2, 1, 1, 2, 1, 1, 1, 2, 1, 2, 1, 1, 1, 2, 1, 1, 1, 2, 1],
            [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1],
            [1, 2, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 2, 1],
            [1, 2, 2, 2, 2, 1, 2, 2, 2, 1, 2, 2, 2, 1, 2, 2, 2, 2, 2, 1],
            [1, 1, 1, 1, 2, 1, 1, 1, 2, 1, 2, 1, 1, 1, 2, 1, 1, 1, 1, 1],
            [1, 1, 1, 1, 2, 1, 2, 2, 2, 2, 2, 2, 2, 1, 2, 1, 1, 1, 1, 1],
            [1, 1, 1, 1, 2, 1, 2, 1, 1, 0, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1], // Ghost starts at 0, Pac-Man starts here too
            [1, 1, 1, 1, 2, 1, 2, 2, 2, 2, 2, 2, 2, 1, 2, 1, 1, 1, 1, 1],
            [1, 1, 1, 1, 2, 1, 1, 1, 2, 1, 2, 1, 1, 1, 2, 1, 1, 1, 1, 1],
            [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1],
            [1, 2, 1, 1, 2, 1, 1, 1, 2, 1, 2, 1, 1, 1, 2, 1, 1, 1, 2, 1],
            [1, 2, 1, 1, 2, 1, 1, 1, 2, 1, 2, 1, 1, 1, 2, 1, 1, 1, 2, 1],
            [1, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1],
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
        ];

        // Find Pac-Man's initial position (where '0' is in the maze)
        let pacman = { x: 0, y: 0, dx: 0, dy: 0, radius: TILE_SIZE / 2 - 2 };
        for (let r = 0; r < MAZE_HEIGHT; r++) {
            for (let c = 0; c < MAZE_WIDTH; c++) {
                if (maze[r][c] === 0) {
                    pacman.x = c * TILE_SIZE + TILE_SIZE / 2;
                    pacman.y = r * TILE_SIZE + TILE_SIZE / 2;
                    maze[r][c] = 2; // Treat initial '0' as a path with a pellet
                    break;
                }
            }
            if (pacman.x !== 0 || pacman.y !== 0) break;
        }

        // Simple ghost
        let ghost = { x: pacman.x, y: pacman.y - TILE_SIZE * 2, dx: 0, dy: 0, speed: 1, radius: TILE_SIZE / 2 - 2 };
        let ghostDirection = 'right'; // Simple AI: just moves in one direction until it hits a wall

        function drawMaze() {
            for (let r = 0; r < MAZE_HEIGHT; r++) {
                for (let c = 0; c < MAZE_WIDTH; c++) {
                    const x = c * TILE_SIZE;
                    const y = r * TILE_SIZE;

                    if (maze[r][c] === 1) { // Wall
                        ctx.fillStyle = 'blue';
                        ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
                    } else if (maze[r][c] === 2) { // Pellet
                        ctx.fillStyle = 'white';
                        ctx.beginPath();
                        ctx.arc(x + TILE_SIZE / 2, y + TILE_SIZE / 2, TILE_SIZE / 8, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }
        }

        function drawPacman() {
            ctx.fillStyle = 'yellow';
            ctx.beginPath();
            // Simple static Pac-Man, no mouth animation
            ctx.arc(pacman.x, pacman.y, pacman.radius, 0.75 * Math.PI, 1.25 * Math.PI, true);
            ctx.lineTo(pacman.x, pacman.y);
            ctx.closePath();
            ctx.fill();
        }

        function drawGhost() {
            ctx.fillStyle = 'red';
            ctx.fillRect(ghost.x - ghost.radius, ghost.y - ghost.radius, TILE_SIZE - 4, TILE_SIZE - 4);
            ctx.fillStyle = 'white'; // Eyes
            ctx.beginPath();
            ctx.arc(ghost.x - ghost.radius / 2, ghost.y - ghost.radius / 2, 2, 0, Math.PI * 2);
            ctx.arc(ghost.x + ghost.radius / 2, ghost.y - ghost.radius / 2, 2, 0, Math.PI * 2);
            ctx.fill();
        }

        function checkCollision(obj, targetX, targetY) {
            const currentTileX = Math.floor((obj.x - obj.radius) / TILE_SIZE);
            const currentTileY = Math.floor((obj.y - obj.radius) / TILE_SIZE);

            const nextTileX = Math.floor((targetX - obj.radius) / TILE_SIZE);
            const nextTileY = Math.floor((targetY - obj.radius) / TILE_SIZE);

            // Check all 4 corners of the object's bounding box
            const corners = [
                { x: targetX - obj.radius, y: targetY - obj.radius }, // Top-left
                { x: targetX + obj.radius, y: targetY - obj.radius }, // Top-right
                { x: targetX - obj.radius, y: targetY + obj.radius }, // Bottom-left
                { x: targetX + obj.radius, y: targetY + obj.radius }  // Bottom-right
            ];

            for (const corner of corners) {
                const tileCol = Math.floor(corner.x / TILE_SIZE);
                const tileRow = Math.floor(corner.y / TILE_SIZE);

                if (tileCol < 0 || tileCol >= MAZE_WIDTH || tileRow < 0 || tileRow >= MAZE_HEIGHT) {
                    return true; // Out of bounds is a wall
                }
                if (maze[tileRow][tileCol] === 1) {
                    return true; // Collision with a wall
                }
            }
            return false;
        }

        function updatePacman() {
            let nextX = pacman.x + pacman.dx;
            let nextY = pacman.y + pacman.dy;

            if (!checkCollision(pacman, nextX, nextY)) {
                pacman.x = nextX;
                pacman.y = nextY;
            } else {
                // If collision, try to align to tile center to prevent sticking
                const currentTileCol = Math.floor(pacman.x / TILE_SIZE);
                const currentTileRow = Math.floor(pacman.y / TILE_SIZE);
                const centerOfTileX = currentTileCol * TILE_SIZE + TILE_SIZE / 2;
                const centerOfTileY = currentTileRow * TILE_SIZE + TILE_SIZE / 2;

                if (pacman.dx !== 0) { // Moving horizontally
                    if (Math.abs(pacman.y - centerOfTileY) > 2) { // If not centered vertically, allow centering
                        if (pacman.y < centerOfTileY) pacman.y = Math.min(pacman.y + 2, centerOfTileY);
                        else pacman.y = Math.max(pacman.y - 2, centerOfTileY);
                    } else {
                        pacman.y = centerOfTileY;
                    }
                } else if (pacman.dy !== 0) { // Moving vertically
                    if (Math.abs(pacman.x - centerOfTileX) > 2) { // If not centered horizontally, allow centering
                        if (pacman.x < centerOfTileX) pacman.x = Math.min(pacman.x + 2, centerOfTileX);
                        else pacman.x = Math.max(pacman.x - 2, centerOfTileX);
                    } else {
                        pacman.x = centerOfTileX;
                    }
                }
            }

            // Pellet eating
            const tileCol = Math.floor(pacman.x / TILE_SIZE);
            const tileRow = Math.floor(pacman.y / TILE_SIZE);
            if (maze[tileRow] && maze[tileRow][tileCol] === 2) {
                maze[tileRow][tileCol] = 0; // Remove pellet
                score += 10;
                scoreDisplay.textContent = `Score: ${score}`;
            }
        }

        function updateGhost() {
            let nextX = ghost.x;
            let nextY = ghost.y;

            // Simple "AI": move in current direction until wall, then change randomly
            const currentTileCol = Math.floor(ghost.x / TILE_SIZE);
            const currentTileRow = Math.floor(ghost.y / TILE_SIZE);

            if (ghostDirection === 'right') nextX += ghost.speed;
            else if (ghostDirection === 'left') nextX -= ghost.speed;
            else if (ghostDirection === 'up') nextY -= ghost.speed;
            else if (ghostDirection === 'down') nextY += ghost.speed;

            if (checkCollision(ghost, nextX, nextY)) {
                // Hit a wall, change direction
                const directions = ['up', 'down', 'left', 'right'];
                let newDirection;
                do {
                    newDirection = directions[Math.floor(Math.random() * directions.length)];
                } while (newDirection === ghostDirection); // Don't pick the same direction again immediately
                ghostDirection = newDirection;
                ghost.dx = 0;
                ghost.dy = 0;
                if (ghostDirection === 'right') ghost.dx = ghost.speed;
                else if (ghostDirection === 'left') ghost.dx = -ghost.speed;
                else if (ghostDirection === 'up') ghost.dy = -ghost.speed;
                else if (ghostDirection === 'down') ghost.dy = ghost.speed;

                // Try to align to center of tile
                ghost.x = currentTileCol * TILE_SIZE + TILE_SIZE / 2;
                ghost.y = currentTileRow * TILE_SIZE + TILE_SIZE / 2;

            } else {
                ghost.x = nextX;
                ghost.y = nextY;
            }

            // Check for collision with Pac-Man
            const dx = pacman.x - ghost.x;
            const dy = pacman.y - ghost.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            if (distance < pacman.radius + ghost.radius) {
                alert('Game Over! You were caught by the ghost.');
                document.location.reload(); // Restart game for simplicity
            }
        }

        function gameLoop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas
            drawMaze();
            updatePacman();
            drawPacman();
            updateGhost();
            drawGhost();

            requestAnimationFrame(gameLoop); // Loop
        }

        // Keyboard input handling
        document.addEventListener('keydown', e => {
            const speed = 2; // Pac-Man speed
            switch (e.key) {
                case 'ArrowUp':
                case 'w':
                    pacman.dy = -speed;
                    pacman.dx = 0;
                    break;
                case 'ArrowDown':
                case 's':
                    pacman.dy = speed;
                    pacman.dx = 0;
                    break;
                case 'ArrowLeft':
                case 'a':
                    pacman.dx = -speed;
                    pacman.dy = 0;
                    break;
                case 'ArrowRight':
                case 'd':
                    pacman.dx = speed;
                    pacman.dy = 0;
                    break;
            }
        });

        // Start the game
        gameLoop();
    </script>
</body>
</html>