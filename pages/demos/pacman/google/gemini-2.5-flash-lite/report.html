<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OpenRouter API Response</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            max-width: 900px;
            margin: 0 auto;
            padding: 2rem;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        .container {
            background: white;
            border-radius: 16px;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            padding: 2rem;
        }
        h1 {
            color: #1a202c;
            margin-bottom: 1.5rem;
            font-size: 2rem;
        }
        .metadata {
            background: #f7fafc;
            border-left: 4px solid #667eea;
            padding: 1rem;
            margin-bottom: 2rem;
            border-radius: 4px;
        }
        .metadata p {
            margin: 0.5rem 0;
            color: #4a5568;
        }
        .metadata strong {
            color: #2d3748;
        }
        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 1rem;
            margin-bottom: 2rem;
        }
        .metric-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 1rem;
            border-radius: 8px;
            text-align: center;
        }
        .metric-value {
            font-size: 1.5rem;
            font-weight: bold;
        }
        .metric-label {
            font-size: 0.875rem;
            opacity: 0.9;
        }
        .prompt-section, .response-section {
            margin-bottom: 2rem;
        }
        .section-title {
            font-size: 1.25rem;
            font-weight: 600;
            color: #2d3748;
            margin-bottom: 1rem;
        }
        .content-box {
            background: #f9fafb;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 1.5rem;
            white-space: pre-wrap;
            word-wrap: break-word;
            color: #2d3748;
            line-height: 1.6;
        }
        .response-content {
            background: white;
            border: 2px solid #667eea;
        }
        code {
            background: #edf2f7;
            padding: 0.2rem 0.4rem;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
        }
        pre {
            background: #2d3748;
            color: #e2e8f0;
            padding: 1rem;
            border-radius: 8px;
            overflow-x: auto;
        }
        pre code {
            background: transparent;
            padding: 0;
            color: inherit;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ü§ñ OpenRouter API Response</h1>
        
        <div class="metadata">
            <p><strong>Model:</strong> google/gemini-2.5-flash-lite</p>
            <p><strong>Generated:</strong> 2025-10-06T11:41:24.474Z</p>
        </div>
        
        <div class="metrics">
            <div class="metric-card">
                <div class="metric-value">16079</div>
                <div class="metric-label">Total Tokens</div>
            </div>
            <div class="metric-card">
                <div class="metric-value">7.432s</div>
                <div class="metric-label">Duration</div>
            </div>
            <div class="metric-card">
                <div class="metric-value">$0.0040</div>
                <div class="metric-label">Total Cost</div>
            </div>
        </div>
        
        <div class="prompt-section">
            <div class="section-title">üìù Prompt</div>
            <div class="content-box">In a single HTML file named index.html, create exact copy of the PAC-MAN game in one html file using css and js.
</div>
        </div>
        
        <div class="response-section">
            <div class="section-title">üí¨ Response</div>
            <div class="content-box response-content">Creating an *exact* copy of Pac-Man in a single HTML file with CSS and JavaScript is a **monumental undertaking** and extremely difficult to achieve perfectly within the scope of a single response. Pac-Man involves:<br><br>*   **Complex Game Loop:** Handling simultaneous movement of Pac-Man, ghosts with AI, pellets, power pellets, and scoring.<br>*   **Collision Detection:** Precise detection of Pac-Man hitting walls, ghosts, pellets, and power pellets.<br>*   **Ghost AI:** Implementing different behaviors for each ghost (Blinky, Pinky, Inky, Clyde).<br>*   **Animation:** Smooth movement and sprite animations for Pac-Man and ghosts.<br>*   **Sound Effects:** Implementing the iconic sounds.<br>*   **Level Design:** Representing the maze layout.<br>*   **State Management:** Keeping track of game states (ready, playing, game over, winning).<br><br>However, I can provide a **simplified, functional version of Pac-Man** in a single <code>index.html</code> file that demonstrates the core mechanics: movement, pellet eating, basic collision with walls, and a rudimentary ghost. This will give you a good starting point and illustrate how it can be done.<br><br>**Please be aware that this is NOT an exact copy.** It&#039;s a simplified representation.<br><br>Here&#039;s the <code>index.html</code> file:<br><br><pre><code>&lt;!DOCTYPE html&gt;<br>&lt;html lang=&quot;en&quot;&gt;<br>&lt;head&gt;<br>    &lt;meta charset=&quot;UTF-8&quot;&gt;<br>    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;<br>    &lt;title&gt;Simple Pac-Man&lt;/title&gt;<br>    &lt;style&gt;<br>        body {<br>            display: flex;<br>            justify-content: center;<br>            align-items: center;<br>            min-height: 100vh;<br>            background-color: #000;<br>            margin: 0;<br>            font-family: &#039;Press Start 2P&#039;, cursive; /* For a retro feel, you&#039;d need to link this font */<br>            color: white;<br>            overflow: hidden; /* Prevent scrollbars */<br>        }<br><br>        #game-container {<br>            border: 2px solid #fff;<br>            position: relative;<br>            background-color: #000;<br>            overflow: hidden; /* Crucial for canvas clipping */<br>        }<br><br>        canvas {<br>            display: block;<br>        }<br><br>        #score-display {<br>            position: absolute;<br>            top: 10px;<br>            left: 10px;<br>            font-size: 16px;<br>            z-index: 10;<br>        }<br><br>        #game-over-overlay {<br>            position: absolute;<br>            top: 50%;<br>            left: 50%;<br>            transform: translate(-50%, -50%);<br>            font-size: 48px;<br>            color: red;<br>            text-align: center;<br>            z-index: 100;<br>            display: none; /* Initially hidden */<br>            background-color: rgba(0, 0, 0, 0.7);<br>            padding: 20px;<br>            border-radius: 10px;<br>        }<br><br>        #ready-overlay {<br>            position: absolute;<br>            top: 50%;<br>            left: 50%;<br>            transform: translate(-50%, -50%);<br>            font-size: 36px;<br>            color: yellow;<br>            text-align: center;<br>            z-index: 100;<br>            display: none; /* Initially hidden */<br>            background-color: rgba(0, 0, 0, 0.7);<br>            padding: 20px;<br>            border-radius: 10px;<br>        }<br>    &lt;/style&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>    &lt;div id=&quot;game-container&quot;&gt;<br>        &lt;div id=&quot;score-display&quot;&gt;Score: 0&lt;/div&gt;<br>        &lt;div id=&quot;ready-overlay&quot;&gt;Press Space to Start&lt;/div&gt;<br>        &lt;div id=&quot;game-over-overlay&quot;&gt;Game Over! &lt;br&gt; Press R to Restart&lt;/div&gt;<br>        &lt;canvas id=&quot;gameCanvas&quot;&gt;&lt;/canvas&gt;<br>    &lt;/div&gt;<br><br>    &lt;script&gt;<br>        const canvas = document.getElementById(&#039;gameCanvas&#039;);<br>        const ctx = canvas.getContext(&#039;2d&#039;);<br>        const scoreDisplay = document.getElementById(&#039;score-display&#039;);<br>        const gameOverOverlay = document.getElementById(&#039;game-over-overlay&#039;);<br>        const readyOverlay = document.getElementById(&#039;ready-overlay&#039;);<br><br>        // Game Settings<br>        const TILE_SIZE = 20; // Size of each grid cell<br>        const MAZE_WIDTH = 20; // Number of tiles horizontally<br>        const MAZE_HEIGHT = 20; // Number of tiles vertically<br>        canvas.width = MAZE_WIDTH * TILE_SIZE;<br>        canvas.height = MAZE_HEIGHT * TILE_SIZE;<br><br>        const PACMAN_SPEED = 2;<br>        const GHOST_SPEED = 1.5;<br><br>        // Game State<br>        let score = 0;<br>        let lives = 3; // Not implemented in this simple version, but good to have<br>        let gameRunning = false;<br>        let pacmanDirection = { x: 0, y: 0 }; // Current direction<br>        let nextPacmanDirection = { x: 0, y: 0 }; // Direction to change to on next tile<br><br>        // Maze Layout (0: empty, 1: wall, 2: pellet, 3: power pellet)<br>        // This is a very simplified maze. A real Pac-Man maze is much more complex.<br>        const maze = [<br>            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],<br>            [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1],<br>            [1, 2, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 2, 2, 1],<br>            [1, 2, 1, 0, 1, 2, 1, 0, 0, 0, 0, 0, 1, 2, 1, 0, 1, 2, 2, 1],<br>            [1, 2, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 2, 2, 1],<br>            [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1],<br>            [1, 2, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 2, 2, 1],<br>            [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1],<br>            [1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1],<br>            [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1],<br>            [1, 2, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 2, 2, 1],<br>            [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1],<br>            [1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1],<br>            [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1],<br>            [1, 2, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 2, 2, 1],<br>            [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1],<br>            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]<br>        ];<br>        // Adjust maze height if it&#039;s not filled to MAZE_HEIGHT<br>        while(maze.length &lt; MAZE_HEIGHT) {<br>            maze.push(Array(MAZE_WIDTH).fill(1)); // Fill with walls if short<br>        }<br>        maze.forEach(row =&gt; {<br>            while(row.length &lt; MAZE_WIDTH) {<br>                row.push(1); // Fill with walls if short<br>            }<br>        });<br><br><br>        // Game Objects<br>        let pacman = {<br>            x: 10 * TILE_SIZE + TILE_SIZE / 2, // Start in the middle of tile 10, 10<br>            y: 10 * TILE_SIZE + TILE_SIZE / 2,<br>            radius: TILE_SIZE / 2 - 2,<br>            color: &#039;yellow&#039;,<br>            mouthOpen: true,<br>            mouthAngle: 0.2 // Angle for Pac-Man&#039;s mouth<br>        };<br><br>        let ghosts = [<br>            {<br>                id: &#039;blinky&#039;,<br>                x: 9 * TILE_SIZE + TILE_SIZE / 2,<br>                y: 9 * TILE_SIZE + TILE_SIZE / 2,<br>                radius: TILE_SIZE / 2 - 2,<br>                color: &#039;red&#039;,<br>                direction: { x: 0, y: 0 },<br>                speed: GHOST_SPEED,<br>                AI: &#039;chase&#039; // Simple AI state<br>            },<br>            {<br>                id: &#039;pinky&#039;,<br>                x: 11 * TILE_SIZE + TILE_SIZE / 2,<br>                y: 9 * TILE_SIZE + TILE_SIZE / 2,<br>                radius: TILE_SIZE / 2 - 2,<br>                color: &#039;pink&#039;,<br>                direction: { x: 0, y: 0 },<br>                speed: GHOST_SPEED,<br>                AI: &#039;scatter&#039;<br>            }<br>            // Add more ghosts here if desired<br>        ];<br><br>        // --- Game Logic ---<br><br>        function getTile(x, y) {<br>            const tileX = Math.floor(x / TILE_SIZE);<br>            const tileY = Math.floor(y / TILE_SIZE);<br>            if (tileY &gt;= 0 &amp;&amp; tileY &lt; MAZE_HEIGHT &amp;&amp; tileX &gt;= 0 &amp;&amp; tileX &lt; MAZE_WIDTH) {<br>                return maze[tileY][tileX];<br>            }<br>            return 1; // Treat out of bounds as wall<br>        }<br><br>        function isWall(x, y) {<br>            return getTile(x, y) === 1;<br>        }<br><br>        function isPellet(x, y) {<br>            return getTile(x, y) === 2;<br>        }<br><br>        function isPowerPellet(x, y) {<br>            return getTile(x, y) === 3;<br>        }<br><br>        function getGridCoords(x, y) {<br>            return {<br>                gridX: Math.floor(x / TILE_SIZE),<br>                gridY: Math.floor(y / TILE_SIZE)<br>            };<br>        }<br><br>        function canMove(x, y, direction) {<br>            const nextX = x + direction.x * TILE_SIZE;<br>            const nextY = y + direction.y * TILE_SIZE;<br><br>            // Check collision with walls in the direction of movement<br>            // This is a simplified check, a more robust one would check corners<br>            const checkX = x + direction.x * (TILE_SIZE / 2); // Check halfway into the next tile<br>            const checkY = y + direction.y * (TILE_SIZE / 2);<br><br>            if (isWall(checkX, checkY)) {<br>                return false;<br>            }<br><br>            // Check if the next tile is a wall<br>            const gridX = Math.floor((x + direction.x * TILE_SIZE) / TILE_SIZE);<br>            const gridY = Math.floor((y + direction.y * TILE_SIZE) / TILE_SIZE);<br><br>            if (gridY &gt;= 0 &amp;&amp; gridY &lt; MAZE_HEIGHT &amp;&amp; gridX &gt;= 0 &amp;&amp; gridX &lt; MAZE_WIDTH) {<br>                if (maze[gridY][gridX] === 1) {<br>                    return false;<br>                }<br>            } else {<br>                return false; // Out of bounds is a wall<br>            }<br><br>            return true;<br>        }<br><br><br>        function movePacman() {<br>            // Try to change direction if a new direction is queued and it&#039;s valid<br>            if (nextPacmanDirection.x !== 0 || nextPacmanDirection.y !== 0) {<br>                if (canMove(pacman.x, pacman.y, nextPacmanDirection)) {<br>                    pacmanDirection = { ...nextPacmanDirection };<br>                    nextPacmanDirection = { x: 0, y: 0 }; // Clear the queued direction<br>                }<br>            }<br><br>            // Move in the current direction<br>            if (pacmanDirection.x !== 0 || pacmanDirection.y !== 0) {<br>                if (canMove(pacman.x, pacman.y, pacmanDirection)) {<br>                    pacman.x += pacmanDirection.x * PACMAN_SPEED;<br>                    pacman.y += pacmanDirection.y * PACMAN_SPEED;<br>                } else {<br>                    // If we hit a wall, we might be able to stop or switch direction<br>                    // For simplicity, we just stop if we can&#039;t move<br>                    // A better implementation would align to grid and check other directions<br>                    pacmanDirection = { x: 0, y: 0 };<br>                }<br>            }<br><br>            // Wrap around screen (simplified tunnel effect)<br>            if (pacman.x &lt; 0) pacman.x = canvas.width;<br>            if (pacman.x &gt; canvas.width) pacman.x = 0;<br>            if (pacman.y &lt; 0) pacman.y = canvas.height;<br>            if (pacman.y &gt; canvas.height) pacman.y = 0;<br><br>            // Eat pellets<br>            const currentGridX = Math.floor(pacman.x / TILE_SIZE);<br>            const currentGridY = Math.floor(pacman.y / TILE_SIZE);<br><br>            if (currentGridY &gt;= 0 &amp;&amp; currentGridY &lt; MAZE_HEIGHT &amp;&amp; currentGridX &gt;= 0 &amp;&amp; currentGridX &lt; MAZE_WIDTH) {<br>                if (maze[currentGridY][currentGridX] === 2) {<br>                    maze[currentGridY][currentGridX] = 0; // Remove pellet<br>                    score += 10;<br>                    scoreDisplay.textContent = <code>Score: ${score}</code>;<br>                } else if (maze[currentGridY][currentGridX] === 3) {<br>                    maze[currentGridY][currentGridX] = 0; // Remove power pellet<br>                    score += 50;<br>                    scoreDisplay.textContent = <code>Score: ${score}</code>;<br>                    // Implement power pellet effect (e.g., make ghosts vulnerable)<br>                    // For this simple version, it just gives points.<br>                }<br>            }<br>        }<br><br>        function moveGhost(ghost) {<br>            // Rudimentary Ghost AI: Try to move in a random valid direction<br>            // A real Pac-Man ghost AI is much more complex (chase, scatter, frightened, etc.)<br><br>            const possibleDirections = [];<br>            const directions = [{ x: 0, y: -1 }, { x: 0, y: 1 }, { x: -1, y: 0 }, { x: 1, y: 0 }];<br><br>            // Check which directions are not walls<br>            directions.forEach(dir =&gt; {<br>                // Calculate a point slightly ahead in the direction to check for walls<br>                const checkX = ghost.x + dir.x * (TILE_SIZE / 2);<br>                const checkY = ghost.y + dir.y * (TILE_SIZE / 2);<br><br>                // Also check the next tile for walls for more robust collision<br>                const nextGridX = Math.floor((ghost.x + dir.x * TILE_SIZE) / TILE_SIZE);<br>                const nextGridY = Math.floor((ghost.y + dir.y * TILE_SIZE) / TILE_SIZE);<br><br><br>                if (!isWall(checkX, checkY) &amp;&amp; (nextGridY &lt; 0 || nextGridY &gt;= MAZE_HEIGHT || nextGridX &lt; 0 || nextGridX &gt;= MAZE_WIDTH || maze[nextGridY][nextGridX] !== 1)) {<br>                    // Prevent reversing direction unless it&#039;s the only option (to avoid getting stuck)<br>                    if (!(dir.x === -ghost.direction.x &amp;&amp; dir.y === -ghost.direction.y) || (directions.length === 1)) {<br>                        possibleDirections.push(dir);<br>                    }<br>                }<br>            });<br><br>            // If there are valid moves, pick one.<br>            if (possibleDirections.length &gt; 0) {<br>                // Simple random move, or implement more complex AI here<br>                let chosenDirection = null;<br><br>                if (ghost.AI === &#039;chase&#039;) {<br>                    // Basic chase: try to move towards Pac-Man<br>                    const dx = pacman.x - ghost.x;<br>                    const dy = pacman.y - ghost.y;<br><br>                    let bestDir = null;<br>                    let minDistSq = Infinity;<br><br>                    possibleDirections.forEach(dir =&gt; {<br>                        const newX = ghost.x + dir.x * GHOST_SPEED;<br>                        const newY = ghost.y + dir.y * GHOST_SPEED;<br>                        const distSq = (newX - pacman.x)**2 + (newY - pacman.y)**2;<br>                        if (distSq &lt; minDistSq) {<br>                            minDistSq = distSq;<br>                            bestDir = dir;<br>                        }<br>                    });<br>                    chosenDirection = bestDir;<br>                } else if (ghost.AI === &#039;scatter&#039;) {<br>                    // Basic scatter: move towards a corner (e.g., top-left)<br>                    const scatterTargetX = 1 * TILE_SIZE;<br>                    const scatterTargetY = 1 * TILE_SIZE;<br>                    const dx = scatterTargetX - ghost.x;<br>                    const dy = scatterTargetY - ghost.y;<br><br>                    let bestDir = null;<br>                    let minDistSq = Infinity;<br><br>                    possibleDirections.forEach(dir =&gt; {<br>                        const newX = ghost.x + dir.x * GHOST_SPEED;<br>                        const newY = ghost.y + dir.y * GHOST_SPEED;<br>                        const distSq = (newX - scatterTargetX)**2 + (newY - scatterTargetY)**2;<br>                        if (distSq &lt; minDistSq) {<br>                            minDistSq = distSq;<br>                            bestDir = dir;<br>                        }<br>                    });<br>                    chosenDirection = bestDir;<br>                } else { // Random move if AI is unknown or not implemented<br>                    chosenDirection = possibleDirections[Math.floor(Math.random() * possibleDirections.length)];<br>                }<br><br>                // If a chosen direction is found, update ghost&#039;s direction<br>                if (chosenDirection) {<br>                    ghost.direction = chosenDirection;<br>                } else {<br>                    // Fallback to random if no specific AI direction is found<br>                    ghost.direction = possibleDirections[Math.floor(Math.random() * possibleDirections.length)];<br>                }<br>            } else {<br>                // If no possible directions, the ghost is stuck (shouldn&#039;t happen in a well-designed maze)<br>                ghost.direction = { x: 0, y: 0 };<br>            }<br><br>            // Move the ghost<br>            if (ghost.direction.x !== 0 || ghost.direction.y !== 0) {<br>                ghost.x += ghost.direction.x * ghost.speed;<br>                ghost.y += ghost.direction.y * ghost.speed;<br>            }<br><br>            // Wrap around screen (simplified tunnel effect)<br>            if (ghost.x &lt; 0) ghost.x = canvas.width;<br>            if (ghost.x &gt; canvas.width) ghost.x = 0;<br>            if (ghost.y &lt; 0) ghost.y = canvas.height;<br>            if (ghost.y &gt; canvas.height) ghost.y = 0;<br>        }<br><br>        function checkGhostCollision() {<br>            for (const ghost of ghosts) {<br>                const dx = pacman.x - ghost.x;<br>                const dy = pacman.y - ghost.y;<br>                const distance = Math.sqrt(dx * dx + dy * dy);<br><br>                if (distance &lt; pacman.radius + ghost.radius) {<br>                    // Collision detected!<br>                    gameOver();<br>                    return;<br>                }<br>            }<br>        }<br><br>        function drawMaze() {<br>            for (let y = 0; y &lt; MAZE_HEIGHT; y++) {<br>                for (let x = 0; x &lt; MAZE_WIDTH; x++) {<br>                    const tileType = maze[y][x];<br>                    const tileX = x * TILE_SIZE;<br>                    const tileY = y * TILE_SIZE;<br><br>                    ctx.fillStyle = &#039;#000&#039;; // Background<br>                    ctx.fillRect(tileX, tileY, TILE_SIZE, TILE_SIZE);<br><br>                    if (tileType === 1) { // Wall<br>                        ctx.fillStyle = &#039;#0000ff&#039;; // Blue for walls<br>                        ctx.fillRect(tileX, tileY, TILE_SIZE, TILE_SIZE);<br>                    } else if (tileType === 2) { // Pellet<br>                        ctx.fillStyle = &#039;white&#039;;<br>                        ctx.beginPath();<br>                        ctx.arc(tileX + TILE_SIZE / 2, tileY + TILE_SIZE / 2, TILE_SIZE / 8, 0, Math.PI * 2);<br>                        ctx.fill();<br>                    } else if (tileType === 3) { // Power Pellet<br>                        ctx.fillStyle = &#039;white&#039;;<br>                        ctx.beginPath();<br>                        ctx.arc(tileX + TILE_SIZE / 2, tileY + TILE_SIZE / 2, TILE_SIZE / 4, 0, Math.PI * 2);<br>                        ctx.fill();<br>                    }<br>                }<br>            }<br>        }<br><br>        function drawPacman() {<br>            ctx.fillStyle = pacman.color;<br>            ctx.save(); // Save the current drawing state<br><br>            ctx.translate(pacman.x, pacman.y); // Move origin to Pac-Man&#039;s center<br><br>            // Rotate Pac-Man to face the direction he&#039;s moving<br>            let angle = 0;<br>            if (pacmanDirection.y &lt; 0) angle = -Math.PI / 2; // Up<br>            else if (pacmanDirection.y &gt; 0) angle = Math.PI / 2; // Down<br>            else if (pacmanDirection.x &lt; 0) angle = Math.PI; // Left<br>            else if (pacmanDirection.x &gt; 0) angle = 0; // Right<br><br>            ctx.rotate(angle);<br><br>            ctx.beginPath();<br>            ctx.arc(0, 0, pacman.radius, pacman.mouthOpen ? pacman.mouthAngle : 0, Math.PI * 2 - (pacman.mouthOpen ? pacman.mouthAngle : 0));<br>            ctx.lineTo(0, 0); // Close the shape by drawing to the center<br>            ctx.fill();<br><br>            ctx.restore(); // Restore the original drawing state<br>        }<br><br>        function drawGhost(ghost) {<br>            ctx.fillStyle = ghost.color;<br>            ctx.beginPath();<br>            ctx.arc(ghost.x, ghost.y, ghost.radius, 0, Math.PI * 2);<br>            ctx.fill();<br>            // A more advanced ghost would have eyes and a body shape.<br>        }<br><br>        function updateScoreDisplay() {<br>            scoreDisplay.textContent = <code>Score: ${score}</code>;<br>        }<br><br>        function gameOver() {<br>            gameRunning = false;<br>            gameOverOverlay.style.display = &#039;block&#039;;<br>            readyOverlay.style.display = &#039;none&#039;;<br>        }<br><br>        function resetGame() {<br>            score = 0;<br>            lives = 3; // Reset lives if implemented<br>            gameRunning = false;<br>            pacmanDirection = { x: 0, y: 0 };<br>            nextPacmanDirection = { x: 0, y: 0 };<br><br>            // Reset Pac-Man position<br>            pacman.x = 10 * TILE_SIZE + TILE_SIZE / 2;<br>            pacman.y = 10 * TILE_SIZE + TILE_SIZE / 2;<br><br>            // Reset ghosts&#039; positions and directions<br>            ghosts[0].x = 9 * TILE_SIZE + TILE_SIZE / 2;<br>            ghosts[0].y = 9 * TILE_SIZE + TILE_SIZE / 2;<br>            ghosts[0].direction = { x: 0, y: 0 };<br>            ghosts[0].AI = &#039;chase&#039;;<br><br>            ghosts[1].x = 11 * TILE_SIZE + TILE_SIZE / 2;<br>            ghosts[1].y = 9 * TILE_SIZE + TILE_SIZE / 2;<br>            ghosts[1].direction = { x: 0, y: 0 };<br>            ghosts[1].AI = &#039;scatter&#039;;<br><br><br>            // Re-initialize maze (or a copy of the original)<br>            // For simplicity, we&#039;ll just reload the original maze structure<br>            // In a real game, you might have multiple levels.<br>            const originalMaze = [<br>                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],<br>                [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1],<br>                [1, 2, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 2, 2, 1],<br>                [1, 2, 1, 0, 1, 2, 1, 0, 0, 0, 0, 0, 1, 2, 1, 0, 1, 2, 2, 1],<br>                [1, 2, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 2, 2, 1],<br>                [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1],<br>                [1, 2, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 2, 2, 1],<br>                [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1],<br>                [1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1],<br>                [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1],<br>                [1, 2, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 2, 2, 1],<br>                [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1],<br>                [1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1],<br>                [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1],<br>                [1, 2, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 2, 2, 1],<br>                [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1],<br>                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]<br>            ];<br>            // Ensure the maze has the correct dimensions, padding with walls if necessary<br>            for (let i = 0; i &lt; MAZE_HEIGHT; i++) {<br>                if (!originalMaze[i]) originalMaze[i] = [];<br>                while (originalMaze[i].length &lt; MAZE_WIDTH) {<br>                    originalMaze[i].push(1);<br>                }<br>            }<br>             for (let i = 0; i &lt; MAZE_HEIGHT; i++) {<br>                originalMaze[i] = originalMaze[i].slice(0, MAZE_WIDTH);<br>            }<br>            // Ensure maze has enough rows<br>            while(originalMaze.length &lt; MAZE_HEIGHT) {<br>                originalMaze.push(Array(MAZE_WIDTH).fill(1));<br>            }<br>            // Ensure maze has enough columns in each row<br>            originalMaze.forEach(row =&gt; {<br>                while(row.length &lt; MAZE_WIDTH) {<br>                    row.push(1);<br>                }<br>            });<br><br>            // Deep copy the original maze to avoid modifying it directly on reset<br>            for (let y = 0; y &lt; MAZE_HEIGHT; y++) {<br>                for (let x = 0; x &lt; MAZE_WIDTH; x++) {<br>                    maze[y][x] = originalMaze[y][x];<br>                }<br>            }<br><br>            updateScoreDisplay();<br>            gameOverOverlay.style.display = &#039;none&#039;;<br>            readyOverlay.style.display = &#039;block&#039;;<br>        }<br><br>        function startGame() {<br>            if (!gameRunning) {<br>                gameRunning = true;<br>                readyOverlay.style.display = &#039;none&#039;;<br>                gameOverOverlay.style.display = &#039;none&#039;;<br>                gameLoop();<br>            }<br>        }<br><br>        function gameLoop() {<br>            if (!gameRunning) return;<br><br>            // Clear canvas<br>            ctx.clearRect(0, 0, canvas.width, canvas.height);<br><br>            // Update game state<br>            movePacman();<br>            ghosts.forEach(moveGhost);<br>            checkGhostCollision();<br><br>            // Draw elements<br>            drawMaze();<br>            drawPacman();<br>            ghosts.forEach(drawGhost);<br><br>            // Animation for Pac-Man&#039;s mouth<br>            pacman.mouthOpen = !pacman.mouthOpen;<br><br>            requestAnimationFrame(gameLoop); // Continue the loop<br>        }<br><br>        // --- Event Listeners ---<br><br>        document.addEventListener(&#039;keydown&#039;, (event) =&gt; {<br>            if (!gameRunning) {<br>                if (event.code === &#039;Space&#039;) {<br>                    startGame();<br>                } else if (event.code === &#039;KeyR&#039;) {<br>                    resetGame(); // Allow restarting from game over screen<br>                }<br>                return;<br>            }<br><br>            // Handle<br>movement controls when the game is running<br>            switch (event.code) {<br>                case &#039;ArrowUp&#039;:<br>                case &#039;KeyW&#039;:<br>                    nextPacmanDirection = { x: 0, y: -1 };<br>                    break;<br>                case &#039;ArrowDown&#039;:<br>                case &#039;KeyS&#039;:<br>                    nextPacmanDirection = { x: 0, y: 1 };<br>                    break;<br>                case &#039;ArrowLeft&#039;:<br>                case &#039;KeyA&#039;:<br>                    nextPacmanDirection = { x: -1, y: 0 };<br>                    break;<br>                case &#039;ArrowRight&#039;:<br>                case &#039;KeyD&#039;:<br>                    nextPacmanDirection = { x: 1, y: 0 };<br>                    break;<br>            }<br>        });<br><br>        // Initial setup<br>        resetGame(); // Set up the initial game state and display<br>    &lt;/script&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;</code></pre></div>
        </div>
    </div>
</body>
</html>