{
  "timestamp": "2025-10-06T11:41:24.467Z",
  "execution": {
    "duration_seconds": "7.432",
    "model_used": "google/gemini-2.5-flash-lite",
    "model_requested": "google/gemini-2.5-flash-lite"
  },
  "tokens": {
    "prompt_tokens": 7976,
    "completion_tokens": 8103,
    "total_tokens": 16079
  },
  "cost": {
    "currency": "USD",
    "prompt_cost": 0.000798,
    "completion_cost": 0.003241,
    "total_cost": 0.004039
  },
  "model_card": {
    "id": "google/gemini-2.5-flash-lite",
    "name": "Google: Gemini 2.5 Flash Lite",
    "description": "Gemini 2.5 Flash-Lite is a lightweight reasoning model in the Gemini 2.5 family, optimized for ultra-low latency and cost efficiency. It offers improved throughput, faster token generation, and better performance across common benchmarks compared to earlier Flash models. By default, \"thinking\" (i.e. multi-pass reasoning) is disabled to prioritize speed, but developers can enable it via the [Reasoning API parameter](https://openrouter.ai/docs/use-cases/reasoning-tokens) to selectively trade off cost for intelligence. ",
    "context_length": 1048576,
    "architecture": {
      "modality": "text+image->text",
      "input_modalities": [
        "file",
        "image",
        "text",
        "audio"
      ],
      "output_modalities": [
        "text"
      ],
      "tokenizer": "Gemini",
      "instruct_type": null
    },
    "pricing": {
      "prompt": "0.0000001",
      "completion": "0.0000004",
      "request": "0",
      "image": "0",
      "web_search": "0",
      "internal_reasoning": "0",
      "input_cache_read": "0.000000025",
      "input_cache_write": "0.0000001833"
    },
    "top_provider": {
      "context_length": 1048576,
      "max_completion_tokens": 65535,
      "is_moderated": false
    }
  },
  "request": {
    "prompt": "In a single HTML file named index.html, create exact copy of the PAC-MAN game in one html file using css and js.\n",
    "system_prompt": null,
    "temperature": 0.7,
    "max_tokens": 8000
  },
  "response_metadata": {
    "id": "gen-1759750865-fRKoedo8LakdcdBKJM8H",
    "created": 1759750865,
    "object": "chat.completion"
  },
  "raw_response": "Creating an *exact* copy of Pac-Man in a single HTML file with CSS and JavaScript is a **monumental undertaking** and extremely difficult to achieve perfectly within the scope of a single response. Pac-Man involves:\n\n*   **Complex Game Loop:** Handling simultaneous movement of Pac-Man, ghosts with AI, pellets, power pellets, and scoring.\n*   **Collision Detection:** Precise detection of Pac-Man hitting walls, ghosts, pellets, and power pellets.\n*   **Ghost AI:** Implementing different behaviors for each ghost (Blinky, Pinky, Inky, Clyde).\n*   **Animation:** Smooth movement and sprite animations for Pac-Man and ghosts.\n*   **Sound Effects:** Implementing the iconic sounds.\n*   **Level Design:** Representing the maze layout.\n*   **State Management:** Keeping track of game states (ready, playing, game over, winning).\n\nHowever, I can provide a **simplified, functional version of Pac-Man** in a single `index.html` file that demonstrates the core mechanics: movement, pellet eating, basic collision with walls, and a rudimentary ghost. This will give you a good starting point and illustrate how it can be done.\n\n**Please be aware that this is NOT an exact copy.** It's a simplified representation.\n\nHere's the `index.html` file:\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Simple Pac-Man</title>\n    <style>\n        body {\n            display: flex;\n            justify-content: center;\n            align-items: center;\n            min-height: 100vh;\n            background-color: #000;\n            margin: 0;\n            font-family: 'Press Start 2P', cursive; /* For a retro feel, you'd need to link this font */\n            color: white;\n            overflow: hidden; /* Prevent scrollbars */\n        }\n\n        #game-container {\n            border: 2px solid #fff;\n            position: relative;\n            background-color: #000;\n            overflow: hidden; /* Crucial for canvas clipping */\n        }\n\n        canvas {\n            display: block;\n        }\n\n        #score-display {\n            position: absolute;\n            top: 10px;\n            left: 10px;\n            font-size: 16px;\n            z-index: 10;\n        }\n\n        #game-over-overlay {\n            position: absolute;\n            top: 50%;\n            left: 50%;\n            transform: translate(-50%, -50%);\n            font-size: 48px;\n            color: red;\n            text-align: center;\n            z-index: 100;\n            display: none; /* Initially hidden */\n            background-color: rgba(0, 0, 0, 0.7);\n            padding: 20px;\n            border-radius: 10px;\n        }\n\n        #ready-overlay {\n            position: absolute;\n            top: 50%;\n            left: 50%;\n            transform: translate(-50%, -50%);\n            font-size: 36px;\n            color: yellow;\n            text-align: center;\n            z-index: 100;\n            display: none; /* Initially hidden */\n            background-color: rgba(0, 0, 0, 0.7);\n            padding: 20px;\n            border-radius: 10px;\n        }\n    </style>\n</head>\n<body>\n    <div id=\"game-container\">\n        <div id=\"score-display\">Score: 0</div>\n        <div id=\"ready-overlay\">Press Space to Start</div>\n        <div id=\"game-over-overlay\">Game Over! <br> Press R to Restart</div>\n        <canvas id=\"gameCanvas\"></canvas>\n    </div>\n\n    <script>\n        const canvas = document.getElementById('gameCanvas');\n        const ctx = canvas.getContext('2d');\n        const scoreDisplay = document.getElementById('score-display');\n        const gameOverOverlay = document.getElementById('game-over-overlay');\n        const readyOverlay = document.getElementById('ready-overlay');\n\n        // Game Settings\n        const TILE_SIZE = 20; // Size of each grid cell\n        const MAZE_WIDTH = 20; // Number of tiles horizontally\n        const MAZE_HEIGHT = 20; // Number of tiles vertically\n        canvas.width = MAZE_WIDTH * TILE_SIZE;\n        canvas.height = MAZE_HEIGHT * TILE_SIZE;\n\n        const PACMAN_SPEED = 2;\n        const GHOST_SPEED = 1.5;\n\n        // Game State\n        let score = 0;\n        let lives = 3; // Not implemented in this simple version, but good to have\n        let gameRunning = false;\n        let pacmanDirection = { x: 0, y: 0 }; // Current direction\n        let nextPacmanDirection = { x: 0, y: 0 }; // Direction to change to on next tile\n\n        // Maze Layout (0: empty, 1: wall, 2: pellet, 3: power pellet)\n        // This is a very simplified maze. A real Pac-Man maze is much more complex.\n        const maze = [\n            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n            [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1],\n            [1, 2, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 2, 2, 1],\n            [1, 2, 1, 0, 1, 2, 1, 0, 0, 0, 0, 0, 1, 2, 1, 0, 1, 2, 2, 1],\n            [1, 2, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 2, 2, 1],\n            [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1],\n            [1, 2, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 2, 2, 1],\n            [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1],\n            [1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1],\n            [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1],\n            [1, 2, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 2, 2, 1],\n            [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1],\n            [1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1],\n            [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1],\n            [1, 2, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 2, 2, 1],\n            [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1],\n            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n        ];\n        // Adjust maze height if it's not filled to MAZE_HEIGHT\n        while(maze.length < MAZE_HEIGHT) {\n            maze.push(Array(MAZE_WIDTH).fill(1)); // Fill with walls if short\n        }\n        maze.forEach(row => {\n            while(row.length < MAZE_WIDTH) {\n                row.push(1); // Fill with walls if short\n            }\n        });\n\n\n        // Game Objects\n        let pacman = {\n            x: 10 * TILE_SIZE + TILE_SIZE / 2, // Start in the middle of tile 10, 10\n            y: 10 * TILE_SIZE + TILE_SIZE / 2,\n            radius: TILE_SIZE / 2 - 2,\n            color: 'yellow',\n            mouthOpen: true,\n            mouthAngle: 0.2 // Angle for Pac-Man's mouth\n        };\n\n        let ghosts = [\n            {\n                id: 'blinky',\n                x: 9 * TILE_SIZE + TILE_SIZE / 2,\n                y: 9 * TILE_SIZE + TILE_SIZE / 2,\n                radius: TILE_SIZE / 2 - 2,\n                color: 'red',\n                direction: { x: 0, y: 0 },\n                speed: GHOST_SPEED,\n                AI: 'chase' // Simple AI state\n            },\n            {\n                id: 'pinky',\n                x: 11 * TILE_SIZE + TILE_SIZE / 2,\n                y: 9 * TILE_SIZE + TILE_SIZE / 2,\n                radius: TILE_SIZE / 2 - 2,\n                color: 'pink',\n                direction: { x: 0, y: 0 },\n                speed: GHOST_SPEED,\n                AI: 'scatter'\n            }\n            // Add more ghosts here if desired\n        ];\n\n        // --- Game Logic ---\n\n        function getTile(x, y) {\n            const tileX = Math.floor(x / TILE_SIZE);\n            const tileY = Math.floor(y / TILE_SIZE);\n            if (tileY >= 0 && tileY < MAZE_HEIGHT && tileX >= 0 && tileX < MAZE_WIDTH) {\n                return maze[tileY][tileX];\n            }\n            return 1; // Treat out of bounds as wall\n        }\n\n        function isWall(x, y) {\n            return getTile(x, y) === 1;\n        }\n\n        function isPellet(x, y) {\n            return getTile(x, y) === 2;\n        }\n\n        function isPowerPellet(x, y) {\n            return getTile(x, y) === 3;\n        }\n\n        function getGridCoords(x, y) {\n            return {\n                gridX: Math.floor(x / TILE_SIZE),\n                gridY: Math.floor(y / TILE_SIZE)\n            };\n        }\n\n        function canMove(x, y, direction) {\n            const nextX = x + direction.x * TILE_SIZE;\n            const nextY = y + direction.y * TILE_SIZE;\n\n            // Check collision with walls in the direction of movement\n            // This is a simplified check, a more robust one would check corners\n            const checkX = x + direction.x * (TILE_SIZE / 2); // Check halfway into the next tile\n            const checkY = y + direction.y * (TILE_SIZE / 2);\n\n            if (isWall(checkX, checkY)) {\n                return false;\n            }\n\n            // Check if the next tile is a wall\n            const gridX = Math.floor((x + direction.x * TILE_SIZE) / TILE_SIZE);\n            const gridY = Math.floor((y + direction.y * TILE_SIZE) / TILE_SIZE);\n\n            if (gridY >= 0 && gridY < MAZE_HEIGHT && gridX >= 0 && gridX < MAZE_WIDTH) {\n                if (maze[gridY][gridX] === 1) {\n                    return false;\n                }\n            } else {\n                return false; // Out of bounds is a wall\n            }\n\n            return true;\n        }\n\n\n        function movePacman() {\n            // Try to change direction if a new direction is queued and it's valid\n            if (nextPacmanDirection.x !== 0 || nextPacmanDirection.y !== 0) {\n                if (canMove(pacman.x, pacman.y, nextPacmanDirection)) {\n                    pacmanDirection = { ...nextPacmanDirection };\n                    nextPacmanDirection = { x: 0, y: 0 }; // Clear the queued direction\n                }\n            }\n\n            // Move in the current direction\n            if (pacmanDirection.x !== 0 || pacmanDirection.y !== 0) {\n                if (canMove(pacman.x, pacman.y, pacmanDirection)) {\n                    pacman.x += pacmanDirection.x * PACMAN_SPEED;\n                    pacman.y += pacmanDirection.y * PACMAN_SPEED;\n                } else {\n                    // If we hit a wall, we might be able to stop or switch direction\n                    // For simplicity, we just stop if we can't move\n                    // A better implementation would align to grid and check other directions\n                    pacmanDirection = { x: 0, y: 0 };\n                }\n            }\n\n            // Wrap around screen (simplified tunnel effect)\n            if (pacman.x < 0) pacman.x = canvas.width;\n            if (pacman.x > canvas.width) pacman.x = 0;\n            if (pacman.y < 0) pacman.y = canvas.height;\n            if (pacman.y > canvas.height) pacman.y = 0;\n\n            // Eat pellets\n            const currentGridX = Math.floor(pacman.x / TILE_SIZE);\n            const currentGridY = Math.floor(pacman.y / TILE_SIZE);\n\n            if (currentGridY >= 0 && currentGridY < MAZE_HEIGHT && currentGridX >= 0 && currentGridX < MAZE_WIDTH) {\n                if (maze[currentGridY][currentGridX] === 2) {\n                    maze[currentGridY][currentGridX] = 0; // Remove pellet\n                    score += 10;\n                    scoreDisplay.textContent = `Score: ${score}`;\n                } else if (maze[currentGridY][currentGridX] === 3) {\n                    maze[currentGridY][currentGridX] = 0; // Remove power pellet\n                    score += 50;\n                    scoreDisplay.textContent = `Score: ${score}`;\n                    // Implement power pellet effect (e.g., make ghosts vulnerable)\n                    // For this simple version, it just gives points.\n                }\n            }\n        }\n\n        function moveGhost(ghost) {\n            // Rudimentary Ghost AI: Try to move in a random valid direction\n            // A real Pac-Man ghost AI is much more complex (chase, scatter, frightened, etc.)\n\n            const possibleDirections = [];\n            const directions = [{ x: 0, y: -1 }, { x: 0, y: 1 }, { x: -1, y: 0 }, { x: 1, y: 0 }];\n\n            // Check which directions are not walls\n            directions.forEach(dir => {\n                // Calculate a point slightly ahead in the direction to check for walls\n                const checkX = ghost.x + dir.x * (TILE_SIZE / 2);\n                const checkY = ghost.y + dir.y * (TILE_SIZE / 2);\n\n                // Also check the next tile for walls for more robust collision\n                const nextGridX = Math.floor((ghost.x + dir.x * TILE_SIZE) / TILE_SIZE);\n                const nextGridY = Math.floor((ghost.y + dir.y * TILE_SIZE) / TILE_SIZE);\n\n\n                if (!isWall(checkX, checkY) && (nextGridY < 0 || nextGridY >= MAZE_HEIGHT || nextGridX < 0 || nextGridX >= MAZE_WIDTH || maze[nextGridY][nextGridX] !== 1)) {\n                    // Prevent reversing direction unless it's the only option (to avoid getting stuck)\n                    if (!(dir.x === -ghost.direction.x && dir.y === -ghost.direction.y) || (directions.length === 1)) {\n                        possibleDirections.push(dir);\n                    }\n                }\n            });\n\n            // If there are valid moves, pick one.\n            if (possibleDirections.length > 0) {\n                // Simple random move, or implement more complex AI here\n                let chosenDirection = null;\n\n                if (ghost.AI === 'chase') {\n                    // Basic chase: try to move towards Pac-Man\n                    const dx = pacman.x - ghost.x;\n                    const dy = pacman.y - ghost.y;\n\n                    let bestDir = null;\n                    let minDistSq = Infinity;\n\n                    possibleDirections.forEach(dir => {\n                        const newX = ghost.x + dir.x * GHOST_SPEED;\n                        const newY = ghost.y + dir.y * GHOST_SPEED;\n                        const distSq = (newX - pacman.x)**2 + (newY - pacman.y)**2;\n                        if (distSq < minDistSq) {\n                            minDistSq = distSq;\n                            bestDir = dir;\n                        }\n                    });\n                    chosenDirection = bestDir;\n                } else if (ghost.AI === 'scatter') {\n                    // Basic scatter: move towards a corner (e.g., top-left)\n                    const scatterTargetX = 1 * TILE_SIZE;\n                    const scatterTargetY = 1 * TILE_SIZE;\n                    const dx = scatterTargetX - ghost.x;\n                    const dy = scatterTargetY - ghost.y;\n\n                    let bestDir = null;\n                    let minDistSq = Infinity;\n\n                    possibleDirections.forEach(dir => {\n                        const newX = ghost.x + dir.x * GHOST_SPEED;\n                        const newY = ghost.y + dir.y * GHOST_SPEED;\n                        const distSq = (newX - scatterTargetX)**2 + (newY - scatterTargetY)**2;\n                        if (distSq < minDistSq) {\n                            minDistSq = distSq;\n                            bestDir = dir;\n                        }\n                    });\n                    chosenDirection = bestDir;\n                } else { // Random move if AI is unknown or not implemented\n                    chosenDirection = possibleDirections[Math.floor(Math.random() * possibleDirections.length)];\n                }\n\n                // If a chosen direction is found, update ghost's direction\n                if (chosenDirection) {\n                    ghost.direction = chosenDirection;\n                } else {\n                    // Fallback to random if no specific AI direction is found\n                    ghost.direction = possibleDirections[Math.floor(Math.random() * possibleDirections.length)];\n                }\n            } else {\n                // If no possible directions, the ghost is stuck (shouldn't happen in a well-designed maze)\n                ghost.direction = { x: 0, y: 0 };\n            }\n\n            // Move the ghost\n            if (ghost.direction.x !== 0 || ghost.direction.y !== 0) {\n                ghost.x += ghost.direction.x * ghost.speed;\n                ghost.y += ghost.direction.y * ghost.speed;\n            }\n\n            // Wrap around screen (simplified tunnel effect)\n            if (ghost.x < 0) ghost.x = canvas.width;\n            if (ghost.x > canvas.width) ghost.x = 0;\n            if (ghost.y < 0) ghost.y = canvas.height;\n            if (ghost.y > canvas.height) ghost.y = 0;\n        }\n\n        function checkGhostCollision() {\n            for (const ghost of ghosts) {\n                const dx = pacman.x - ghost.x;\n                const dy = pacman.y - ghost.y;\n                const distance = Math.sqrt(dx * dx + dy * dy);\n\n                if (distance < pacman.radius + ghost.radius) {\n                    // Collision detected!\n                    gameOver();\n                    return;\n                }\n            }\n        }\n\n        function drawMaze() {\n            for (let y = 0; y < MAZE_HEIGHT; y++) {\n                for (let x = 0; x < MAZE_WIDTH; x++) {\n                    const tileType = maze[y][x];\n                    const tileX = x * TILE_SIZE;\n                    const tileY = y * TILE_SIZE;\n\n                    ctx.fillStyle = '#000'; // Background\n                    ctx.fillRect(tileX, tileY, TILE_SIZE, TILE_SIZE);\n\n                    if (tileType === 1) { // Wall\n                        ctx.fillStyle = '#0000ff'; // Blue for walls\n                        ctx.fillRect(tileX, tileY, TILE_SIZE, TILE_SIZE);\n                    } else if (tileType === 2) { // Pellet\n                        ctx.fillStyle = 'white';\n                        ctx.beginPath();\n                        ctx.arc(tileX + TILE_SIZE / 2, tileY + TILE_SIZE / 2, TILE_SIZE / 8, 0, Math.PI * 2);\n                        ctx.fill();\n                    } else if (tileType === 3) { // Power Pellet\n                        ctx.fillStyle = 'white';\n                        ctx.beginPath();\n                        ctx.arc(tileX + TILE_SIZE / 2, tileY + TILE_SIZE / 2, TILE_SIZE / 4, 0, Math.PI * 2);\n                        ctx.fill();\n                    }\n                }\n            }\n        }\n\n        function drawPacman() {\n            ctx.fillStyle = pacman.color;\n            ctx.save(); // Save the current drawing state\n\n            ctx.translate(pacman.x, pacman.y); // Move origin to Pac-Man's center\n\n            // Rotate Pac-Man to face the direction he's moving\n            let angle = 0;\n            if (pacmanDirection.y < 0) angle = -Math.PI / 2; // Up\n            else if (pacmanDirection.y > 0) angle = Math.PI / 2; // Down\n            else if (pacmanDirection.x < 0) angle = Math.PI; // Left\n            else if (pacmanDirection.x > 0) angle = 0; // Right\n\n            ctx.rotate(angle);\n\n            ctx.beginPath();\n            ctx.arc(0, 0, pacman.radius, pacman.mouthOpen ? pacman.mouthAngle : 0, Math.PI * 2 - (pacman.mouthOpen ? pacman.mouthAngle : 0));\n            ctx.lineTo(0, 0); // Close the shape by drawing to the center\n            ctx.fill();\n\n            ctx.restore(); // Restore the original drawing state\n        }\n\n        function drawGhost(ghost) {\n            ctx.fillStyle = ghost.color;\n            ctx.beginPath();\n            ctx.arc(ghost.x, ghost.y, ghost.radius, 0, Math.PI * 2);\n            ctx.fill();\n            // A more advanced ghost would have eyes and a body shape.\n        }\n\n        function updateScoreDisplay() {\n            scoreDisplay.textContent = `Score: ${score}`;\n        }\n\n        function gameOver() {\n            gameRunning = false;\n            gameOverOverlay.style.display = 'block';\n            readyOverlay.style.display = 'none';\n        }\n\n        function resetGame() {\n            score = 0;\n            lives = 3; // Reset lives if implemented\n            gameRunning = false;\n            pacmanDirection = { x: 0, y: 0 };\n            nextPacmanDirection = { x: 0, y: 0 };\n\n            // Reset Pac-Man position\n            pacman.x = 10 * TILE_SIZE + TILE_SIZE / 2;\n            pacman.y = 10 * TILE_SIZE + TILE_SIZE / 2;\n\n            // Reset ghosts' positions and directions\n            ghosts[0].x = 9 * TILE_SIZE + TILE_SIZE / 2;\n            ghosts[0].y = 9 * TILE_SIZE + TILE_SIZE / 2;\n            ghosts[0].direction = { x: 0, y: 0 };\n            ghosts[0].AI = 'chase';\n\n            ghosts[1].x = 11 * TILE_SIZE + TILE_SIZE / 2;\n            ghosts[1].y = 9 * TILE_SIZE + TILE_SIZE / 2;\n            ghosts[1].direction = { x: 0, y: 0 };\n            ghosts[1].AI = 'scatter';\n\n\n            // Re-initialize maze (or a copy of the original)\n            // For simplicity, we'll just reload the original maze structure\n            // In a real game, you might have multiple levels.\n            const originalMaze = [\n                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n                [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1],\n                [1, 2, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 2, 2, 1],\n                [1, 2, 1, 0, 1, 2, 1, 0, 0, 0, 0, 0, 1, 2, 1, 0, 1, 2, 2, 1],\n                [1, 2, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 2, 2, 1],\n                [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1],\n                [1, 2, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 2, 2, 1],\n                [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1],\n                [1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1],\n                [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1],\n                [1, 2, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 2, 2, 1],\n                [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1],\n                [1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1],\n                [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1],\n                [1, 2, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 2, 2, 1],\n                [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1],\n                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n            ];\n            // Ensure the maze has the correct dimensions, padding with walls if necessary\n            for (let i = 0; i < MAZE_HEIGHT; i++) {\n                if (!originalMaze[i]) originalMaze[i] = [];\n                while (originalMaze[i].length < MAZE_WIDTH) {\n                    originalMaze[i].push(1);\n                }\n            }\n             for (let i = 0; i < MAZE_HEIGHT; i++) {\n                originalMaze[i] = originalMaze[i].slice(0, MAZE_WIDTH);\n            }\n            // Ensure maze has enough rows\n            while(originalMaze.length < MAZE_HEIGHT) {\n                originalMaze.push(Array(MAZE_WIDTH).fill(1));\n            }\n            // Ensure maze has enough columns in each row\n            originalMaze.forEach(row => {\n                while(row.length < MAZE_WIDTH) {\n                    row.push(1);\n                }\n            });\n\n            // Deep copy the original maze to avoid modifying it directly on reset\n            for (let y = 0; y < MAZE_HEIGHT; y++) {\n                for (let x = 0; x < MAZE_WIDTH; x++) {\n                    maze[y][x] = originalMaze[y][x];\n                }\n            }\n\n            updateScoreDisplay();\n            gameOverOverlay.style.display = 'none';\n            readyOverlay.style.display = 'block';\n        }\n\n        function startGame() {\n            if (!gameRunning) {\n                gameRunning = true;\n                readyOverlay.style.display = 'none';\n                gameOverOverlay.style.display = 'none';\n                gameLoop();\n            }\n        }\n\n        function gameLoop() {\n            if (!gameRunning) return;\n\n            // Clear canvas\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n            // Update game state\n            movePacman();\n            ghosts.forEach(moveGhost);\n            checkGhostCollision();\n\n            // Draw elements\n            drawMaze();\n            drawPacman();\n            ghosts.forEach(drawGhost);\n\n            // Animation for Pac-Man's mouth\n            pacman.mouthOpen = !pacman.mouthOpen;\n\n            requestAnimationFrame(gameLoop); // Continue the loop\n        }\n\n        // --- Event Listeners ---\n\n        document.addEventListener('keydown', (event) => {\n            if (!gameRunning) {\n                if (event.code === 'Space') {\n                    startGame();\n                } else if (event.code === 'KeyR') {\n                    resetGame(); // Allow restarting from game over screen\n                }\n                return;\n            }\n\n            // Handle\nmovement controls when the game is running\n            switch (event.code) {\n                case 'ArrowUp':\n                case 'KeyW':\n                    nextPacmanDirection = { x: 0, y: -1 };\n                    break;\n                case 'ArrowDown':\n                case 'KeyS':\n                    nextPacmanDirection = { x: 0, y: 1 };\n                    break;\n                case 'ArrowLeft':\n                case 'KeyA':\n                    nextPacmanDirection = { x: -1, y: 0 };\n                    break;\n                case 'ArrowRight':\n                case 'KeyD':\n                    nextPacmanDirection = { x: 1, y: 0 };\n                    break;\n            }\n        });\n\n        // Initial setup\n        resetGame(); // Set up the initial game state and display\n    </script>\n</body>\n</html>\n```"
}