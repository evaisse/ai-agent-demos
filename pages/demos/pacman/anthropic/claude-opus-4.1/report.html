<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OpenRouter API Response</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            max-width: 900px;
            margin: 0 auto;
            padding: 2rem;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        .container {
            background: white;
            border-radius: 16px;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            padding: 2rem;
        }
        h1 {
            color: #1a202c;
            margin-bottom: 1.5rem;
            font-size: 2rem;
        }
        .metadata {
            background: #f7fafc;
            border-left: 4px solid #667eea;
            padding: 1rem;
            margin-bottom: 2rem;
            border-radius: 4px;
        }
        .metadata p {
            margin: 0.5rem 0;
            color: #4a5568;
        }
        .metadata strong {
            color: #2d3748;
        }
        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 1rem;
            margin-bottom: 2rem;
        }
        .metric-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 1rem;
            border-radius: 8px;
            text-align: center;
        }
        .metric-value {
            font-size: 1.5rem;
            font-weight: bold;
        }
        .metric-label {
            font-size: 0.875rem;
            opacity: 0.9;
        }
        .prompt-section, .response-section {
            margin-bottom: 2rem;
        }
        .section-title {
            font-size: 1.25rem;
            font-weight: 600;
            color: #2d3748;
            margin-bottom: 1rem;
        }
        .content-box {
            background: #f9fafb;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 1.5rem;
            white-space: pre-wrap;
            word-wrap: break-word;
            color: #2d3748;
            line-height: 1.6;
        }
        .response-content {
            background: white;
            border: 2px solid #667eea;
        }
        code {
            background: #edf2f7;
            padding: 0.2rem 0.4rem;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
        }
        pre {
            background: #2d3748;
            color: #e2e8f0;
            padding: 1rem;
            border-radius: 8px;
            overflow-x: auto;
        }
        pre code {
            background: transparent;
            padding: 0;
            color: inherit;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ü§ñ OpenRouter API Response</h1>
        
        <div class="metadata">
            <p><strong>Model:</strong> anthropic/claude-opus-4.1</p>
            <p><strong>Generated:</strong> 2025-10-06T11:43:33.482Z</p>
        </div>
        
        <div class="metrics">
            <div class="metric-card">
                <div class="metric-value">16821</div>
                <div class="metric-label">Total Tokens</div>
            </div>
            <div class="metric-card">
                <div class="metric-value">15.920s</div>
                <div class="metric-label">Duration</div>
            </div>
            <div class="metric-card">
                <div class="metric-value">$0.7762</div>
                <div class="metric-label">Total Cost</div>
            </div>
        </div>
        
        <div class="prompt-section">
            <div class="section-title">üìù Prompt</div>
            <div class="content-box">In a single HTML file named index.html, create exact copy of the PAC-MAN game in one html file using css and js.
</div>
        </div>
        
        <div class="response-section">
            <div class="section-title">üí¨ Response</div>
            <div class="content-box response-content">I&#039;ll create a fully functional PAC-MAN game in a single HTML file. This is a complete implementation with ghosts, pellets, power-ups, scoring, and multiple levels.<br><br><pre><code>&lt;!DOCTYPE html&gt;<br>&lt;html lang=&quot;en&quot;&gt;<br>&lt;head&gt;<br>    &lt;meta charset=&quot;UTF-8&quot;&gt;<br>    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;<br>    &lt;title&gt;PAC-MAN&lt;/title&gt;<br>    &lt;style&gt;<br>        * {<br>            margin: 0;<br>            padding: 0;<br>            box-sizing: border-box;<br>        }<br><br>        body {<br>            background: #000;<br>            display: flex;<br>            justify-content: center;<br>            align-items: center;<br>            min-height: 100vh;<br>            font-family: &#039;Courier New&#039;, monospace;<br>        }<br><br>        #gameContainer {<br>            text-align: center;<br>        }<br><br>        #scoreBoard {<br>            color: white;<br>            margin-bottom: 20px;<br>            font-size: 20px;<br>        }<br><br>        #score, #highScore, #lives {<br>            margin: 0 15px;<br>        }<br><br>        #gameCanvas {<br>            border: 2px solid #2121ff;<br>            display: block;<br>            background: #000;<br>        }<br><br>        #gameOver, #startScreen {<br>            position: absolute;<br>            top: 50%;<br>            left: 50%;<br>            transform: translate(-50%, -50%);<br>            color: white;<br>            font-size: 24px;<br>            text-align: center;<br>        }<br><br>        #startScreen h1 {<br>            color: #ffff00;<br>            font-size: 48px;<br>            margin-bottom: 20px;<br>            text-shadow: 2px 2px 4px rgba(255, 255, 0, 0.5);<br>        }<br><br>        .hidden {<br>            display: none;<br>        }<br><br>        button {<br>            background: #ffff00;<br>            color: #000;<br>            border: none;<br>            padding: 10px 20px;<br>            font-size: 18px;<br>            cursor: pointer;<br>            margin-top: 20px;<br>            font-weight: bold;<br>            border-radius: 5px;<br>        }<br><br>        button:hover {<br>            background: #ffff88;<br>        }<br><br>        .controls {<br>            color: #888;<br>            margin-top: 20px;<br>            font-size: 14px;<br>        }<br>    &lt;/style&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>    &lt;div id=&quot;gameContainer&quot;&gt;<br>        &lt;div id=&quot;scoreBoard&quot;&gt;<br>            &lt;span id=&quot;score&quot;&gt;Score: 0&lt;/span&gt;<br>            &lt;span id=&quot;highScore&quot;&gt;High: 0&lt;/span&gt;<br>            &lt;span id=&quot;lives&quot;&gt;Lives: 3&lt;/span&gt;<br>        &lt;/div&gt;<br>        &lt;canvas id=&quot;gameCanvas&quot; width=&quot;672&quot; height=&quot;744&quot;&gt;&lt;/canvas&gt;<br>        &lt;div id=&quot;startScreen&quot;&gt;<br>            &lt;h1&gt;PAC-MAN&lt;/h1&gt;<br>            &lt;button onclick=&quot;startGame()&quot;&gt;START GAME&lt;/button&gt;<br>            &lt;div class=&quot;controls&quot;&gt;<br>                Use ARROW KEYS or WASD to move<br>            &lt;/div&gt;<br>        &lt;/div&gt;<br>        &lt;div id=&quot;gameOver&quot; class=&quot;hidden&quot;&gt;<br>            &lt;h2&gt;GAME OVER&lt;/h2&gt;<br>            &lt;p&gt;Final Score: &lt;span id=&quot;finalScore&quot;&gt;0&lt;/span&gt;&lt;/p&gt;<br>            &lt;button onclick=&quot;resetGame()&quot;&gt;PLAY AGAIN&lt;/button&gt;<br>        &lt;/div&gt;<br>    &lt;/div&gt;<br><br>    &lt;script&gt;<br>        const canvas = document.getElementById(&#039;gameCanvas&#039;);<br>        const ctx = canvas.getContext(&#039;2d&#039;);<br>        const CELL_SIZE = 24;<br>        const ROWS = 31;<br>        const COLS = 28;<br><br>        let score = 0;<br>        let highScore = localStorage.getItem(&#039;pacmanHighScore&#039;) || 0;<br>        let lives = 3;<br>        let gameRunning = false;<br>        let level = 1;<br>        let dotsEaten = 0;<br>        let totalDots = 0;<br>        let powerMode = false;<br>        let powerModeTimer = 0;<br>        let gameLoop = null;<br><br>        // Game map (1 = wall, 0 = dot, 2 = power pellet, 3 = empty)<br>        const initialMap = [<br>            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],<br>            [1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1],<br>            [1,0,1,1,1,1,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,1,1,1,1,0,1],<br>            [1,2,1,1,1,1,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,1,1,1,1,2,1],<br>            [1,0,1,1,1,1,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,1,1,1,1,0,1],<br>            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],<br>            [1,0,1,1,1,1,0,1,1,0,1,1,1,1,1,1,1,1,0,1,1,0,1,1,1,1,0,1],<br>            [1,0,1,1,1,1,0,1,1,0,1,1,1,1,1,1,1,1,0,1,1,0,1,1,1,1,0,1],<br>            [1,0,0,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,0,0,1],<br>            [1,1,1,1,1,1,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,1,1,1,1,1,1],<br>            [1,1,1,1,1,1,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,1,1,1,1,1,1],<br>            [1,1,1,1,1,1,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,1,1,1,1,1,1],<br>            [1,1,1,1,1,1,0,1,1,0,1,1,1,3,3,1,1,1,0,1,1,0,1,1,1,1,1,1],<br>            [1,1,1,1,1,1,0,1,1,0,1,3,3,3,3,3,3,1,0,1,1,0,1,1,1,1,1,1],<br>            [3,3,3,3,3,3,0,0,0,0,1,3,3,3,3,3,3,1,0,0,0,0,3,3,3,3,3,3],<br>            [1,1,1,1,1,1,0,1,1,0,1,3,3,3,3,3,3,1,0,1,1,0,1,1,1,1,1,1],<br>            [1,1,1,1,1,1,0,1,1,0,1,1,1,1,1,1,1,1,0,1,1,0,1,1,1,1,1,1],<br>            [1,1,1,1,1,1,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,1,1,1,1,1,1],<br>            [1,1,1,1,1,1,0,1,1,0,1,1,1,1,1,1,1,1,0,1,1,0,1,1,1,1,1,1],<br>            [1,1,1,1,1,1,0,1,1,0,1,1,1,1,1,1,1,1,0,1,1,0,1,1,1,1,1,1],<br>            [1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1],<br>            [1,0,1,1,1,1,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,1,1,1,1,0,1],<br>            [1,0,1,1,1,1,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,1,1,1,1,0,1],<br>            [1,2,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,2,1],<br>            [1,1,1,0,1,1,0,1,1,0,1,1,1,1,1,1,1,1,0,1,1,0,1,1,0,1,1,1],<br>            [1,1,1,0,1,1,0,1,1,0,1,1,1,1,1,1,1,1,0,1,1,0,1,1,0,1,1,1],<br>            [1,0,0,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,0,0,1],<br>            [1,0,1,1,1,1,1,1,1,1,1,1,0,1,1,0,1,1,1,1,1,1,1,1,1,1,0,1],<br>            [1,0,1,1,1,1,1,1,1,1,1,1,0,1,1,0,1,1,1,1,1,1,1,1,1,1,0,1],<br>            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],<br>            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]<br>        ];<br><br>        let map = [];<br><br>        function resetMap() {<br>            map = initialMap.map(row =&gt; [...row]);<br>            totalDots = 0;<br>            dotsEaten = 0;<br>            for (let row of map) {<br>                for (let cell of row) {<br>                    if (cell === 0 || cell === 2) totalDots++;<br>                }<br>            }<br>        }<br><br>        // Pac-Man object<br>        const pacman = {<br>            x: 13.5,<br>            y: 23,<br>            direction: &#039;right&#039;,<br>            nextDirection: null,<br>            speed: 0.15,<br>            animationCounter: 0<br>        };<br><br>        // Ghost class<br>        class Ghost {<br>            constructor(x, y, color, personality) {<br>                this.x = x;<br>                this.y = y;<br>                this.startX = x;<br>                this.startY = y;<br>                this.color = color;<br>                this.personality = personality;<br>                this.direction = &#039;up&#039;;<br>                this.speed = 0.1;<br>                this.isScared = false;<br>                this.isDead = false;<br>                this.scaredTimer = 0;<br>            }<br><br>            reset() {<br>                this.x = this.startX;<br>                this.y = this.startY;<br>                this.direction = &#039;up&#039;;<br>                this.isDead = false;<br>                this.isScared = false;<br>                this.scaredTimer = 0;<br>            }<br><br>            move() {<br>                if (this.isDead) {<br>                    // Move back to spawn<br>                    const dx = this.startX - this.x;<br>                    const dy = this.startY - this.y;<br>                    const dist = Math.sqrt(dx * dx + dy * dy);<br>                    <br>                    if (dist &lt; 0.5) {<br>                        this.isDead = false;<br>                        this.x = this.startX;<br>                        this.y = this.startY;<br>                    } else {<br>                        this.x += (dx / dist) * this.speed * 2;<br>                        this.y += (dy / dist) * this.speed * 2;<br>                    }<br>                    return;<br>                }<br><br>                const possibleMoves = [];<br>                const directions = [<br>                    { dir: &#039;up&#039;, dx: 0, dy: -1 },<br>                    { dir: &#039;down&#039;, dx: 0, dy: 1 },<br>                    { dir: &#039;left&#039;, dx: -1, dy: 0 },<br>                    { dir: &#039;right&#039;, dx: 1, dy: 0 }<br>                ];<br><br>                for (let d of directions) {<br>                    const newX = Math.round(this.x + d.dx);<br>                    const newY = Math.round(this.y + d.dy);<br>                    <br>                    if (newY &gt;= 0 &amp;&amp; newY &lt; ROWS &amp;&amp; newX &gt;= 0 &amp;&amp; newX &lt; COLS &amp;&amp; <br>                        map[newY][newX] !== 1) {<br>                        // Don&#039;t reverse direction unless necessary<br>                        if (this.direction === &#039;up&#039; &amp;&amp; d.dir === &#039;down&#039;) continue;<br>                        if (this.direction === &#039;down&#039; &amp;&amp; d.dir === &#039;up&#039;) continue;<br>                        if (this.direction === &#039;left&#039; &amp;&amp; d.dir === &#039;right&#039;) continue;<br>                        if (this.direction === &#039;right&#039; &amp;&amp; d.dir === &#039;left&#039;) continue;<br>                        <br>                        possibleMoves.push(d);<br>                    }<br>                }<br><br>                if (possibleMoves.length === 0) {<br>                    // If stuck, allow reversal<br>                    for (let d of directions) {<br>                        const newX = Math.round(this.x + d.dx);<br>                        const newY = Math.round(this.y + d.dy);<br>                        <br>                        if (newY &gt;= 0 &amp;&amp; newY &lt; ROWS &amp;&amp; newX &gt;= 0 &amp;&amp; newX &lt; COLS &amp;&amp; <br>                            map[newY][newX] !== 1) {<br>                            possibleMoves.push(d);<br>                        }<br>                    }<br>                }<br><br>                if (possibleMoves.length &gt; 0) {<br>                    let chosenMove;<br>                    <br>                    if (this.isScared) {<br>                        // Run away from Pac-Man<br>                        chosenMove = possibleMoves.reduce((best, move) =&gt; {<br>                            const newX = this.x + move.dx;<br>                            const newY = this.y + move.dy;<br>                            const dist = Math.sqrt(Math.pow(newX - pacman.x, 2) + Math.pow(newY - pacman.y, 2));<br>                            const bestDist = Math.sqrt(Math.pow(this.x + best.dx - pacman.x, 2) + <br>                                                      Math.pow(this.y + best.dy - pacman.y, 2));<br>                            return dist &gt; bestDist ? move : best;<br>                        });<br>                    } else if (this.personality === &#039;chaser&#039;) {<br>                        // Chase Pac-Man directly<br>                        chosenMove = possibleMoves.reduce((best, move) =&gt; {<br>                            const newX = this.x + move.dx;<br>                            const newY = this.y + move.dy;<br>                            const dist = Math.sqrt(Math.pow(newX - pacman.x, 2) + Math.pow(newY - pacman.y, 2));<br>                            const bestDist = Math.sqrt(Math.pow(this.x + best.dx - pacman.x, 2) + <br>                                                      Math.pow(this.y + best.dy - pacman.y, 2));<br>                            return dist &lt; bestDist ? move : best;<br>                        });<br>                    } else if (this.personality === &#039;ambusher&#039;) {<br>                        // Try to get ahead of Pac-Man<br>                        let targetX = pacman.x;<br>                        let targetY = pacman.y;<br>                        <br>                        if (pacman.direction === &#039;up&#039;) targetY -= 4;<br>                        else if (pacman.direction === &#039;down&#039;) targetY += 4;<br>                        else if (pacman.direction === &#039;left&#039;) targetX -= 4;<br>                        else if (pacman.direction === &#039;right&#039;) targetX += 4;<br>                        <br>                        chosenMove = possibleMoves.reduce((best, move) =&gt; {<br>                            const newX = this.x + move.dx;<br>                            const newY = this.y + move.dy;<br>                            const dist = Math.sqrt(Math.pow(newX - targetX, 2) + Math.pow(newY - targetY, 2));<br>                            const bestDist = Math.sqrt(Math.pow(this.x + best.dx - targetX, 2) + <br>                                                      Math.pow(this.y + best.dy - targetY, 2));<br>                            return dist &lt; bestDist ? move : best;<br>                        });<br>                    } else {<br>                        // Random movement<br>                        chosenMove = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];<br>                    }<br>                    <br>                    this.direction = chosenMove.dir;<br>                    this.x += chosenMove.dx * this.speed;<br>                    this.y += chosenMove.dy * this.speed;<br>                }<br><br>                // Handle tunnel<br>                if (this.x &lt; 0) this.x = COLS - 1;<br>                if (this.x &gt;= COLS) this.x = 0;<br>            }<br><br>            update() {<br>                if (this.isScared) {<br>                    this.scaredTimer--;<br>                    if (this.scaredTimer &lt;= 0) {<br>                        this.isScared = false;<br>                    }<br>                }<br>                this.move();<br>            }<br>        }<br><br>        // Create ghosts<br>        const ghosts = [<br>            new Ghost(13.5, 14, &#039;#ff0000&#039;, &#039;chaser&#039;),    // Red - Blinky<br>            new Ghost(13.5, 14, &#039;#ffb8ff&#039;, &#039;ambusher&#039;),  // Pink - Pinky<br>            new Ghost(11.5, 14, &#039;#00ffff&#039;, &#039;random&#039;),    // Cyan - Inky<br>            new Ghost(15.5, 14, &#039;#ffb852&#039;, &#039;random&#039;)     // Orange - Clyde<br>        ];<br><br>        // Input handling<br>        const keys = {};<br>        document.addEventListener(&#039;keydown&#039;, (e) =&gt; {<br>            keys[e.key] = true;<br>            <br>            if (gameRunning) {<br>                if (e.key === &#039;ArrowUp&#039; || e.key === &#039;w&#039; || e.key === &#039;W&#039;) {<br>                    pacman.nextDirection = &#039;up&#039;;<br>                } else if (e.key === &#039;ArrowDown&#039; || e.key === &#039;s&#039; || e.key === &#039;S&#039;) {<br>                    pacman.nextDirection = &#039;down&#039;;<br>                } else if (e.key === &#039;ArrowLeft&#039; || e.key === &#039;a&#039; || e.key === &#039;A&#039;) {<br>                    pacman.nextDirection = &#039;left&#039;;<br>                } else if (e.key === &#039;ArrowRight&#039; || e.key === &#039;d&#039; || e.key === &#039;D&#039;) {<br>                    pacman.nextDirection = &#039;right&#039;;<br>                }<br>            }<br>        });<br><br>        document.addEventListener(&#039;keyup&#039;, (e) =&gt; {<br>            keys[e.key] = false;<br>        });<br><br>        function canMove(x, y, direction) {<br>            let newX = x;<br>            let newY = y;<br>            <br>            if (direction === &#039;up&#039;) newY = Math.floor(y - 0.5);<br>            else if (direction === &#039;down&#039;) newY = Math.ceil(y + 0.5);<br>            else if (direction === &#039;left&#039;) newX = Math.floor(x - 0.5);<br>            else if (direction === &#039;right&#039;) newX = Math.ceil(x + 0.5);<br>            <br>            if (newY &lt; 0 || newY &gt;= ROWS || newX &lt; 0 || newX &gt;= COLS) {<br>                return direction === &#039;left&#039; || direction === &#039;right&#039;; // Allow tunnel<br>            }<br>            <br>            return map[newY][newX] !== 1;<br>        }<br><br>        function updatePacman() {<br>            pacman.animationCounter++;<br>            <br>            // Try to change direction<br>            if (pacman.nextDirection &amp;&amp; canMove(pacman.x, pacman.y, pacman.nextDirection)) {<br>                pacman.direction = pacman.nextDirection;<br>                pacman.nextDirection = null;<br>            }<br>            <br>            // Move Pac-Man<br>            if (canMove(pacman.x, pacman.y, pacman.direction)) {<br>                if (pacman.direction === &#039;up&#039;) pacman.y -= pacman.speed;<br>                else if (pacman.direction === &#039;down&#039;) pacman.y += pacman.speed;<br>                else if (pacman.direction === &#039;left&#039;) pacman.x -= pacman.speed;<br>                else if (pacman.direction === &#039;right&#039;) pacman.x += pacman.speed;<br>            }<br>            <br>            // Handle tunnel<br>            if (pacman.x &lt; 0) pacman.x = COLS - 1;<br>            if (pacman.x &gt;= COLS) pacman.x = 0;<br>            <br>            // Eat dots<br>            const gridX = Math.round(pacman.x);<br>            const gridY = Math.round(pacman.y);<br>            <br>            if (map[gridY][gridX] === 0) {<br>                map[gridY][gridX] = 3;<br>                score += 10;<br>                dotsEaten++;<br>            } else if (map[gridY][gridX] === 2) {<br>                map[gridY][gridX] = 3;<br>                score += 50;<br>                dotsEaten++;<br>                powerMode = true;<br>                powerModeTimer = 500; // About 8 seconds<br>                <br>                ghosts.forEach(ghost =&gt; {<br>                    if (!ghost.isDead) {<br>                        ghost.isScared = true;<br>                        ghost.scaredTimer = 500;<br>                    }<br>                });<br>            }<br>            <br>            // Check ghost collision<br>            ghosts.forEach(ghost =&gt; {<br>                const dist = Math.sqrt(Math.pow(ghost.x - pacman.x, 2) + Math.pow(ghost.y - pacman.y, 2));<br>                <br>                if (dist &lt; 0.8) {<br>                    if (ghost.isScared &amp;&amp; !ghost.isDead) {<br>                        ghost.isDead = true;<br>                        ghost.isScared = false;<br>                        score += 200;<br>                    } else if (!ghost.isDead) {<br>                        loseLife();<br>                    }<br>                }<br>            });<br>            <br>            // Check win condition<br>            if (dotsEaten &gt;= totalDots) {<br>                nextLevel();<br>            }<br>        }<br><br>        function loseLife() {<br>            lives--;<br>            updateScore();<br>            <br>            if (lives &lt;= 0) {<br>                endGame();<br>            } else {<br>                resetPositions();<br>            }<br>        }<br><br>        function resetPositions() {<br>            pacman.x = 13.5;<br>            pacman.y = 23;<br>            pacman.direction = &#039;right&#039;;<br>            pacman.nextDirection = null;<br>            <br>            ghosts.forEach(ghost =&gt; ghost.reset());<br>        }<br><br>        function nextLevel() {<br>            level++;<br>            resetMap();<br>            resetPositions();<br>            <br>            // Increase difficulty<br>            ghosts.forEach(ghost =&gt; {<br>                ghost.speed = Math.min(0.15, ghost.speed + 0.01);<br>            });<br>        }<br><br>        function updateScore() {<br>            document.getElementById(&#039;score&#039;).textContent = <code>Score: ${score}</code>;<br>            document.getElementById(&#039;lives&#039;).textContent = <code>Lives: ${lives}</code>;<br>            <br>            if (score &gt; highScore) {<br>                highScore = score;<br>                localStorage.setItem(&#039;pacmanHighScore&#039;, highScore);<br>                document.getElementById(&#039;highScore&#039;).textContent = <code>High: ${highScore}</code>;<br>            }<br>        }<br><br>        function draw() {<br>            ctx.clearRect(0, 0, canvas.width, canvas.height);<br>            <br>            // Draw maze<br>            for (let row = 0; row &lt; ROWS; row++) {<br>                for (let col = 0; col &lt; COLS; col++) {<br>                    const x = col * CELL_SIZE;<br>                    const y = row * CELL_SIZE;<br>                    <br>                    if (map[row][col] === 1) {<br>                        ctx.fillStyle = &#039;#2121ff&#039;;<br>                        ctx.fillRect(x, y, CELL_SIZE, CELL_SIZE);<br>                    } else if (map[row][col] === 0) {<br>                        ctx.fillStyle = &#039;#ffb897&#039;;<br>                        ctx.beginPath();<br>                        ctx.arc(x + CELL_SIZE/2, y + CELL_SIZE/2, 2, 0, Math.PI * 2);<br>                        ctx.fill();<br>                    } else if (map[row][col] === 2) {<br>                        ctx.fillStyle = &#039;#ffb897&#039;;<br>                        ctx.beginPath();<br>                        ctx.arc(x + CELL_SIZE/2, y + CELL_SIZE/2, 6, 0, Math.PI * 2);<br>                        ctx.fill();<br>                    }<br>                }<br>            }<br>            <br>            // Draw Pac-Man<br>            ctx.fillStyle = &#039;#ffff00&#039;;<br>            ctx.beginPath();<br>            const mouthAngle = Math.abs(Math.sin(pacman.animationCounter * 0.1)) * 0.3;<br>            let startAngle = mouthAngle;<br>            let endAngle = Math.PI * 2 - mouthAngle;<br>            <br>            if (pacman.direction === &#039;up&#039;) {<br>                startAngle = Math.PI * 1.5 + mouthAngle;<br>                endAngle = Math.PI * 1.5 - mouthAngle;<br>            } else if (pacman.direction === &#039;down&#039;) {<br>                startAngle = Math.PI * 0.5 + mouthAngle;<br>                endAngle = Math.PI * 0.5 - mouthAngle;<br>            } else if (pacman.direction === &#039;left&#039;) {<br>                startAngle = Math.PI + mouthAngle;<br>                endAngle = Math.PI - mouthAngle;<br>            }<br>            <br>            ctx.arc(pacman.x * CELL_SIZE + CELL_SIZE/2, pacman.y * CELL_SIZE + CELL_SIZE/2, <br>                    CELL_SIZE/2 - 2, startAngle, endAngle);<br>            ctx.lineTo(pacman.x * CELL_SIZE + CELL_SIZE/2, pacman.y * CELL_SIZE + CELL_SIZE/2);<br>            ctx.fill();<br>            <br>            // Draw ghosts<br>            ghosts.forEach(ghost =&gt; {<br>                const ghostX = ghost.x * CELL_SIZE + CELL_SIZE/2;<br>                const ghostY = ghost.y * CELL_SIZE + CELL_SIZE/2;<br>                <br>                if (ghost.isDead) {<br>                    // Draw eyes only<br>                    ctx.fillStyle = &#039;white&#039;;<br>                    ctx.beginPath();<br>                    ctx.arc(ghostX - 5, ghostY - 5, 3, 0, Math.PI * 2);<br>                    ctx.arc(ghostX + 5, ghostY - 5, 3, 0, Math.PI * 2);<br>                    ctx.fill();<br>                    <br>                    ctx.fillStyle = &#039;blue&#039;;<br>                    ctx.beginPath();<br>                    ctx.arc(ghostX - 5, ghostY - 5, 1.5, 0, Math.PI * 2);<br>                    ctx.arc(ghostX + 5, ghostY - 5, 1.5, 0, Math.PI * 2);<br>                    ctx.fill();<br>                } else {<br>                    // Ghost body<br>                    ctx.fillStyle = ghost.isScared ? <br>                        (ghost.scaredTimer &lt; 100 &amp;&amp; Math.floor(ghost.scaredTimer / 10) % 2 ? &#039;white&#039; : &#039;blue&#039;) : <br>                        ghost.color;<br>                    <br>                    ctx.beginPath();<br>                    ctx.arc(ghostX, ghostY - 3, CELL_SIZE/2 - 2, Math.PI, 0, false);<br>                    ctx.lineTo(ghostX + CELL_SIZE/2 - 2, ghostY + CELL_SIZE/2 - 4);<br>                    <br>                    // Wavy bottom<br>                    for (let i = 0; i &lt; 3; i++) {<br>                        ctx.quadraticCurveTo(<br>                            ghostX + CELL_SIZE/2 - 6 - i * 6, <br>                            ghostY + CELL_SIZE/2 - 2,<br>                            ghostX + CELL_SIZE/2 - 8 - i * 6, <br>                            ghostY + CELL_SIZE/2 - 4<br>                        );<br>                    }<br>                    <br>                    ctx.closePath();<br>                    ctx.fill();<br>                    <br>                    // Eyes<br>                    if (!ghost.isScared) {<br>                        ctx.fillStyle = &#039;white&#039;;<br>                        ctx.beginPath();<br>                        ctx.arc(ghostX - 5, ghostY - 5, 3, 0, Math.PI * 2);<br>                        ctx.arc(ghostX + 5, ghostY - 5, 3, 0, Math.PI * 2);<br>                        ctx.fill();<br>                        <br>                        ctx.fillStyle = &#039;blue&#039;;<br>                        ctx.beginPath();<br>                        ctx.arc(ghostX - 5 + (ghost.direction === &#039;left&#039; ? -1 : ghost.direction === &#039;right&#039; ? 1 : 0), <br>                               ghostY - 5 + (ghost.direction === &#039;up&#039; ? -1 : ghost.direction === &#039;down&#039; ? 1 : 0), <br>                               1.5, 0, Math.PI * 2);<br>                        ctx.arc(ghostX + 5 + (ghost.direction === &#039;left&#039; ? -1 : ghost.direction === &#039;right&#039; ? 1 : 0), <br>                               ghostY - 5 + (ghost.direction === &#039;up&#039; ? -1 : ghost.direction === &#039;down&#039; ? 1 : 0), <br>                               1.5, 0</code></pre>javascript<br>                               1.5, 0, Math.PI * 2);<br>                        ctx.fill();<br>                    } else {<br>                        // Scared face<br>                        ctx.strokeStyle = &#039;white&#039;;<br>                        ctx.lineWidth = 2;<br>                        ctx.beginPath();<br>                        ctx.moveTo(ghostX - 7, ghostY + 3);<br>                        ctx.lineTo(ghostX - 3, ghostY + 6);<br>                        ctx.lineTo(ghostX, ghostY + 3);<br>                        ctx.lineTo(ghostX + 3, ghostY + 6);<br>                        ctx.lineTo(ghostX + 7, ghostY + 3);<br>                        ctx.stroke();<br>                        <br>                        ctx.fillStyle = &#039;white&#039;;<br>                        ctx.fillRect(ghostX - 6, ghostY - 6, 3, 3);<br>                        ctx.fillRect(ghostX + 3, ghostY - 6, 3, 3);<br>                    }<br>                }<br>            });<br>            <br>            // Draw power mode indicator<br>            if (powerMode) {<br>                ctx.fillStyle = <code>rgba(255, 255, 255, ${0.1 + Math.sin(Date.now() * 0.01) * 0.05})</code>;<br>                ctx.fillRect(0, 0, canvas.width, canvas.height);<br>            }<br>        }<br><br>        function update() {<br>            if (!gameRunning) return;<br>            <br>            updatePacman();<br>            ghosts.forEach(ghost =&gt; ghost.update());<br>            <br>            if (powerMode) {<br>                powerModeTimer--;<br>                if (powerModeTimer &lt;= 0) {<br>                    powerMode = false;<br>                }<br>            }<br>            <br>            updateScore();<br>        }<br><br>        function gameStep() {<br>            update();<br>            draw();<br>            <br>            if (gameRunning) {<br>                requestAnimationFrame(gameStep);<br>            }<br>        }<br><br>        function startGame() {<br>            document.getElementById(&#039;startScreen&#039;).classList.add(&#039;hidden&#039;);<br>            document.getElementById(&#039;gameOver&#039;).classList.add(&#039;hidden&#039;);<br>            <br>            resetMap();<br>            resetPositions();<br>            score = 0;<br>            lives = 3;<br>            level = 1;<br>            powerMode = false;<br>            powerModeTimer = 0;<br>            gameRunning = true;<br>            <br>            updateScore();<br>            document.getElementById(&#039;highScore&#039;).textContent = <code>High: ${highScore}</code>;<br>            <br>            gameStep();<br>        }<br><br>        function endGame() {<br>            gameRunning = false;<br>            document.getElementById(&#039;finalScore&#039;).textContent = score;<br>            document.getElementById(&#039;gameOver&#039;).classList.remove(&#039;hidden&#039;);<br>        }<br><br>        function resetGame() {<br>            startGame();<br>        }<br><br>        // Initialize<br>        window.onload = () =&gt; {<br>            document.getElementById(&#039;highScore&#039;).textContent = <code>High: ${highScore}</code>;<br>            draw(); // Draw initial maze<br>        };<br>    &lt;/script&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br>```</div>
        </div>
    </div>
</body>
</html>