{
  "timestamp": "2025-10-06T11:43:33.459Z",
  "execution": {
    "duration_seconds": "15.920",
    "model_used": "anthropic/claude-opus-4.1",
    "model_requested": "anthropic/claude-opus-4.1"
  },
  "tokens": {
    "prompt_tokens": 8090,
    "completion_tokens": 8731,
    "total_tokens": 16821
  },
  "cost": {
    "currency": "USD",
    "prompt_cost": 0.12135,
    "completion_cost": 0.654825,
    "total_cost": 0.776175
  },
  "model_card": {
    "id": "anthropic/claude-opus-4.1",
    "name": "Anthropic: Claude Opus 4.1",
    "description": "Claude Opus 4.1 is an updated version of Anthropicâ€™s flagship model, offering improved performance in coding, reasoning, and agentic tasks. It achieves 74.5% on SWE-bench Verified and shows notable gains in multi-file code refactoring, debugging precision, and detail-oriented reasoning. The model supports extended thinking up to 64K tokens and is optimized for tasks involving research, data analysis, and tool-assisted reasoning.",
    "context_length": 200000,
    "architecture": {
      "modality": "text+image->text",
      "input_modalities": [
        "image",
        "text",
        "file"
      ],
      "output_modalities": [
        "text"
      ],
      "tokenizer": "Claude",
      "instruct_type": null
    },
    "pricing": {
      "prompt": "0.000015",
      "completion": "0.000075",
      "request": "0",
      "image": "0.024",
      "web_search": "0",
      "internal_reasoning": "0",
      "input_cache_read": "0.0000015",
      "input_cache_write": "0.00001875"
    },
    "top_provider": {
      "context_length": 200000,
      "max_completion_tokens": 32000,
      "is_moderated": false
    }
  },
  "request": {
    "prompt": "In a single HTML file named index.html, create exact copy of the PAC-MAN game in one html file using css and js.\n",
    "system_prompt": null,
    "temperature": 0.7,
    "max_tokens": 8000
  },
  "response_metadata": {
    "id": "gen-1759750865-JkwlusOjotfwZcHimjil",
    "created": 1759750865,
    "object": "chat.completion"
  },
  "raw_response": "I'll create a fully functional PAC-MAN game in a single HTML file. This is a complete implementation with ghosts, pellets, power-ups, scoring, and multiple levels.\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>PAC-MAN</title>\n    <style>\n        * {\n            margin: 0;\n            padding: 0;\n            box-sizing: border-box;\n        }\n\n        body {\n            background: #000;\n            display: flex;\n            justify-content: center;\n            align-items: center;\n            min-height: 100vh;\n            font-family: 'Courier New', monospace;\n        }\n\n        #gameContainer {\n            text-align: center;\n        }\n\n        #scoreBoard {\n            color: white;\n            margin-bottom: 20px;\n            font-size: 20px;\n        }\n\n        #score, #highScore, #lives {\n            margin: 0 15px;\n        }\n\n        #gameCanvas {\n            border: 2px solid #2121ff;\n            display: block;\n            background: #000;\n        }\n\n        #gameOver, #startScreen {\n            position: absolute;\n            top: 50%;\n            left: 50%;\n            transform: translate(-50%, -50%);\n            color: white;\n            font-size: 24px;\n            text-align: center;\n        }\n\n        #startScreen h1 {\n            color: #ffff00;\n            font-size: 48px;\n            margin-bottom: 20px;\n            text-shadow: 2px 2px 4px rgba(255, 255, 0, 0.5);\n        }\n\n        .hidden {\n            display: none;\n        }\n\n        button {\n            background: #ffff00;\n            color: #000;\n            border: none;\n            padding: 10px 20px;\n            font-size: 18px;\n            cursor: pointer;\n            margin-top: 20px;\n            font-weight: bold;\n            border-radius: 5px;\n        }\n\n        button:hover {\n            background: #ffff88;\n        }\n\n        .controls {\n            color: #888;\n            margin-top: 20px;\n            font-size: 14px;\n        }\n    </style>\n</head>\n<body>\n    <div id=\"gameContainer\">\n        <div id=\"scoreBoard\">\n            <span id=\"score\">Score: 0</span>\n            <span id=\"highScore\">High: 0</span>\n            <span id=\"lives\">Lives: 3</span>\n        </div>\n        <canvas id=\"gameCanvas\" width=\"672\" height=\"744\"></canvas>\n        <div id=\"startScreen\">\n            <h1>PAC-MAN</h1>\n            <button onclick=\"startGame()\">START GAME</button>\n            <div class=\"controls\">\n                Use ARROW KEYS or WASD to move\n            </div>\n        </div>\n        <div id=\"gameOver\" class=\"hidden\">\n            <h2>GAME OVER</h2>\n            <p>Final Score: <span id=\"finalScore\">0</span></p>\n            <button onclick=\"resetGame()\">PLAY AGAIN</button>\n        </div>\n    </div>\n\n    <script>\n        const canvas = document.getElementById('gameCanvas');\n        const ctx = canvas.getContext('2d');\n        const CELL_SIZE = 24;\n        const ROWS = 31;\n        const COLS = 28;\n\n        let score = 0;\n        let highScore = localStorage.getItem('pacmanHighScore') || 0;\n        let lives = 3;\n        let gameRunning = false;\n        let level = 1;\n        let dotsEaten = 0;\n        let totalDots = 0;\n        let powerMode = false;\n        let powerModeTimer = 0;\n        let gameLoop = null;\n\n        // Game map (1 = wall, 0 = dot, 2 = power pellet, 3 = empty)\n        const initialMap = [\n            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],\n            [1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1],\n            [1,0,1,1,1,1,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,1,1,1,1,0,1],\n            [1,2,1,1,1,1,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,1,1,1,1,2,1],\n            [1,0,1,1,1,1,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,1,1,1,1,0,1],\n            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],\n            [1,0,1,1,1,1,0,1,1,0,1,1,1,1,1,1,1,1,0,1,1,0,1,1,1,1,0,1],\n            [1,0,1,1,1,1,0,1,1,0,1,1,1,1,1,1,1,1,0,1,1,0,1,1,1,1,0,1],\n            [1,0,0,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,0,0,1],\n            [1,1,1,1,1,1,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,1,1,1,1,1,1],\n            [1,1,1,1,1,1,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,1,1,1,1,1,1],\n            [1,1,1,1,1,1,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,1,1,1,1,1,1],\n            [1,1,1,1,1,1,0,1,1,0,1,1,1,3,3,1,1,1,0,1,1,0,1,1,1,1,1,1],\n            [1,1,1,1,1,1,0,1,1,0,1,3,3,3,3,3,3,1,0,1,1,0,1,1,1,1,1,1],\n            [3,3,3,3,3,3,0,0,0,0,1,3,3,3,3,3,3,1,0,0,0,0,3,3,3,3,3,3],\n            [1,1,1,1,1,1,0,1,1,0,1,3,3,3,3,3,3,1,0,1,1,0,1,1,1,1,1,1],\n            [1,1,1,1,1,1,0,1,1,0,1,1,1,1,1,1,1,1,0,1,1,0,1,1,1,1,1,1],\n            [1,1,1,1,1,1,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,1,1,1,1,1,1],\n            [1,1,1,1,1,1,0,1,1,0,1,1,1,1,1,1,1,1,0,1,1,0,1,1,1,1,1,1],\n            [1,1,1,1,1,1,0,1,1,0,1,1,1,1,1,1,1,1,0,1,1,0,1,1,1,1,1,1],\n            [1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1],\n            [1,0,1,1,1,1,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,1,1,1,1,0,1],\n            [1,0,1,1,1,1,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,1,1,1,1,0,1],\n            [1,2,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,2,1],\n            [1,1,1,0,1,1,0,1,1,0,1,1,1,1,1,1,1,1,0,1,1,0,1,1,0,1,1,1],\n            [1,1,1,0,1,1,0,1,1,0,1,1,1,1,1,1,1,1,0,1,1,0,1,1,0,1,1,1],\n            [1,0,0,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,0,0,1],\n            [1,0,1,1,1,1,1,1,1,1,1,1,0,1,1,0,1,1,1,1,1,1,1,1,1,1,0,1],\n            [1,0,1,1,1,1,1,1,1,1,1,1,0,1,1,0,1,1,1,1,1,1,1,1,1,1,0,1],\n            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],\n            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\n        ];\n\n        let map = [];\n\n        function resetMap() {\n            map = initialMap.map(row => [...row]);\n            totalDots = 0;\n            dotsEaten = 0;\n            for (let row of map) {\n                for (let cell of row) {\n                    if (cell === 0 || cell === 2) totalDots++;\n                }\n            }\n        }\n\n        // Pac-Man object\n        const pacman = {\n            x: 13.5,\n            y: 23,\n            direction: 'right',\n            nextDirection: null,\n            speed: 0.15,\n            animationCounter: 0\n        };\n\n        // Ghost class\n        class Ghost {\n            constructor(x, y, color, personality) {\n                this.x = x;\n                this.y = y;\n                this.startX = x;\n                this.startY = y;\n                this.color = color;\n                this.personality = personality;\n                this.direction = 'up';\n                this.speed = 0.1;\n                this.isScared = false;\n                this.isDead = false;\n                this.scaredTimer = 0;\n            }\n\n            reset() {\n                this.x = this.startX;\n                this.y = this.startY;\n                this.direction = 'up';\n                this.isDead = false;\n                this.isScared = false;\n                this.scaredTimer = 0;\n            }\n\n            move() {\n                if (this.isDead) {\n                    // Move back to spawn\n                    const dx = this.startX - this.x;\n                    const dy = this.startY - this.y;\n                    const dist = Math.sqrt(dx * dx + dy * dy);\n                    \n                    if (dist < 0.5) {\n                        this.isDead = false;\n                        this.x = this.startX;\n                        this.y = this.startY;\n                    } else {\n                        this.x += (dx / dist) * this.speed * 2;\n                        this.y += (dy / dist) * this.speed * 2;\n                    }\n                    return;\n                }\n\n                const possibleMoves = [];\n                const directions = [\n                    { dir: 'up', dx: 0, dy: -1 },\n                    { dir: 'down', dx: 0, dy: 1 },\n                    { dir: 'left', dx: -1, dy: 0 },\n                    { dir: 'right', dx: 1, dy: 0 }\n                ];\n\n                for (let d of directions) {\n                    const newX = Math.round(this.x + d.dx);\n                    const newY = Math.round(this.y + d.dy);\n                    \n                    if (newY >= 0 && newY < ROWS && newX >= 0 && newX < COLS && \n                        map[newY][newX] !== 1) {\n                        // Don't reverse direction unless necessary\n                        if (this.direction === 'up' && d.dir === 'down') continue;\n                        if (this.direction === 'down' && d.dir === 'up') continue;\n                        if (this.direction === 'left' && d.dir === 'right') continue;\n                        if (this.direction === 'right' && d.dir === 'left') continue;\n                        \n                        possibleMoves.push(d);\n                    }\n                }\n\n                if (possibleMoves.length === 0) {\n                    // If stuck, allow reversal\n                    for (let d of directions) {\n                        const newX = Math.round(this.x + d.dx);\n                        const newY = Math.round(this.y + d.dy);\n                        \n                        if (newY >= 0 && newY < ROWS && newX >= 0 && newX < COLS && \n                            map[newY][newX] !== 1) {\n                            possibleMoves.push(d);\n                        }\n                    }\n                }\n\n                if (possibleMoves.length > 0) {\n                    let chosenMove;\n                    \n                    if (this.isScared) {\n                        // Run away from Pac-Man\n                        chosenMove = possibleMoves.reduce((best, move) => {\n                            const newX = this.x + move.dx;\n                            const newY = this.y + move.dy;\n                            const dist = Math.sqrt(Math.pow(newX - pacman.x, 2) + Math.pow(newY - pacman.y, 2));\n                            const bestDist = Math.sqrt(Math.pow(this.x + best.dx - pacman.x, 2) + \n                                                      Math.pow(this.y + best.dy - pacman.y, 2));\n                            return dist > bestDist ? move : best;\n                        });\n                    } else if (this.personality === 'chaser') {\n                        // Chase Pac-Man directly\n                        chosenMove = possibleMoves.reduce((best, move) => {\n                            const newX = this.x + move.dx;\n                            const newY = this.y + move.dy;\n                            const dist = Math.sqrt(Math.pow(newX - pacman.x, 2) + Math.pow(newY - pacman.y, 2));\n                            const bestDist = Math.sqrt(Math.pow(this.x + best.dx - pacman.x, 2) + \n                                                      Math.pow(this.y + best.dy - pacman.y, 2));\n                            return dist < bestDist ? move : best;\n                        });\n                    } else if (this.personality === 'ambusher') {\n                        // Try to get ahead of Pac-Man\n                        let targetX = pacman.x;\n                        let targetY = pacman.y;\n                        \n                        if (pacman.direction === 'up') targetY -= 4;\n                        else if (pacman.direction === 'down') targetY += 4;\n                        else if (pacman.direction === 'left') targetX -= 4;\n                        else if (pacman.direction === 'right') targetX += 4;\n                        \n                        chosenMove = possibleMoves.reduce((best, move) => {\n                            const newX = this.x + move.dx;\n                            const newY = this.y + move.dy;\n                            const dist = Math.sqrt(Math.pow(newX - targetX, 2) + Math.pow(newY - targetY, 2));\n                            const bestDist = Math.sqrt(Math.pow(this.x + best.dx - targetX, 2) + \n                                                      Math.pow(this.y + best.dy - targetY, 2));\n                            return dist < bestDist ? move : best;\n                        });\n                    } else {\n                        // Random movement\n                        chosenMove = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];\n                    }\n                    \n                    this.direction = chosenMove.dir;\n                    this.x += chosenMove.dx * this.speed;\n                    this.y += chosenMove.dy * this.speed;\n                }\n\n                // Handle tunnel\n                if (this.x < 0) this.x = COLS - 1;\n                if (this.x >= COLS) this.x = 0;\n            }\n\n            update() {\n                if (this.isScared) {\n                    this.scaredTimer--;\n                    if (this.scaredTimer <= 0) {\n                        this.isScared = false;\n                    }\n                }\n                this.move();\n            }\n        }\n\n        // Create ghosts\n        const ghosts = [\n            new Ghost(13.5, 14, '#ff0000', 'chaser'),    // Red - Blinky\n            new Ghost(13.5, 14, '#ffb8ff', 'ambusher'),  // Pink - Pinky\n            new Ghost(11.5, 14, '#00ffff', 'random'),    // Cyan - Inky\n            new Ghost(15.5, 14, '#ffb852', 'random')     // Orange - Clyde\n        ];\n\n        // Input handling\n        const keys = {};\n        document.addEventListener('keydown', (e) => {\n            keys[e.key] = true;\n            \n            if (gameRunning) {\n                if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') {\n                    pacman.nextDirection = 'up';\n                } else if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') {\n                    pacman.nextDirection = 'down';\n                } else if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') {\n                    pacman.nextDirection = 'left';\n                } else if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') {\n                    pacman.nextDirection = 'right';\n                }\n            }\n        });\n\n        document.addEventListener('keyup', (e) => {\n            keys[e.key] = false;\n        });\n\n        function canMove(x, y, direction) {\n            let newX = x;\n            let newY = y;\n            \n            if (direction === 'up') newY = Math.floor(y - 0.5);\n            else if (direction === 'down') newY = Math.ceil(y + 0.5);\n            else if (direction === 'left') newX = Math.floor(x - 0.5);\n            else if (direction === 'right') newX = Math.ceil(x + 0.5);\n            \n            if (newY < 0 || newY >= ROWS || newX < 0 || newX >= COLS) {\n                return direction === 'left' || direction === 'right'; // Allow tunnel\n            }\n            \n            return map[newY][newX] !== 1;\n        }\n\n        function updatePacman() {\n            pacman.animationCounter++;\n            \n            // Try to change direction\n            if (pacman.nextDirection && canMove(pacman.x, pacman.y, pacman.nextDirection)) {\n                pacman.direction = pacman.nextDirection;\n                pacman.nextDirection = null;\n            }\n            \n            // Move Pac-Man\n            if (canMove(pacman.x, pacman.y, pacman.direction)) {\n                if (pacman.direction === 'up') pacman.y -= pacman.speed;\n                else if (pacman.direction === 'down') pacman.y += pacman.speed;\n                else if (pacman.direction === 'left') pacman.x -= pacman.speed;\n                else if (pacman.direction === 'right') pacman.x += pacman.speed;\n            }\n            \n            // Handle tunnel\n            if (pacman.x < 0) pacman.x = COLS - 1;\n            if (pacman.x >= COLS) pacman.x = 0;\n            \n            // Eat dots\n            const gridX = Math.round(pacman.x);\n            const gridY = Math.round(pacman.y);\n            \n            if (map[gridY][gridX] === 0) {\n                map[gridY][gridX] = 3;\n                score += 10;\n                dotsEaten++;\n            } else if (map[gridY][gridX] === 2) {\n                map[gridY][gridX] = 3;\n                score += 50;\n                dotsEaten++;\n                powerMode = true;\n                powerModeTimer = 500; // About 8 seconds\n                \n                ghosts.forEach(ghost => {\n                    if (!ghost.isDead) {\n                        ghost.isScared = true;\n                        ghost.scaredTimer = 500;\n                    }\n                });\n            }\n            \n            // Check ghost collision\n            ghosts.forEach(ghost => {\n                const dist = Math.sqrt(Math.pow(ghost.x - pacman.x, 2) + Math.pow(ghost.y - pacman.y, 2));\n                \n                if (dist < 0.8) {\n                    if (ghost.isScared && !ghost.isDead) {\n                        ghost.isDead = true;\n                        ghost.isScared = false;\n                        score += 200;\n                    } else if (!ghost.isDead) {\n                        loseLife();\n                    }\n                }\n            });\n            \n            // Check win condition\n            if (dotsEaten >= totalDots) {\n                nextLevel();\n            }\n        }\n\n        function loseLife() {\n            lives--;\n            updateScore();\n            \n            if (lives <= 0) {\n                endGame();\n            } else {\n                resetPositions();\n            }\n        }\n\n        function resetPositions() {\n            pacman.x = 13.5;\n            pacman.y = 23;\n            pacman.direction = 'right';\n            pacman.nextDirection = null;\n            \n            ghosts.forEach(ghost => ghost.reset());\n        }\n\n        function nextLevel() {\n            level++;\n            resetMap();\n            resetPositions();\n            \n            // Increase difficulty\n            ghosts.forEach(ghost => {\n                ghost.speed = Math.min(0.15, ghost.speed + 0.01);\n            });\n        }\n\n        function updateScore() {\n            document.getElementById('score').textContent = `Score: ${score}`;\n            document.getElementById('lives').textContent = `Lives: ${lives}`;\n            \n            if (score > highScore) {\n                highScore = score;\n                localStorage.setItem('pacmanHighScore', highScore);\n                document.getElementById('highScore').textContent = `High: ${highScore}`;\n            }\n        }\n\n        function draw() {\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            \n            // Draw maze\n            for (let row = 0; row < ROWS; row++) {\n                for (let col = 0; col < COLS; col++) {\n                    const x = col * CELL_SIZE;\n                    const y = row * CELL_SIZE;\n                    \n                    if (map[row][col] === 1) {\n                        ctx.fillStyle = '#2121ff';\n                        ctx.fillRect(x, y, CELL_SIZE, CELL_SIZE);\n                    } else if (map[row][col] === 0) {\n                        ctx.fillStyle = '#ffb897';\n                        ctx.beginPath();\n                        ctx.arc(x + CELL_SIZE/2, y + CELL_SIZE/2, 2, 0, Math.PI * 2);\n                        ctx.fill();\n                    } else if (map[row][col] === 2) {\n                        ctx.fillStyle = '#ffb897';\n                        ctx.beginPath();\n                        ctx.arc(x + CELL_SIZE/2, y + CELL_SIZE/2, 6, 0, Math.PI * 2);\n                        ctx.fill();\n                    }\n                }\n            }\n            \n            // Draw Pac-Man\n            ctx.fillStyle = '#ffff00';\n            ctx.beginPath();\n            const mouthAngle = Math.abs(Math.sin(pacman.animationCounter * 0.1)) * 0.3;\n            let startAngle = mouthAngle;\n            let endAngle = Math.PI * 2 - mouthAngle;\n            \n            if (pacman.direction === 'up') {\n                startAngle = Math.PI * 1.5 + mouthAngle;\n                endAngle = Math.PI * 1.5 - mouthAngle;\n            } else if (pacman.direction === 'down') {\n                startAngle = Math.PI * 0.5 + mouthAngle;\n                endAngle = Math.PI * 0.5 - mouthAngle;\n            } else if (pacman.direction === 'left') {\n                startAngle = Math.PI + mouthAngle;\n                endAngle = Math.PI - mouthAngle;\n            }\n            \n            ctx.arc(pacman.x * CELL_SIZE + CELL_SIZE/2, pacman.y * CELL_SIZE + CELL_SIZE/2, \n                    CELL_SIZE/2 - 2, startAngle, endAngle);\n            ctx.lineTo(pacman.x * CELL_SIZE + CELL_SIZE/2, pacman.y * CELL_SIZE + CELL_SIZE/2);\n            ctx.fill();\n            \n            // Draw ghosts\n            ghosts.forEach(ghost => {\n                const ghostX = ghost.x * CELL_SIZE + CELL_SIZE/2;\n                const ghostY = ghost.y * CELL_SIZE + CELL_SIZE/2;\n                \n                if (ghost.isDead) {\n                    // Draw eyes only\n                    ctx.fillStyle = 'white';\n                    ctx.beginPath();\n                    ctx.arc(ghostX - 5, ghostY - 5, 3, 0, Math.PI * 2);\n                    ctx.arc(ghostX + 5, ghostY - 5, 3, 0, Math.PI * 2);\n                    ctx.fill();\n                    \n                    ctx.fillStyle = 'blue';\n                    ctx.beginPath();\n                    ctx.arc(ghostX - 5, ghostY - 5, 1.5, 0, Math.PI * 2);\n                    ctx.arc(ghostX + 5, ghostY - 5, 1.5, 0, Math.PI * 2);\n                    ctx.fill();\n                } else {\n                    // Ghost body\n                    ctx.fillStyle = ghost.isScared ? \n                        (ghost.scaredTimer < 100 && Math.floor(ghost.scaredTimer / 10) % 2 ? 'white' : 'blue') : \n                        ghost.color;\n                    \n                    ctx.beginPath();\n                    ctx.arc(ghostX, ghostY - 3, CELL_SIZE/2 - 2, Math.PI, 0, false);\n                    ctx.lineTo(ghostX + CELL_SIZE/2 - 2, ghostY + CELL_SIZE/2 - 4);\n                    \n                    // Wavy bottom\n                    for (let i = 0; i < 3; i++) {\n                        ctx.quadraticCurveTo(\n                            ghostX + CELL_SIZE/2 - 6 - i * 6, \n                            ghostY + CELL_SIZE/2 - 2,\n                            ghostX + CELL_SIZE/2 - 8 - i * 6, \n                            ghostY + CELL_SIZE/2 - 4\n                        );\n                    }\n                    \n                    ctx.closePath();\n                    ctx.fill();\n                    \n                    // Eyes\n                    if (!ghost.isScared) {\n                        ctx.fillStyle = 'white';\n                        ctx.beginPath();\n                        ctx.arc(ghostX - 5, ghostY - 5, 3, 0, Math.PI * 2);\n                        ctx.arc(ghostX + 5, ghostY - 5, 3, 0, Math.PI * 2);\n                        ctx.fill();\n                        \n                        ctx.fillStyle = 'blue';\n                        ctx.beginPath();\n                        ctx.arc(ghostX - 5 + (ghost.direction === 'left' ? -1 : ghost.direction === 'right' ? 1 : 0), \n                               ghostY - 5 + (ghost.direction === 'up' ? -1 : ghost.direction === 'down' ? 1 : 0), \n                               1.5, 0, Math.PI * 2);\n                        ctx.arc(ghostX + 5 + (ghost.direction === 'left' ? -1 : ghost.direction === 'right' ? 1 : 0), \n                               ghostY - 5 + (ghost.direction === 'up' ? -1 : ghost.direction === 'down' ? 1 : 0), \n                               1.5, 0\n```javascript\n                               1.5, 0, Math.PI * 2);\n                        ctx.fill();\n                    } else {\n                        // Scared face\n                        ctx.strokeStyle = 'white';\n                        ctx.lineWidth = 2;\n                        ctx.beginPath();\n                        ctx.moveTo(ghostX - 7, ghostY + 3);\n                        ctx.lineTo(ghostX - 3, ghostY + 6);\n                        ctx.lineTo(ghostX, ghostY + 3);\n                        ctx.lineTo(ghostX + 3, ghostY + 6);\n                        ctx.lineTo(ghostX + 7, ghostY + 3);\n                        ctx.stroke();\n                        \n                        ctx.fillStyle = 'white';\n                        ctx.fillRect(ghostX - 6, ghostY - 6, 3, 3);\n                        ctx.fillRect(ghostX + 3, ghostY - 6, 3, 3);\n                    }\n                }\n            });\n            \n            // Draw power mode indicator\n            if (powerMode) {\n                ctx.fillStyle = `rgba(255, 255, 255, ${0.1 + Math.sin(Date.now() * 0.01) * 0.05})`;\n                ctx.fillRect(0, 0, canvas.width, canvas.height);\n            }\n        }\n\n        function update() {\n            if (!gameRunning) return;\n            \n            updatePacman();\n            ghosts.forEach(ghost => ghost.update());\n            \n            if (powerMode) {\n                powerModeTimer--;\n                if (powerModeTimer <= 0) {\n                    powerMode = false;\n                }\n            }\n            \n            updateScore();\n        }\n\n        function gameStep() {\n            update();\n            draw();\n            \n            if (gameRunning) {\n                requestAnimationFrame(gameStep);\n            }\n        }\n\n        function startGame() {\n            document.getElementById('startScreen').classList.add('hidden');\n            document.getElementById('gameOver').classList.add('hidden');\n            \n            resetMap();\n            resetPositions();\n            score = 0;\n            lives = 3;\n            level = 1;\n            powerMode = false;\n            powerModeTimer = 0;\n            gameRunning = true;\n            \n            updateScore();\n            document.getElementById('highScore').textContent = `High: ${highScore}`;\n            \n            gameStep();\n        }\n\n        function endGame() {\n            gameRunning = false;\n            document.getElementById('finalScore').textContent = score;\n            document.getElementById('gameOver').classList.remove('hidden');\n        }\n\n        function resetGame() {\n            startGame();\n        }\n\n        // Initialize\n        window.onload = () => {\n            document.getElementById('highScore').textContent = `High: ${highScore}`;\n            draw(); // Draw initial maze\n        };\n    </script>\n</body>\n</html>\n```"
}