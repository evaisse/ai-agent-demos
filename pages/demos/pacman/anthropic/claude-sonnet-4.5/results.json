{
  "timestamp": "2025-10-02T13:05:53.108Z",
  "execution": {
    "duration_seconds": "73.198",
    "model_used": "anthropic/claude-sonnet-4.5",
    "model_requested": "anthropic/claude-sonnet-4.5"
  },
  "tokens": {
    "prompt_tokens": 37,
    "completion_tokens": 6839,
    "total_tokens": 6876
  },
  "cost": {
    "currency": "USD",
    "prompt_cost": 0.000111,
    "completion_cost": 0.102585,
    "total_cost": 0.102696
  },
  "model_card": {
    "id": "anthropic/claude-sonnet-4.5",
    "name": "Anthropic: Claude Sonnet 4.5",
    "description": "Claude Sonnet 4.5 is Anthropicâ€™s most advanced Sonnet model to date, optimized for real-world agents and coding workflows. It delivers state-of-the-art performance on coding benchmarks such as SWE-bench Verified, with improvements across system design, code security, and specification adherence. The model is designed for extended autonomous operation, maintaining task continuity across sessions and providing fact-based progress tracking.\n\nSonnet 4.5 also introduces stronger agentic capabilities, including improved tool orchestration, speculative parallel execution, and more efficient context and memory management. With enhanced context tracking and awareness of token usage across tool calls, it is particularly well-suited for multi-context and long-running workflows. Use cases span software engineering, cybersecurity, financial analysis, research agents, and other domains requiring sustained reasoning and tool use.",
    "context_length": 1000000,
    "architecture": {
      "input_modalities": [
        "text",
        "image",
        "file"
      ],
      "instruct_type": null,
      "modality": "text+image->text",
      "output_modalities": [
        "text"
      ],
      "tokenizer": "Claude"
    },
    "pricing": {
      "completion": "0.000015",
      "image": "0.0048",
      "input_cache_read": "0.0000003",
      "input_cache_write": "0.00000375",
      "internal_reasoning": "0",
      "prompt": "0.000003",
      "request": "0",
      "web_search": "0"
    },
    "top_provider": {
      "context_length": 1000000,
      "is_moderated": true,
      "max_completion_tokens": 64000
    }
  },
  "request": {
    "prompt": "In a single HTML file named index.html, create exact copy of the PAC-MAN game in one html file using css and js.\n",
    "system_prompt": null,
    "temperature": 0.7,
    "max_tokens": 8000
  },
  "response_metadata": {
    "id": "gen-1759410280-xs6RA3qKxItoPyHx0lqn",
    "created": 1759410280,
    "object": "chat.completion"
  },
  "raw_response": "```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>PAC-MAN Game</title>\n    <style>\n        * {\n            margin: 0;\n            padding: 0;\n            box-sizing: border-box;\n        }\n\n        body {\n            background: #000;\n            display: flex;\n            justify-content: center;\n            align-items: center;\n            min-height: 100vh;\n            font-family: 'Courier New', monospace;\n            overflow: hidden;\n        }\n\n        #gameContainer {\n            text-align: center;\n        }\n\n        #score {\n            color: #fff;\n            font-size: 24px;\n            margin-bottom: 10px;\n            display: flex;\n            justify-content: space-between;\n            width: 560px;\n        }\n\n        #canvas {\n            border: 2px solid #00f;\n            background: #000;\n            display: block;\n        }\n\n        #gameOver {\n            position: absolute;\n            top: 50%;\n            left: 50%;\n            transform: translate(-50%, -50%);\n            color: #ff0;\n            font-size: 48px;\n            display: none;\n            text-shadow: 3px 3px #f00;\n        }\n\n        #instructions {\n            color: #0ff;\n            margin-top: 10px;\n            font-size: 14px;\n        }\n    </style>\n</head>\n<body>\n    <div id=\"gameContainer\">\n        <div id=\"score\">\n            <span>SCORE: <span id=\"scoreValue\">0</span></span>\n            <span>LIVES: <span id=\"lives\">3</span></span>\n        </div>\n        <canvas id=\"canvas\" width=\"560\" height=\"620\"></canvas>\n        <div id=\"gameOver\">GAME OVER!</div>\n        <div id=\"instructions\">Use Arrow Keys to Move | Press SPACE to Restart</div>\n    </div>\n\n    <script>\n        const canvas = document.getElementById('canvas');\n        const ctx = canvas.getContext('2d');\n        const scoreElement = document.getElementById('scoreValue');\n        const livesElement = document.getElementById('lives');\n        const gameOverElement = document.getElementById('gameOver');\n\n        const TILE_SIZE = 20;\n        const COLS = 28;\n        const ROWS = 31;\n\n        // Game state\n        let score = 0;\n        let lives = 3;\n        let gameRunning = true;\n        let powerPelletActive = false;\n        let powerPelletTimer = 0;\n\n        // Maze layout (1 = wall, 0 = dot, 2 = power pellet, 3 = empty, 4 = ghost house)\n        const maze = [\n            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],\n            [1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1],\n            [1,0,1,1,1,1,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,1,1,1,1,0,1],\n            [1,2,1,1,1,1,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,1,1,1,1,2,1],\n            [1,0,1,1,1,1,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,1,1,1,1,0,1],\n            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],\n            [1,0,1,1,1,1,0,1,1,0,1,1,1,1,1,1,1,1,0,1,1,0,1,1,1,1,0,1],\n            [1,0,1,1,1,1,0,1,1,0,1,1,1,1,1,1,1,1,0,1,1,0,1,1,1,1,0,1],\n            [1,0,0,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,0,0,1],\n            [1,1,1,1,1,1,0,1,1,1,1,1,3,1,1,3,1,1,1,1,1,0,1,1,1,1,1,1],\n            [1,1,1,1,1,1,0,1,1,1,1,1,3,1,1,3,1,1,1,1,1,0,1,1,1,1,1,1],\n            [1,1,1,1,1,1,0,1,1,3,3,3,3,3,3,3,3,3,3,1,1,0,1,1,1,1,1,1],\n            [1,1,1,1,1,1,0,1,1,3,1,1,1,4,4,1,1,1,3,1,1,0,1,1,1,1,1,1],\n            [1,1,1,1,1,1,0,1,1,3,1,4,4,4,4,4,4,1,3,1,1,0,1,1,1,1,1,1],\n            [3,3,3,3,3,3,0,3,3,3,1,4,4,4,4,4,4,1,3,3,3,0,3,3,3,3,3,3],\n            [1,1,1,1,1,1,0,1,1,3,1,4,4,4,4,4,4,1,3,1,1,0,1,1,1,1,1,1],\n            [1,1,1,1,1,1,0,1,1,3,1,1,1,1,1,1,1,1,3,1,1,0,1,1,1,1,1,1],\n            [1,1,1,1,1,1,0,1,1,3,3,3,3,3,3,3,3,3,3,1,1,0,1,1,1,1,1,1],\n            [1,1,1,1,1,1,0,1,1,3,1,1,1,1,1,1,1,1,3,1,1,0,1,1,1,1,1,1],\n            [1,1,1,1,1,1,0,1,1,3,1,1,1,1,1,1,1,1,3,1,1,0,1,1,1,1,1,1],\n            [1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1],\n            [1,0,1,1,1,1,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,1,1,1,1,0,1],\n            [1,0,1,1,1,1,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,1,1,1,1,0,1],\n            [1,2,0,0,1,1,0,0,0,0,0,0,0,3,3,0,0,0,0,0,0,0,1,1,0,0,2,1],\n            [1,1,1,0,1,1,0,1,1,0,1,1,1,1,1,1,1,1,0,1,1,0,1,1,0,1,1,1],\n            [1,1,1,0,1,1,0,1,1,0,1,1,1,1,1,1,1,1,0,1,1,0,1,1,0,1,1,1],\n            [1,0,0,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,0,0,1],\n            [1,0,1,1,1,1,1,1,1,1,1,1,0,1,1,0,1,1,1,1,1,1,1,1,1,1,0,1],\n            [1,0,1,1,1,1,1,1,1,1,1,1,0,1,1,0,1,1,1,1,1,1,1,1,1,1,0,1],\n            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],\n            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\n        ];\n\n        // Create a copy for dots tracking\n        let dots = JSON.parse(JSON.stringify(maze));\n\n        // Pac-Man\n        const pacman = {\n            x: 14,\n            y: 23,\n            direction: 0, // 0: right, 1: down, 2: left, 3: up\n            nextDirection: 0,\n            mouthOpen: 0,\n            speed: 2\n        };\n\n        // Ghosts\n        const ghosts = [\n            { x: 14, y: 11, color: '#f00', startX: 14, startY: 11, direction: 0, name: 'blinky', scatterX: 25, scatterY: 0 },\n            { x: 12, y: 14, color: '#ffb8ff', startX: 12, startY: 14, direction: 3, name: 'pinky', scatterX: 2, scatterY: 0 },\n            { x: 14, y: 14, color: '#00ffff', startX: 14, startY: 14, direction: 3, name: 'inky', scatterX: 27, scatterY: 29 },\n            { x: 16, y: 14, color: '#ffb851', startX: 16, startY: 14, direction: 3, name: 'clyde', scatterX: 0, scatterY: 29 }\n        ];\n\n        let ghostMode = 'scatter';\n        let modeTimer = 0;\n        let frightenedGhosts = [];\n\n        // Direction vectors\n        const directions = [\n            { x: 1, y: 0 },   // right\n            { x: 0, y: 1 },   // down\n            { x: -1, y: 0 },  // left\n            { x: 0, y: -1 }   // up\n        ];\n\n        // Input handling\n        document.addEventListener('keydown', (e) => {\n            if (!gameRunning && e.code === 'Space') {\n                resetGame();\n                return;\n            }\n\n            switch(e.code) {\n                case 'ArrowRight':\n                    pacman.nextDirection = 0;\n                    break;\n                case 'ArrowDown':\n                    pacman.nextDirection = 1;\n                    break;\n                case 'ArrowLeft':\n                    pacman.nextDirection = 2;\n                    break;\n                case 'ArrowUp':\n                    pacman.nextDirection = 3;\n                    break;\n            }\n            e.preventDefault();\n        });\n\n        function drawMaze() {\n            for (let row = 0; row < ROWS; row++) {\n                for (let col = 0; col < COLS; col++) {\n                    const cell = maze[row][col];\n                    const x = col * TILE_SIZE;\n                    const y = row * TILE_SIZE;\n\n                    if (cell === 1) {\n                        // Wall\n                        ctx.strokeStyle = '#2121ff';\n                        ctx.lineWidth = 2;\n                        ctx.strokeRect(x + 1, y + 1, TILE_SIZE - 2, TILE_SIZE - 2);\n                    }\n                }\n            }\n        }\n\n        function drawDots() {\n            for (let row = 0; row < ROWS; row++) {\n                for (let col = 0; col < COLS; col++) {\n                    const cell = dots[row][col];\n                    const x = col * TILE_SIZE + TILE_SIZE / 2;\n                    const y = row * TILE_SIZE + TILE_SIZE / 2;\n\n                    if (cell === 0) {\n                        // Regular dot\n                        ctx.fillStyle = '#ffb897';\n                        ctx.beginPath();\n                        ctx.arc(x, y, 2, 0, Math.PI * 2);\n                        ctx.fill();\n                    } else if (cell === 2) {\n                        // Power pellet\n                        ctx.fillStyle = '#ffb897';\n                        ctx.beginPath();\n                        ctx.arc(x, y, 6, 0, Math.PI * 2);\n                        ctx.fill();\n                    }\n                }\n            }\n        }\n\n        function drawPacman() {\n            const x = pacman.x * TILE_SIZE + TILE_SIZE / 2;\n            const y = pacman.y * TILE_SIZE + TILE_SIZE / 2;\n            \n            ctx.fillStyle = '#ffff00';\n            ctx.beginPath();\n            \n            const mouthAngle = 0.2 + Math.abs(Math.sin(pacman.mouthOpen)) * 0.3;\n            const startAngle = mouthAngle + (pacman.direction * Math.PI / 2);\n            const endAngle = -mouthAngle + (pacman.direction * Math.PI / 2);\n            \n            ctx.arc(x, y, TILE_SIZE / 2 - 2, startAngle, endAngle);\n            ctx.lineTo(x, y);\n            ctx.fill();\n            \n            pacman.mouthOpen += 0.3;\n        }\n\n        function drawGhost(ghost) {\n            const x = ghost.x * TILE_SIZE + TILE_SIZE / 2;\n            const y = ghost.y * TILE_SIZE + TILE_SIZE / 2;\n            const radius = TILE_SIZE / 2 - 2;\n\n            if (powerPelletActive) {\n                ctx.fillStyle = '#0000ff';\n            } else {\n                ctx.fillStyle = ghost.color;\n            }\n\n            // Body\n            ctx.beginPath();\n            ctx.arc(x, y - radius / 3, radius, Math.PI, 0);\n            ctx.lineTo(x + radius, y + radius);\n            ctx.lineTo(x + radius * 0.66, y + radius * 0.5);\n            ctx.lineTo(x + radius * 0.33, y + radius);\n            ctx.lineTo(x, y + radius * 0.5);\n            ctx.lineTo(x - radius * 0.33, y + radius);\n            ctx.lineTo(x - radius * 0.66, y + radius * 0.5);\n            ctx.lineTo(x - radius, y + radius);\n            ctx.closePath();\n            ctx.fill();\n\n            // Eyes\n            if (powerPelletActive) {\n                ctx.fillStyle = '#fff';\n                ctx.fillRect(x - 5, y - 3, 3, 6);\n                ctx.fillRect(x + 2, y - 3, 3, 6);\n            } else {\n                ctx.fillStyle = '#fff';\n                ctx.beginPath();\n                ctx.arc(x - 5, y - 2, 4, 0, Math.PI * 2);\n                ctx.arc(x + 5, y - 2, 4, 0, Math.PI * 2);\n                ctx.fill();\n\n                ctx.fillStyle = '#000';\n                const eyeOffsetX = directions[ghost.direction].x * 2;\n                const eyeOffsetY = directions[ghost.direction].y * 2;\n                ctx.beginPath();\n                ctx.arc(x - 5 + eyeOffsetX, y - 2 + eyeOffsetY, 2, 0, Math.PI * 2);\n                ctx.arc(x + 5 + eyeOffsetX, y - 2 + eyeOffsetY, 2, 0, Math.PI * 2);\n                ctx.fill();\n            }\n        }\n\n        function canMove(x, y) {\n            if (x < 0 || x >= COLS || y < 0 || y >= ROWS) return true; // Tunnel\n            const cell = maze[y][x];\n            return cell !== 1;\n        }\n\n        function movePacman() {\n            // Try to change direction\n            const nextDir = directions[pacman.nextDirection];\n            const nextX = Math.round(pacman.x + nextDir.x);\n            const nextY = Math.round(pacman.y + nextDir.y);\n            \n            if (canMove(nextX, nextY)) {\n                pacman.direction = pacman.nextDirection;\n            }\n\n            // Move in current direction\n            const dir = directions[pacman.direction];\n            const newX = pacman.x + dir.x * 0.15;\n            const newY = pacman.y + dir.y * 0.15;\n            \n            // Check if can move\n            const checkX = Math.round(newX);\n            const checkY = Math.round(newY);\n            \n            if (canMove(checkX, checkY)) {\n                pacman.x = newX;\n                pacman.y = newY;\n            }\n\n            // Tunnel wrapping\n            if (pacman.x < 0) pacman.x = COLS - 1;\n            if (pacman.x >= COLS) pacman.x = 0;\n\n            // Eat dots\n            const gridX = Math.round(pacman.x);\n            const gridY = Math.round(pacman.y);\n            \n            if (dots[gridY] && dots[gridY][gridX] === 0) {\n                dots[gridY][gridX] = 3;\n                score += 10;\n                scoreElement.textContent = score;\n            } else if (dots[gridY] && dots[gridY][gridX] === 2) {\n                dots[gridY][gridX] = 3;\n                score += 50;\n                scoreElement.textContent = score;\n                activatePowerPellet();\n            }\n\n            // Check win condition\n            checkWin();\n        }\n\n        function activatePowerPellet() {\n            powerPelletActive = true;\n            powerPelletTimer = 180; // 6 seconds at 30fps\n            frightenedGhosts = [...ghosts];\n        }\n\n        function getDistance(x1, y1, x2, y2) {\n            return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);\n        }\n\n        function moveGhost(ghost) {\n            const currentX = Math.round(ghost.x);\n            const currentY = Math.round(ghost.y);\n\n            // Check if at intersection\n            const isAtCenter = Math.abs(ghost.x - currentX) < 0.1 && Math.abs(ghost.y - currentY) < 0.1;\n\n            if (isAtCenter) {\n                ghost.x = currentX;\n                ghost.y = currentY;\n\n                let targetX, targetY;\n\n                if (powerPelletActive) {\n                    // Run away from Pac-Man\n                    targetX = ghost.x - (pacman.x - ghost.x);\n                    targetY = ghost.y - (pacman.y - ghost.y);\n                } else if (ghostMode === 'scatter') {\n                    targetX = ghost.scatterX;\n                    targetY = ghost.scatterY;\n                } else {\n                    // Chase Pac-Man\n                    targetX = Math.round(pacman.x);\n                    targetY = Math.round(pacman.y);\n                }\n\n                // Find best direction\n                let bestDirection = ghost.direction;\n                let shortestDistance = Infinity;\n\n                for (let i = 0; i < 4; i++) {\n                    // Don't reverse\n                    if (i === (ghost.direction + 2) % 4) continue;\n\n                    const dir = directions[i];\n                    const newX = currentX + dir.x;\n                    const newY = currentY + dir.y;\n\n                    if (canMove(newX, newY)) {\n                        const distance = getDistance(newX, newY, targetX, targetY);\n                        if (distance < shortestDistance) {\n                            shortestDistance = distance;\n                            bestDirection = i;\n                        }\n                    }\n                }\n\n                ghost.direction = bestDirection;\n            }\n\n            // Move ghost\n            const dir = directions[ghost.direction];\n            ghost.x += dir.x * 0.08;\n            ghost.y += dir.y * 0.08;\n\n            // Tunnel wrapping\n            if (ghost.x < 0) ghost.x = COLS - 1;\n            if (ghost.x >= COLS) ghost.x = 0;\n        }\n\n        function checkCollisions() {\n            ghosts.forEach(ghost => {\n                const distance = getDistance(pacman.x, pacman.y, ghost.x, ghost.y);\n                if (distance < 0.5) {\n                    if (powerPelletActive) {\n                        // Eat ghost\n                        score += 200;\n                        scoreElement.textContent = score;\n                        ghost.x = ghost.startX;\n                        ghost.y = ghost.startY;\n                    } else {\n                        // Lose life\n                        loseLife();\n                    }\n                }\n            });\n        }\n\n        function loseLife() {\n            lives--;\n            livesElement.textContent = lives;\n\n            if (lives <= 0) {\n                gameOver();\n            } else {\n                resetPositions();\n            }\n        }\n\n        function resetPositions() {\n            pacman.x = 14;\n            pacman.y = 23;\n            pacman.direction = 0;\n            pacman.nextDirection = 0;\n\n            ghosts.forEach(ghost => {\n                ghost.x = ghost.startX;\n                ghost.y = ghost.startY;\n                ghost.direction = 0;\n            });\n        }\n\n        function checkWin() {\n            let dotsRemaining = 0;\n            for (let row = 0; row < ROWS; row++) {\n                for (let col = 0; col < COLS; col++) {\n                    if (dots[row][col] === 0 || dots[row][col] === 2) {\n                        dotsRemaining++;\n                    }\n                }\n            }\n\n            if (dotsRemaining === 0) {\n                score += 1000;\n                scoreElement.textContent = score;\n                resetLevel();\n            }\n        }\n\n        function resetLevel() {\n            dots = JSON.parse(JSON.stringify(maze));\n            resetPositions();\n        }\n\n        function gameOver() {\n            gameRunning = false;\n            gameOverElement.style.display = 'block';\n        }\n\n        function resetGame() {\n            score = 0;\n            lives = 3;\n            gameRunning = true;\n            powerPelletActive = false;\n            scoreElement.textContent = score;\n            livesElement.textContent = lives;\n            gameOverElement.style.display = 'none';\n            dots = JSON.parse(JSON.stringify(maze));\n            resetPositions();\n            modeTimer = 0;\n            ghostMode = 'scatter';\n        }\n\n        function gameLoop() {\n            ctx.fillStyle = '#000';\n            ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n            drawMaze();\n            drawDots();\n            \n            if (gameRunning) {\n                movePacman();\n                \n                ghosts.forEach(ghost => {\n                    moveGhost(ghost);\n                });\n\n                checkCollisions();\n\n                // Update power pellet timer\n                if (powerPelletActive) {\n                    powerPelletTimer--;\n                    if (powerPelletTimer <= 0) {\n                        powerPelletActive = false;\n                    }\n                }\n\n                // Update ghost mode\n                modeTimer++;\n                if (ghostMode === 'scatter' && modeTimer > 210) { // 7 seconds\n                    ghostMode = 'chase';\n                    modeTimer = 0;\n                } else if (ghostMode === 'chase' && modeTimer > 600) { // 20 seconds\n                    ghostMode = 'scatter';\n                    modeTimer = 0;\n                }\n            }\n\n            drawPacman();\n            ghosts.forEach(ghost => drawGhost(ghost));\n\n            requestAnimationFrame(gameLoop);\n        }\n\n        // Start game\n        gameLoop();\n    </script>\n</body>\n</html>\n```\n\nThis is a complete PAC-MAN game implementation in a single HTML file! Here's what's included:\n\n**Features:**\n- Classic PAC-MAN maze layout\n- Pac-Man with animated mouth\n- 4 ghosts (Blinky, Pinky, Inky, Clyde) with different colors\n- Ghost AI with chase and scatter modes\n- Dots and power pellets\n- Power pellet mode (ghosts turn blue and run away)\n- Score tracking\n- Lives system (3 lives)\n- Collision detection\n- Tunnel wrapping on sides\n- Game over and restart functionality\n- Arrow key controls\n- Win condition (all dots collected)\n\n**Controls:**\n- Arrow keys to move Pac-Man\n- Space bar to restart after game over\n\nThe game features authentic Pac-Man gameplay with ghosts that alternate between chasing you and scattering to corners, power pellets that let you eat ghosts, and classic maze navigation!"
}